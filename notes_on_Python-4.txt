
Часть 5. Классы и ООП.  стр. 693


Глава 25. ООП: общая картина.  стр. 695

Весь написанный нами код до этого, был основан  на объектах (object-based) - в сценариях мы передавали объекты, использовали в выражениях, вызывали их методы и т.д. Но чтобы наш код стал по-настоящему объектно-ориентированным (ОО), наши объекты должны участвовать в иерархии наследования.

Мы присутпаем к изучению классов - программных компонентов, используемых для реализации новых типов объектов, поддерживающих наследование. Классы - основные инструменты ООП в Питон. ООП представляет подход к программированию, при котором мы разлагаем код программ на составляющие, чтобы уменьшить его избыточность, и пишем новые программы, адаптируя имеющийся код, а не изменяя его.

Классы создаются с пом. инструкции class. Увидим, чт ообъекты, определяемые с пом. классов, очень напоминают встр. типы знакомые нам. На самом деле классы лишь применяют и дополняют понятия, которые мы уже рассмотрели. Проще - они представляют собой пакеты ф-ций, которые в основном использ. и обрабатывают объекты встр. типов. Основное назнач. классов в том, чтобы создавать и манипулировать новыми объектами, кроме того они поддерживают механизм наследования - иной способ адапатции кода и его повторного использ., чем мы узнали до этого.

ООП в Питно явл-ся необязательным и на первых порах нам можно не использ. классы. Они больше нужны для стратегического программирования (долгосрочная разработка). Но тем неменее классы полезный и мощный инструмент.


Зачем нужны классы?

Помните - "программы выполняют некоторые действия над чем-то"? Так вот классы - это лишь способ определить новое "что-то", они явл-ся отражением реальных объектов в мире программ. Напр. хотим сделать машину для готовки пиццы. Если реализовать её на основе классов, то мы могли бы смоделировать более близкое к реальности строение машины взаимосвязь между её механизмами. Здесь нам полезны два аспекта ООП:

- Наследование. Машина по изготовлению пиццы - это машина и должна иметь характеристики машин как таковых. В терминах ООП это наз-ся "наследованием" свойств более общей категории машин. Эти свойства нужно реализовать всего один раз и их можн обудет использ. для создания любых типов машин нужных нам.

- Композиция. Машина для пиццы состоит из множества компонентов, которые работают как единое целое. Напр. у нас будут манипуляторы (раскатывать тесто напр.), двигатели (надо же чем-то двигать машину) и т.д. На языке ООП наша машина - это пример композиции; она содержит др. объекты, которые активизируются для выполнения определенных действий. Каждый компонент можно оформить как класс.

Общие идеи ООП, как наследование и композиция, применимы к любым приложениям, которые можно разложить на объекты. Напр. интерфейс - набор визуальных элементов управления, кнопок, меток и т.д., которые рисуются на экране в момент, когда выполняется рисование их контейнеров (композиция). Также мы можем создать свои элементы - кнопки с уникальными шрифтами, новые цвета у элементов, вообщем свои специализированные версии общих эелементов (наследование).

Классы - это программ. компоненты Питона, как ф-ции и модули: они представляют собой еще один способ упаковки кода и данных. У классов есть свое пространство имен. Но есть и три важных отличия:

- Множество экземпляров. Классы это как-бы фабрики по созданию объектов. Каждый раз когда вызывается класс, создается объект со своим пространством имен. Объект, созданный из класса, имеет доступ к атрибутам класса и получает своё пространство имен для своих собственных данных, отличных от др. объектов. 

- Адаптация через наследование. Наследование - мы можем расширять возможности класса, переопределяя его атрибуты за пределами самого класса. Классы могут создавать иерархии пространства имен, которые определяют имена для использ-ия объектами, созданными из классов в иерархии.

Перегрузка операторов. Со спец. протоколом оформления методов, классы могут определять объекты, над которыми можно делать операции, которые мы знаем по встр. типам (напр. извлечение среза, конкатенация, индексация и т.д.). Питон предоставляет спец. обработчики для классов, для перехвата и реализации любой встр. операции.



ООП с высоты 30000 футов.  стр. 697

Поиск унаследованных атрибутов.

ООП в Питон проще в изучении и использ-ии чем в С++ или Java. Фактически ООП в Питон сводится к выражению:

object.attribute

Оно нам знакомо и мы его много использовали. Однако когда это выражение применяется к объекту, полученному с пом. class, интерпретатор начинает поиск - поиск в дереве связанных объектов, который заканчивается, как только будет встречено первое появление атрибута attribute. Когда в деле классы это выражение можно перевести так:

- Найти первое вхождение атрибута attribute, просмотрев объект object, а потом все классы в дереве наследования выше него, снизу вверх и слева направо.

Эта процедура поиска также еще наз-ся поиском в дереве наследования. Объекты ниже наследуют атрибуты у объектов выше по дереву.

Т.е. с пом. программ. кода мы действительно создаем деервья связанных объектов и интерпретатор поднимается по этому дереву вверх в поисках атрибутов.

Рисунок 25.1 Дерево классов.  стр. 698 

На рисунке дерево из 5 объектов, помеченных именами переменных. Два эземпляра внизу (I1, I2), класс выше их (С1) и два суперкласса в самом верху (С2 и С3), т.е. два объекта экземпляров и три объекта классов. Эти объекты явл-ся пространствами имен (пакетами переменных), а наследование означает просто поиск снизу вверх, с целью найти самое нижнее вхождение атрибута с нужным именем. Программ. код задает структуру таких деревьев.

Итак, каждый из этих объектов обладает набором атрибутов, а именно - I1.name; I2.name; C1.x, C1.y; C2.x, C2.z; C3.w, C3.z. Заметим, что классы и экземпляры порождаются от двух разных типов объектов:

- Классы. Играют роль фабрик экземпляров. Их атрибуты обеспечивают поведение - данные и функции - т.е. наследуются всеми экземплярами, созданными от них (напр. ф-ция, считающая зарплату, исходя из часового тарифа).

- Экземпляры. Представляют конкретные элементы программы. Их атрибуты хранят данные, которые могут отличаться в конкретных объектах (напр. номер карточки соц. страхования).

Т.о., по дереву, экземпляры наследуют атрибуты своих классов, а классы наследуют атрибуты классов выше по дереву.

Классы, выше по дереву (С2 и С3), обычно наз. суперклассами (или родительские, базовые), а классы ниже по дереву (С1), обычно наз. подклассами (или дочерние). Суперклассы реализуют общее поведения для подклассов, а подклассы могут переопределять поведение наследуемое от суперкласса, переопределяя имена суперклассов ниже в дереве.

Допустим мы создали дерево по рис. 25.1 и пишем:

I2.w

Этот код демонстрирует наследование. Т.к. это выражение вида object.attribute, оно приводит к запуску  поиска в дереве - интерпретатор ищет атрибут w начиная с I2 и идет вверх. Порядок такой - I2, C1, C2, C3.
Остановится когда найдет атрибут или возбудит исключение если w не найдет вообще. Т.о. автоматич. поиск найдет имя I2.w как C2.w. В терминологии ООП это наз-ся I2 "наследует" атрибут w от C3.

В итоге видим, что два экземпляра наследуют от своих классов 4 атрибута: w, x, y, z. Другие атрибуты будут анйдены в различ. местах в дереве. Например:

- Для I1.x  и I2.x атрибут х будет найден в С1, где поиск остановится, т.к. С1 нах-ся ниже в дереве чем С2.

- Для I1.y и I2.y атрибут y будет найден в С1, где поиск остановится, т.к. это единственное место где он появл-ся.

- Для I1.z и I2.z атрибут z будет найден в С2, т.к. С2 нах-ся в дереве левее чем С3.

- Для I2.name атрибут name будет найден в I2, т.к. в этом случае поиск вообще не будет идти по дереву.

Обратите внимание на атрибут х в С1, т.к. мы видим, что С1 переопределяет этот атрибут ниже в дереве, тем самым замещая версию атрибута, расположенную выше в С2. Ниже мы увидим, что такие переопределения составляют основу адаптации программ. обеспечения в ООП.


Классы и экземпляры.  стр. 700

Классы и экземпляры (отдельные типы объектов) вып-ют почти одну роль: каждый из этих типов служит неким представлением пространства имен - пакета переменных и места, где определяются атрибуты. Т.о. можно сказать, что классы и экземпляры похожи на модули, при этом объекты в деревьях классов содержат автоматически определяемые ссылки на др. объекты пространств имен, и классы соотв. инструкциям, а не файлам.

Различие между ними такое, что классы представляют собой своего рода фабрики по производству экземпляров. Напр. есть класс Employee, определяющих характеристики служащего - из этого класса мы можем создавать фактические экземпляры класса Employee.
Это еще одно отличие классов от модулей: у нас всегда есть всего один экземпляр модуля в памяти (поэтмоу мы его и перезагружаем при необходимости), но экземпляров класса мы можем сделать сколько хотим.

У классов обычно есть ф-ции, присоединенные к ним (пр. computeSalary), а у экземпляров - элементы данных, используемые ф-циями класса (пр. hoursWorked). Фактически модель ООП не так сильн оотличается от классич. модели обработки данных, основанной на программах и записях, - в ООП экземпляры подобны записям с "данными", а классы - "программам", обрабатывающим эти данные. Однако в ООП есть еще иерархия наследования.


Вызовы методов классов.

Выше мы видели как атрибут I2.w в нашем дереве классов транслируется в C3.w при поиске. Нуэно понимать и знать, что точно так же наследуются и методы (т.е. ф-ции, присоединенные к классам в виде атрибутов).

Если ссылка I2.w - это вызов ф-ции, то оно означает: "вызвать ф-цию C3.w для обработки I2". Т.е. интерпретатор автоматич. отобразит вызов I2.w() на вызов C3.w(), передав унаследованной ф-ции экземпляр в виде первого аргумента.

Фактич. всякий раз когда вызывается ф-ция, присоединенная к классу, подразумевается не класс целиком, а экземпляр класса. Этот экземпляр, или контекст, явл-ся одной из причин, почему данная модель названа объектно-ориентированной, - всегда существует объект, над которым выполняются действия. Напр. мы вызываем метод giveRaise, присоедиенный как атрибут к классу Employee, - вызов этого метода не имел бы смысла без указания служащего, которому дается надбавка к зарплате.

Как мы узнаем далее, Питон передает методам подразумеваемый экземпляр в виде спец. первого аргумента, в соответствии с соглашением именуемого self. Также узнаем, что методы могут вызываться как через экземпляры (bob.giveRaise()), так и через классы (Employee.giveRaise(bob)).


Создание деревьев классов.

За всеми идеями ООП стоит реальный код. Мы создаем деревья и объекты в них с пом. инструкций class и вызовов классов, которые рассмотрим позднее. В двух словах:

- Каждая инструкция class создает новый объект класса.

- Каждый раз, когда вызывается класс, он создает новый объект экземпляра.

- Экземпляры автомат. свзываются с классами, из которых они были созданы.

- Классы связаны со своими суперклассами, перечисленными в круглых скобках в заголовке инструкции class, при этом порядок следования в списке определяет порядок расположения в дереве.

Например чтобы создать деревео на рис. 25.1 мы можем написать такой код (без реализации классов конечно, она пока не нужна):

class C2: ...				# Создать объекты классов (на рис. это овалы)
class C3: ...
class C1(C2, C3): ...		# Создаем объект класса связанного с суперклассами

I1 = C1()				# Создаем объекты экземпляров (на рис. прямоугольники)
I2 = C1()				# связанные со своими классами

- как видим экземпляры конструируем вызвав класс С1 дважды, как если бы это была обычная ф-ция. Экземпляры помнят класс, из которого они созданы, а класс С1 помнит свои суперклассы.

В этом примере использ-ся т.н. множественное наследование, которое означает, что некий класс имеет более одного суперкласса над собой в дереве классов. А порядок суперклассов с кобках определяет порядок поиска атрибутов.

Большое значени имеет  то, к какому из объектов присоединяется тот или иной атрибут - что определяет его область видимости. Атрибуты, присоединямые к экземплярам, принадлежат только этим конкретным экземплярам, но атрибуты, присоединенные к классам, использ-ся и подклассами и экземплярами. Далее увидим, что:

- Атрибуты обычно присоед-ся к классам с пом. инструкций присваивания внутри class, а не во вложенных инструкциях def, определяющих ф-ции.

- Атрибуты обычно присоед-ся к экземплярам с пом. присваивания значений спец. аргументу с именем self, передаваемому ф-циям внутри классов.

Напр. классы поределяют поведение своих экземпляров с пом. ф-ций, создаваемых def внутри инструкций class. А т.к. такие влож. инструкции def выполняют присваивание именам внутри класса, они присоед-ся к объектам классов в виде атрибутов и будут унаследованы всеми экземплярами и подклассами:

class C1(C2, C3):					# Создать и связать класс С1
	def setname(self, who):			# Присвоить: С1.setname
		self.name = who				# self - либо I1, либо I2

I1 = C1()						# Создать два экземпляра
I2 = C1()
I1.setname('bob')				# Записать 'bob' в I1.name
I2.setname('mel')				# Записать 'mel' в I2.name 
print(I1.name)					# Выведет 'bob'

Синтаксис инструкции def здесь самый обычный. С функциональной точки зрения, когда def появл-ся внутри инструкции class, как в нашем примере, она обычно наз-ся методом и автомат. принимает спец. первый аргумент с именем self, который содержит ссылку на обрабатываемый экземпляр.

Примечание. Если бы мы ранее изучали С++ или Java, то заметили бы, что в Питон имя self - это то же, что и указатель this, но в языке Питон аргумент self всегда использ-ся явно, чтобы сделать обращения к атрибутам более очевидным.

Т.к. классы способны делать множество экземпляров их методы использ-т этот, получаемый автоматически, аргумент self для получения или изменения атрибутов конкретного экземпляра, который обрабатывается методом. В нашем прим. имя self использ-ся для сохранения имени служащего в конкретном экземпляре.

Как и простые переменные, атрибуты классов и экземпляров не объявляются заранее, а появл-ся когда им присв-ся значение. Когда метод присв-ет значение атрибуту с пом. имени self, он т.о. создает атрибут экземпляра, находящегося в нижнем уровне дерева классов, потмоу что имя self автоматич. ссылается на обрабатываемый экземпляр.

Благодаря тому, что все объекты дерева классов - всего лишь объекты пространств имен, можно получать или устанавливать любой из их атрибутов, используя соотв. имена. Например выражение C1.setname явл-ся таким же допустимым, как и I1.setname, с условием, что имена C1 и I1 находятся в области видимости программ. кода.

Сейчас класс С1 не присоед-ет атрибут name к экземплярам, пока не будет вызван метод setname. Если нужно, чтобы атрибут name всегда присутствовал в экземплярах, то он должен создаваться на этапе создания калсса:

class C1(C2, C3):					
	def __init__(self, who):		# Создать имя при создании класса
		self.name = who				# self - либо I1, либо I2

I1 = C1('bob')					# Записать 'bob' в I1.name
I2 = C1('mel')					# Записать 'mel' в I2.name 
print(I1.name)					# Выведет 'bob'
 
При таком решении интерпретатор автоматич. будет вызывать метод с именем __init__ каждый раз при создании экземпляра класса. Новый экземпляр будут передаваться методу __init__ в виде первого аргумента self, а любые значения, перечисленные в круглых скобках при вызове класса, будут передаваться во втором и последующих аргументах. Т.о. инициализация экземпляров будет выполняться в момент их создания.

Метод __init__ известен как конструктор, т.к. он запускается на этапе конструирования экземпляра. Этот метод явл-ся представителем класса методов, которые наз-ся методами перегрузки операторов. Такие методы наслед-ся в дереве как обычно, а их миена нач-ся и закан-ся двумя подчеркиваниями. Интерпретатор вызывает их автоматич. когда экземпляры, поддерживающие их, участвуют в соответствующих операциях, и они, глав. образом, явл-ся альтернативой вызовам простых методов. Так же они не обязательны, если их нет то соотв. операции просто не поддерживаются экземплярами.


ООП - это многократное использование программного кода.

Конечно в ООП есть не только наследование. Напр. перегрузка операторов может применяться в др. случаях - классы могут предоставлять свои реализации таких операций как доступ по индексу, получение значений атрибутов, выво ди мн. др. Но вообще ООП реализует поиск атрибутов в деревьях.

Используя классы мы адаптируем программы, вместо того, чтобы изменять код или писать новый в каждом проекте - ООП дает нам способы многократного использования программ. кода.             

Классы это действительно лишь пакеты ф-ций и др. имен, которые напоминают во многом модули. Но также они обеспечивают удобную структуру размещения кода и переменных. И, в отличие от ф-ций и модулей, благодаря дереву наследования и поиску в нем, дают широкие возможности по адаптации программ. кода.

Напр. методы - это обычные ф-ции со спец. первым аргументом, поэтому мы можем подражать некоторым их чертам поведения, вручную передавая объекты для обработки обычным ф-циям. Методы в наследовании классов дают возможность адаптировать существующее программное обеспечение, создавая новые подклассы, определяющие новые методы, вместо того, чтобы изменять сущзествующий код. Такое невозможно в случае с модулями или ф-циями.

Пример. Пусть нас привлекли к реализации БД, где хранится информация о служащих. На базе ООП мы могли бы начать с реализации суперкласса с общими категориями для служащих:

class Employee:
	def computeSalary(self): ...
	def giveRaise(self): ...
	def promote(self): ...
	def retire(self): ...
	
Реализовав общее можно специализировать его для каждой категории служащих (у них же есть отличия). Т.е. можно создать подклассы, в которых будут изменения на основе отличий от типового представления служащего - а общие черты останутся от суперкласса. Напр. з\п инженера начисляется по особым правилам (не по часовому тарифу например), т.о. нам нужно переопределить всего один метод:

class Engineer(Employee):			# Специализированный подкласс
	def computeSalary(self): ... 	# Особенная реализация метода

- Новая версия computeSalary будет нах-ся в дереве классов ниже и будет замещать (переопределять) общую версию метода в классе Employee. Далее можно будет создавтаь экземпляры разновидностей классов служащих	соответственно с принадлежностью:

bob = Employee()		# Поведение по умолчанию
mel = Engineer()		# Особые правила начисления з\п 

Обратите внимание, что можно создавать экземпляры любых классов в дереве, - класс, экземпляр которого создается, определяет уровень, откуда будет начинаться поиск атрибутов. Напр. в дальнейшем эти два объекта экземпляров (bob и mel) могли бы быть встроены в большой контейнерный объект (напр. список или экземпляр др. класса), котоый представляет отдел или компанию, реализуя идею композиции (см. начало главы).

Если нам понадобится узнать з\п этих служащих можно вычислить её в соотв. с правилами классов этих объектов, благодаря поиску в дереве наследования:

company = [bob, mel]				# Составной объект
for emp in company:
	print(emp.computeSalary())		# Вызвать версию метода данного объекта 

Отметим, что список company мог бы храниться в файле (удобно для БД), например с пом. модуля pickle. Кроме того в Питон входит модуль shelve, который мог бы сохранять экземпляры классов в файлах с доступом по ключу, то же самое обеспечивает сторонняя разработка ZDOB и даже более качественно.


Последний пример - это еще одна разновидность полиморфизма (см. гл. 4 и 16). Т.е. смысл операции зависит от объекта, над которым она выполняется. Здесь метод computeSalary определяется для каждого объекта в дереве наследования. 

В др. приложениях полиморфизм может применяться для сокрытия (т.е. для инкапсуляции) различий интерфейсов. Напр. программа, которая обрабатывает потоки данных, может работать с объектами, имеющими методы ввода и вывода, не заботясь о том, что эти методы делают в действительности:

def processor(reader, converter, writer):
	while 1:
		data = reader.read()
		if not data: break
		data = converter(data)
		writer.rwite(data)
		
Передавая экземпляры классов с необходимыми интерфейсными методами read и write, специализированными под различные источники данных, мы можем использовать одну и ту же ф-цию processor для работы с любыми источниками данных, как уже существующими, так и с тем, что появятся в будущем:

class Reader:
	def read(self): ...				# Поведение и инструменты оп умолчанию
	def other(self): ...
class FileReader(Reader):
	def read(self): ...				# Чтение из локального файла
class SocketReader(Reader): ...
	def read(self): ...				# Чтение из сокета

...
processor(FileReader(...), 		   Converter, FileWriter(...))
processor(SocketReaderReader(...), Converter, TapeWriter(...))
processor(FtpReader(...), 		   Converter, XmlWriter(...))


Благодаря тому, что внутр. реализация методов read и write была разделена по типам источников данных, их можно изменять, не трогая программный код, подобный приведенному, который использует их.
Фактически ф-ция processor сама может быть классом, реализующим логику работы ф-ции преобразования converter, которую могут унаследовать подклассы, и позволяющим встраивать экземпляры, выполняющие чтение и запись, в соотв. с принципом композиции.

Когда мы привыкнем программировать в ООП, то обнаружим, что наша задача сводится к тому, чтобы в новом проекте подобрать уже имеющиеся суперклассы для нашей задачи.

На практике мы можем найти или купить уже готовые библиотеки суперклассов, известные как "фреймворки", в которых задачи программирования реализвоаны в классах. Напр. интерфейсы к БД, протоколы тестирования, создание графич. интерфейса и мн. др.

Конечно для понимания ООП и адаптации кода нужно время, нужно много работать и учиться. Кстати, ряд программистов изучают и составляют списки наиболее часто встречающихся решений в ООП, сейчас они известны как - шаблоны проектирования.    


















Глава 26. Основы программирования классов.  стр. 709 

Теперь мы приступим к изучению синтаксиса модели классов в Питон. В этой главе рассмотрим неск-ко простых классов в действии.

Классы обладают тремя основными отличительными особенностями. На самом простом уровне они представляют собой лиш ьпространства имен, во многом похожие на модули, которые мы изучали в пятой части книги. Но, в отличие от модулей, классы также поддерживают создание множества объектов, реализуют наследуемое пространство имен и перегрузку операторов.


Классы генерируют множество экземпляров объектов.

Чтобы понять эту возможность, для начала нужно понимать, что в ОО модели Питон существует две разновидности объектов: объекты классов и объекты экземпляров. 

Объекты классов реализуют поведение по умолчанию и играют роль фабрик по производству объектов экземпляров.  

Объекты экземпляров - это настоящие объекты, обрабатываемые программой, - каждый представляет собой самостоятельное пространство имен, но наследует имена (т.е. автоматич. имеет доступ к ним) класса, из которого был создан.

Объекты классов считаются инструкциями, а объекты экземпляров - вызовами. Каждый раз когда мы вызываем класс, мы получаем новый экземпляр этого класса. Классы - это фабрики, которые могут воспроизводит ьмножество экземпляров. В противоположность этому каждый модуль может присутствовать в программе в единственном экземпляре.

Как мы увидим ниже классы в Питон сочетают в себе черты, напоминающие ф-ции и модули, но они совершенно не похожи на классы в др. ЯП.


Объекты классов реализуют поведение по умолчанию.

Когда вып-ся инструкция class, она создает объект класса. Приведем неск-ко отличительных характеристик классов в Питон.

- Инструкция class создает объект класса и присваивает ему имя. Как и def, class явл-ся выполняемой инструкцией. Когда она вып-ся она создает новый объект класса и присваивает его имени, указанному в заголовке class. Как и def инструкция class обычно вып-ся при первом импорте содержащих их файлов.

- Операции присваивания внутри инструкции class создают атрибуты класса. Как и в модулях, операции присваивания на верх. уровне (не влож. в инструкции def создают атрибуты объекта класса. Инструкция class преобразует свою область видимости в пространство имен атрибутов объекта класса, так же, как глоабльная область видимости модуля преобразуется в его пространство имен. При выполнении инструкции class атрибуты класса становятся доступны по их составным (полным) именам: object.name.

- Атрибуты класса описывают состояние объекта и его поведение. Т.е. атрибуты хранят информацию о состоянии и описывают поведение, которым обладают все экземпляры класса, - инструкции def, вложенные в class, создают методы, которые обрабатывают экзмепляры.


Объекты экземпляров - это конкретные элементы.

Когда выз-ся объект класса, возвращается объект экземпляра. Приведем неск-ко характеристик экземпляров.

- Вызов объекта класса как функции создает новый объект экземпляра. Когда вызываем класс создается и  возвращается новый объект экземпляра. Экземпляры - это конкретные элементы данных в нашей проге.

- Каждый объект экземпляра наследует атрибуты класса и приобретает свое собственное пространство имен. Экземпляры созд-ся из классов и представляют собой новые пространства имен, они первоначальн опустые, но наследуют атрибуты класса из которого созданы.

- Операции присваивания значений атрибутам, через ссылку self в методах, создают атрибуты в каждом отдельном экземпляре. Методы класса, в первом аргументе (с именем self), получают ссылку на обрабатываемый объект экземпляра - присв-ие атрибутам через ссылку self создает или изменяет даннеы экземпляра, а не класса.


Первый пример.

Определим класс FirstClass в интерактив. оболочке:

>>> class FirstClass:					# Определяет объект класса
		def setdata(self, value):		# Определяет метод класса
			self.data = value			# self - это экземпляр
		def display(self):
			print(self.data)			# self.data - данные экземпляра

Здесь мы работаем в оболочке, но обычно такие инструкции вып-ся во время импорта вмещающего файл модуля. Как и ф-ции, классы не существуют пока интерпретатор не достигнет инструкций class и не выполнит их.

class нач-ся с заголовка (имя класса), затем идет тело класса (как обычно с отступами если нужно). У нас влож. инструкции это инструкции def - они определяют ф-ции, реализующие поведение класса.

Как мы знаем def на самом деле явл-ся операциями присв-ия - в нашем случае они присваивают объекты ф-ций именам setdata и display в области видимости инструкции class и тем самым создают атрибуты, присоединяемые к классу: FirstClass.setdata и FirstClass.display. Т.е. любое имя, которому присв-ся знач. на верх уровне во вложенном блоке класса становится атрибутом этого класса.

Ф-ции внутри классов обычно наз-ся методами. Но в первом аргументы они автоматич. получают подразумеваемый объект экземпляра - конекст вызова метода. Создадим пару экземпляров:

>>> x = FirstClass()
>>> y = FirstClass()

- Создаются два экземпляра с отдельными пространствами имен.

Вызывая класс таким образом мы создаем объекты экземпляров (обратите внимание на круглые скобки), которые явл-ся лишь пространством имен и имеют доступ к атрибутам класса.

Теперь у нас есть три объекта - два экземпляра и класс. Они связаны пространствами имен, по ООП объект х "наследует" класс FirstClass как и y.

Здесь у нас, в дереве наследования, атрибут "data" обнаруживается в экземплярах, а "setdata" и "display" - в классе, расположенном выше их.

Изначально оба экземпляра пустые, но они свзяаны с классом, из которого были созданы. Если через имя экземпляра обратиться к атрибуту объекта класса, то поиск вернет нам значение атрибута класса (при условии, что в экземпляре отсутствует одноименный атрибут):

>>> x.setdata("King Arthur")		# Вызов метода: self - это х
>>> y.setdata(3.14159)				# Эквивалентно: FirstClass.setdata(y, 3.14159)

Ни x, ни y не имеют атрибута setdata, поэтмоу интерпретатор идет по ссылке от экземпляра к классу. В этом и проявл-ся суть наследования в Питон - поиск имен в связанных объектах.

В ф-ции setdata внутри класса FirstClass значение аргумента записывается в self.data. Имя self внутри метода - имя самого первого аргумента, в соответствии с принятым соглашением, - автоматич. ссылается на обрабатываемый экземпляр (x или y), поэтмоу присваивание сохраняет значения в пространстве имен экземпляра, а не класса (так созд-ся имена-атрибуты "data" у экземпляров).

По причине того, что классы могут делать много экземпляров, методы должны использ-ть аргумент self, чтобы получит ьдоступ к обрабатываемому экземпляру. Пр ивызове метода display, чтобы вывести значение атрибутов self.data, мы увидим, что для каждого экземпляра они разные; с др. стороны, имя display само по себе одинаковое в x и y, т.к. оно пришло (унаследовано) из класса:

>>> x.display()			# В каждом экземпляре свои значения self.data
King Arthur
>>> y.display()
3.14159   

Видите - в атрибутах data экземпляров мы сохранили объекты различных типов (строку и число). Как и везде в Питон, атрибуты экземпляров (иногда наз-ся членами) никак не объявл-ся - они появл-ся, как только будет выполнена первая опреация присваивания (как и переменные). Т.е. если вызвать метод display до вызова метода setdata, то получим сообщение об ошибке.

Еще один способ позволяет изменять атрибуты экземпляров в самом классе, выполняя присваивание как с пом. аргумента self внутри методов, так и за пределами класса, когда экземпляр явно участвует в операции присваивания:

>>> x.data = "New value"
>>> x.display()
New value

Хоть это и редко применяется, но сущ-ет возможность создания новых атрибутов в пространстве имен экземпляра, присваивая значение за пределами методов класса:

>>> x.anothername = "spam"

Эта операция присоединит новый атрибут anothername, который затем сможет использ-ся любыми методами класса в объекте экземпляра х. Обычно классы создают все атрибуты экземпляров за счет присваивания значений аргументу self, но это не обязательно - программы могут получать, изменять или создавать атрибуты в любых объектах, к которым имеют доступ.


Классы адаптируются посредством наследования.

Помимо роли фабрик классы позволяют нам вводить новые компоненты (за счет подклассов), а не изменением существующего кода. Объекты экземпляров, созданнеы из класса, наследуют атрибуты класса. Классы могут наследовать др. классы, что открывает нам путь к иерархии классов, поведение которых специализируется за счет переопределения обощенных атрибутов, находящихся выше в дереве классов, подклассами, находящимися ниже. Т.е. чем ниже подклассы тем они спецрализированнее.

В Питон экземпляры наследуют классы, а классы наследуют суперклассы. Опишем основные идеи, лежащие в основе механизма наследования атрибутов:

- Суперклассы перечисляются в круглых скобках в заголовке инструкции class. Т.е., чтобы унаследовать атрибуты класса нужно указать его в кругл. скобках в заголовке инструкции class. Наследующий класс наз-ся подклассом, а наследуемый - суперклассом.

- Классы наследуют атрибуты своих суперклассов. Как экземпляры наследуют атрибуты своих классов, так и классы наследуют все атрибуты, определяемые в суперклассах.

- Экземпляры наследуют атрибуты всех доступных классов. Экземпляр наследует атрибуты своего класса, а также всех суперклассов. Поиск имен сначала проверяет сам экземпляр, потом его класс и потом все суперклассы.     

- Каждое обращение object.attribute вызывает новый независимый поиск. Интерпретатор проводит отдельный поиск в дереве классов для каждого атрибута, который ему встречается в выражении запроса. Сюда входят ссылки на экземпляры и классы из инструкции class (напр. X.attr), а также ссылки на атрибуты аргумента экземпляра self в методах класса. Каждое выражение self.attr в методе вызывает поиск attr в self и выше.

- Изменения в подклассах не затрагивают суперклассы. Замещение имен суперкласса в подклассах изменяет подклассы и тем самым изменяет унаследованное поведение.

Классы обеспечивают разложение на отдельные операции и адаптацию кода лучше, чем это могут сделать др. компоненты языка. Классы позволяют минимизировать избыточность программ. кода, а с др. - позволяют адаптировать уже существующий код, вместо его изменения.


Второй пример.

Итак, второй пример будет основан на предыдущем. Определим новый класс SecondClass, который наследует класс FirstClass и добавляет кое-что своё:

>>> class SecondClass(FirstClass):						# Наследует метод setdata
		def display(self):								# Изменяет метод display				
			print('Current value = "%s"' % self.data)

- т.о. SecondClass замещает атрибут display своего суперкласса.

В этом случае мы говорим, что класс SecondClass переопределяет метод display класса FirstClass. Иногда такая замена атрибутов, за счет переопределения, называется перегрузкой.

Сейчас класс SecondClass специализирует класс FirstClass, изменяя поведение метода display. С др. стороны он наследует метод setdata (как и все экземпляры подкласса). Создадим экземпляр:

>>> z = SecondClass()
>>> z.setdata(42)				# Найдет setdata в FirstClass
>>> z.display()					# Найдет переопределенный метод в SecondClass
Current value = "42"

- думаю нам понятны наследование и поиск и схема пространства имен в этом примере.

Заметим. Специализация, выполненная в классе SecondClass, находится полностью за пределами класса FirstClass. Т.е. она не оказывает влияние на уже созданнеы или создаваемые впоследствии объекты класса FirstClass, напр. х:

>>> x.display()		# Старое значение х (см. выше)
New value 

Т.о. мы не изменяли класс FirstClass, мы адаптировали его. Этот пример показывает нам как можно вносить изменения с пом. внеш. компонентов (подклассов).


Классы - это атрибуты в модулях.

Напомним, что в именах классов нет ничего необычного, это всего лишь переменные, которым присваиваются объекты во время выполнения инструкции class, а ссылки на объекты можно получить с пом. обычных выражений.

Напр. если бы определение класса FirstClass находилось в файле модуля, а не было введено в оболочке, мы могли бы импортировать этот модуль и использовать имя в строке заголовка инструкции class:

from modulename import FirstClass		# Скопировать имя в мою область видимости
class SecondClass(FirstClass):			# Использовать имя класса непосредственно	
	def display(self): ...

Или эквивалентный вариант:

import modulename								# Доступ ко всему модулю целиком
class SecondClass(modulename.FirstClass):		# Указать полное имя 
	def display(self): ...

Имена классов, как и всё остальное, всегда нах-ся в модулях, и поэтому при их употреблении необходимо следовать правилам, которые мы рассматривали в пятой части книги. Напр. в одном модуле могут нах-ся определения сразу нескольких классов - подобно другим инструкциям в модулях, инструкции class выполняются в ходе операции импорта и определяют имена, которые в свою очередь становятся атрибутами модуля.

Вообще любой модуль может содержать самые произвольные сочетания из любого числа переменных, ф-ций и классов, и все эти имена будут вести себя в модуле одинаково. Рассмотрим файл food.py:

# food.py

var = 1			# food.var

def func():		# food.func
	...
class spam:		# food.spam
	...
class ham:		# food.ham
	...
class eggs:		# food.eggs
	...

Это правило остается справедливым даже если модуль и класс имеют одинаковые имена. Например имеется файл person.py:

class person:
	...
	
Чтобы получить доступ к классу нам нужно обратиться к модулю как обычно:

import person				# Импортируем модуль
x = person.person()			# Класс внутри модуля

Имя person.person ссылается на класс person внутри модуля person, если мы просто будем использ-ть имя person, то обратимся к модулю, а не классу, но только если мы не использовали from:

from person import person
x = person()

Как и любые др. переменные, мы не увидим класс в файле модуля, пока не импортируем его или как-то не извлечем класс из вмещающего файла. Если для вас это сложно, то не используйте одинаковые имена для модулей и классов.

Согласно соглашениям, имена классов в Питон должны начинаться с заглавной буквы, для визуального отличия:

import person
x = person.Person()

И еще, несмотря на то, что классы и модули явл-ся пространствами имен для подключения атрибутов, они представляют собой совершенно разные структуры: модуль это отражение целого файла, а класс - лишь инструкция внутри файла.


Классы могут переопределять операторы языка Питон. стр. 717

Перегрузка операторов позволяет объектам, созданным из классов, перехватывать и участвовать в операциях, которые применяются к встроенным типам: сложение, получение среза, вывод, квалификация имен и т.д. 

Можно полностью реализовать класс в виде методов, однако перегрузка операторов позволяет объектам теснее интегрироваться в объектную модель Питона. Кроме того перегрузка позволяет нашим объектам действовать так же, как действуют встр. объекты, потому что она позволяет создавать менее противоречивые и более простые в изучении интерфейсы объектов и обеспечивает возможность обрабатывать объекты, созданные из классов, программным кодом, который предполагает взаимодействие со встр. типами.

Опишем основные идеи, лежащие в основе мехханизма перегрузки операторов:

- Имена методов, начинающиеся и заканчивающиеся двумя символами подчеркивания (__Х__), имеют специальное назначение. Перегрузка реализуется за счет создания методов со спец. именами для перехватывания операций. Питон определяет фиксированные и неизменяемые имена методов для каждой из операций.

- Такие методы вызываются автоматически, когда экземпляр участвует во встроенных операциях. Напр. если объект экземпляра наследует метод __add__, этот метод будет вызываться всякий раз, когда объект будет появл-ся в операции сложения (+). Возвращаемое значение метода становится результатом соотв. операции.

- Классы могут переопределять большинство встроенных операторов. Есть много спец. имен методов для реализации перегрузки почти всех операторов встр. типов. Это операторы выражений, базовые операции, такие как вывод и создание объекта.

- В методах перегрузки операторов не существует аргументов со значениями по умолчанию, и ни один из таких методов не явл-ся обязательным для реализации. Если класс не определяе ти не наследует методы перегрузки операторов, то это значит, что экземпляры класса не поддерживают эти операции. Напр. если нет метода __add__, попытка выполнить операцию + приведет к ошибке.

- Операторы позволяют интегрировать классы в объектную модель Питона. Благодаря перегрузке операторов, объекты, реализованные на базе классов, действуют подобно встр. типам и тем самым обеспечивают непротиворечивые и совместимые интерфейсы.

Вообще перегрузка не явл-ся обязательной функциональной особенностью, если она не нужна в вашем классе, то и хорошо, используйте стандартные методы. Напр. приложению работающему с БД не нужны такие операторы как * и + (нам нечего умножать и складывать в БД, со всеми задачами справятся стандартные методы работы с БД).

Мы не будем изучать перегрузку каждого оператора, доступного в Питон. Но есть один метод перегрузки оператора, который можно встретить практически в любом классе: метод __init__, который известен как конструктор и использ-ся для инициализации состояния объектов. Наряду с self он явл-ся одним из ключей понимания ООП в Питон.


Третий пример.

Определим подкласс, производный от SecondClass и реализующий три спец. метода, которые будут вызываться интерпретатором автоматически. 

И не путайте имя метода __init__ с файлом __init__.py в пакетах модулей!!!

- Метод __init__ вызывается, когда создается новый объект экземпляра (аргумент self представляет новый объект ThirdClass).

- Метод __add__ вызывается, когда экземпляр ThirdClass участвует в операции +.

- Метод __str__ вызывается при выводе объекта (точнее когда он преобразуется в строку для вывода вызовом встр. ф-ции str или её эквивалентом внутри интерпретатора).

Новый подкласс также определяет метод mul, котоырй изменяет сам объект в памяти. Приступим к испытаниям:

class ThirdClass(SecondClass):					# Наследует SecondClass
	def __init__(self, value):					# Вызывается из ThirdClass(value)
		self.data = value
	def __add__(self, other):					# Для выражения "self + other"
		return ThirdClass(self.data + other)
	def __str__(self):							# Вызывается из print(self), str()
		return '[ThirdClass: %s]' % self.data
	def mul(self, other):						# Изменяет сам объект: обычный метод
		self.data *= other  

>>> a = ThirdClass("abc")					# Вызывается новый метод __init__
>>> a.display()								# Унаследованный метод
Current value = "abc"
>>> print(a)								# __str__ : возвращает строку
[ThirdClass: abc] 

>>> b = a + 'xyz'							# Новый __add__ : создается новый экземпляр
>>> b.display()
Current value = "abcxyz"
>>> print(b)								# __str__ : возвращает строку
[ThirdClass: abcxyz]

>>> a.mul(3)								# mul: изменяет сам экземпляр
>>> print(a)
[ThirdClass: abcabcabc]

Класс ThirdClass "наследует" класс SecondClass, поэтмоу ег оэкземпляры наследуют метод display от SecondClass. Но теперь, при создании экземпляра ThirdClass ему передается доп. аргумент (напр. "abc"). Это значение передается конструктору __init__ в аргументе value, где присв-ся атрибуту self.data. В итоге при создании экземпляра класса ThirdClass значение атрибута data устанавливается автоматически, благодаря чему отпадает необходимость вызывать метод setdata после создания экземпляра.

Далее, объекты ThirdClass могут участвовать в операциях + и в вызовах ф-ции print. При операции сложения (+) объект экземпляра слева от оператора передается методу __add__ в виде аргумента self, а значение справа - в виде аргумента other. 

Т.е. механизм перегрузки операторов отображает операторы выражений и другие встр. операции, выполняемые над экземплярами классов, на спец. имена методов в классе. Здесь у нас использ-е оператора "+" приводит к вызову метода __add__.

Как видим в метод __add__ передается два аргумента и поэтому, из выражения вида a + "xyz", объект экземпляра (self) а и аргумент (other) "xyz" складываются. И получается строка. Т.о. независимо от того что вернет метод __add__, это значение будет интерпретироваться как результат операции сложения.

Когда объект будет участвовать в вызове print(), интерпретатор вызывает метод __str__ объекта и передает ему сам объект - любая строка, которую вернет метод, будет расцениваться, как строковое представление объекта для вывода. Переопределив метод __str__, мы получим возможность использ. ф-цию print для отображения объектиов этого класса, вместо того, чтобы вызывать метод display.

Методы со псец. именами наследуются подклассами и экземплярами, как любые др. имена, которые присв-ся в инструкции class. Если методы отсутствуют в классе идет их поиск в суперклассах. Имена методов пепегрузки не явл-ся встроенными именами или зарезервированными словами - это обычные атрибуты, которые отыскиваются интерпретатором в случае появления объектов в различ. контекстах. Обычно интерпретатор вызывает их автоматич., но они могут вызываться и программным кодом - метод __init__, часто взывается вручную, чтобы запустить конструктор суперкласса.

Внимание! Посмотрите, что метод __add__ создает и возвращает НОВЫЙ объект экземпляра этого класса (вызывая ThirdClass, которому передается значение результата), а метод mul ИЗМЕНЯЕТ текущий объект экземпляра (выполняя присваивание атрибуту аргумента self). Т.к. перегрузка - это всего лишь механизм отображения выражений на методы, мы можем интерпретировать операторы в своих объектах классов, как нам угодно.


Когда следует использовать перегрузку операторов?

Конечно использовать или нет перегрузку мы определяем сами. Выбор зависит от того, насколько близко наш класс должен имитировать поведение встр. типов. Как мы знаем, если метод перегрузки оператора отсутствует в определении класса и не наследуется из суперкласса, соотв. операция не будет поддерживаться экземплярами этого класса - при попытке вып-ть такую операцию мы получим исключение (или действие по умолч.).

Вообще перегрузка операторов чаще использ. при реализации объектов с матем. природой - класс вектора или матрицы (напр. перегрузка сложения). Для упрощения классов можно не использ. перегрузку, а использ. явные методы.

С др. стороны мы можем использовать перегрузку операторов, чтобы иметь возможность передавать объекты, определяемые пользователем, в ф-цию, которая вып-ет операции, поддерживаемые встр. типами (списки или словари напр.). Наличие того же набора операторов в нашем классе обеспечит поддержку нашими объектами тех же самых интерфейсов и т.о. совместимость с используемой ф-цией. В гл. 29 мы ознакомимся с длоп. приемами перегрузки операторов в примерах.

Метод-конструктор __init__ присутствует почти во всех реалистичных классах. Он позволяет классам немедленно заполнять атрибуты вновь созданных экземпляров, поэтому конструктор полезно использ. практически во всех разновидностях наших классов. Фактически, даже при том, что в Питон атрибуты не оьновляются, мы сможем без труда определить какие атрибуты принадлежат экземплярам, просмотрев программ. код метода __init__.


Самый простой в мире класс на языке Python.

Приступим к детальному изучению синтаксиса инструкции class, и еще раз вспомним, что модель наследования, на которой основаны классы, очень проста - суть её заключается в организации поиска атрибутов в деревьях взаимосвязанных объектов. Фактически можно создавать вообще пустые классы. Создадим класс без атрибутов (объект пустого пространства имен):

>>> class rec: pass

- вот нам и пригодилась пустая операция pass.

Теперь можем начинать присоединять атрибуты выполняя присваивание за пределами класса:

>>> rec.name = 'Bob'
>>> rec.age = 40

Когда атрибуты созданы можно обращаться к ним с пом. обычного синтаксиса. Классы - это полноценные объекты, даже если нет ни одного экземпляра. Фактич. они лишь самостоятельные пространства имен, поэтмоу пока есть ссылка на класс, мы можем в любое время добавлять или изменять его атрибуты по своему усмотрению. Посмотрим, что будет если создать два экземпляра класса:

>>> y = rec()		# Экземпляры наследуют имена из класса
>>> x = rec()  

Они начинают свое существование как объекты абсолютно пустых пространств имен. Однако они наследуют из класса атрибуты:

>>> x.name, y.name
('Bob', 'Bob')

- Эти экземпляры получили атрибут name из класса, своих атрибутов у них пока нет.

Но если сейчас атрибуту экземпляра присвоить др. значение, то будет создан (изменен) атрибут именно этого объекта. Т.е. операция присваивания значеняи атрибуту действует только на тот объект, к которому она прмиеняется. Экземпляр х получает собственный атрибут name, а экземпляр y по-прежнему наследует name от класса:

>>> x.name = 'Sue'
>>> rec.name, x.name, y.name
('Bob', 'Sue', 'Bob')

Фактич. атрибуты объекта пространства имен обычно реализованы в виде словарей, и деревья наследования классов тоже всего лишь словари со ссылками на др. словари.

Напр. в большинстве объектов, созданных на базе классов, есть атрибут __dict__, который явл-ся словарем пространства имен. Пример - порядок следования имен и перечень внутренних имен вида __X__ может изменяться от версии к версии интерпретатора, но имена, которые использовали, присутствует везде:

>>> list(rec.__dict__.keys())
['age', '__dict__', 'name', '__weakref__', '__module__', '__doc__']

>>> list(x.__dict__.keys())
['name']

>>> list(y.__dict__.keys())
[]

Видим, что в классе есть атрибуты age и name, объект х имеет только свой атрибут name, а объект y по-прежнему пуст.

Каждый экземпляр имеет ссылку на свой наследумый класс, она наз-ся __class__ :

>>> x.__class__
<class '__main__.rec'>

Классы также имеют атрибут __bases__ , который представляет собой кортеж его суперклассов:

>>> rec.__bases__
(<class 'object'>,)

>>> ThirdClass.__bases__
(<class '__main__.SecondClass'>,)       

Главное, что нужно понимать - модель классов в Питон очень динамична. Классы и экземпляры - это всего лишь объекты пространств имен с атрибутами, создаваемыми на лету присваиванием.

Даже методы, которые созда-ся def, влож. в инструкцию class, могут создаваться независимо от объекта класса. Пример поределения простой ф-ции вне класса:

>>> def upperName(self):
	return self.name.upper()		# Аргумент self по-прежнему необходим

Это простая ф-ция и она может вызываться как обычная ф-ция, при услови, что объект, получаемый ею, имеет атрибут name (в данном случае имя аргумента self не имеет никакого особого смысла).

>>> upperName(x)		# Вызов как обычной ф-ции
'SUE' 

Однако, если эту ф-цию присвоить атрибуту нашего класса, она станет методом, вызываемым из любого экземпляра (и через имя самого класса, при условии, что ф-ции будет вручную передан экземпляр):

>>> rec.method = upperName

>>> x.method()					# Вызват ьметод для обработки х
'SUE'

>>> y.method()					# То же самое, но в self передается y 	
'BOB'

>>> rec.method(x)				# Можно вызвать через имя экземпляра или класса
'SUE'        

Обычно заполнение классов произв-ся внутри инструкции class, а атрибуты экземпляров создаются присваиванием значений атрибутам аргумента self в методах. Но это не явл-ся обязательным.


Классы и словари. стр. 723 

Мы познакомились с основными особенностями модели классов. В гл. 8 мы увидели как можно использ. словари для хранения записей свойств сущностей в программах. Оказывается классы тоже могут играть эту роль - хранить информацию, как словари, но при этом могут включать логику обработки этой информации в методах.

Пример со словарем:

>>> rec = {}
>>> rec['name'] = 'mel'
>>> rec['age'] = 40
>>> rec['job'] = 'trainer/writer'
>>> 
>>> print(rec['name'])
mel

А теперь пример записи на основе класса, с заменой ключей атрибутами:

>>> class rec: pass

>>> rec.name = 'mel'
>>> rec.age = 40
>>> rec.job = 'trainer/writer'
>>> 
>>> print(rec.age)
40

Создав пустой класс мы заполняем его, присваивая значения его атрибутам.

Этот прием работает, но для каждой отдельной записи придется писать новую инструкцию class. Все-таки более удобно будет создавать экземпляры класса для новых записей:

>>> class rec: pass

>>> pers1 = rec()
>>> pers1.name = 'mel'
>>> pers1.age = 40
>>> pers1.job = 'trainer'
>>> 
>>> pers2 = rec()
>>> pers2.name = 'dave'
>>> pers2.job = 'developer'
>>> 
>>> pers1.name, pers2.name
('mel', 'dave')

Два отдельных объекта экземпляра и, соответственно, два разных атрибута name. И даже кол-во атрибутов у экземпляров может быть разным (напр. age). Т.о. каждый экземпляр имеет своё пространство имен, т.е. свой словарь атрибутов.

Мы могли бы создать более полноценный класс:

>>> class Person:
	def __init__(self, name, job):
		self.name = name
		self.job = job
	def info(self):
		return (self.name, self.job)

>>> rec1 = Person('mel', 'trainer')
>>> rec2 = Person('vls', 'developer')
>>> 
>>> rec1.job, rec2.info()
('trainer', ('vls', 'developer'))

В этот класс мы добавили логику (методы) инициализации экземпляров на этапе создания и сбора атрибутов в кортеж. Конструктор налагает некоторые ограничения целостности, требуя значения для двух атрибутов - name и job. Методы класса и атрибуты экземпляра вместе образуют пакет, объединяющий данные и логику.

Классы - это гибкость и универсальность, недоступные встр. типам и функциям.











Глава 27. Более реалистичный пример.  стр. 728

В этой главе мы создадим множество классов, решающих конкретные задачи - сохранение и обработку инфомрации о людях. Те компоненты, которые мы называем экземпляры и классы, часто могут играть роль записей и программ в традиционном понимании.

Мы создадим два класса:   
 
- Person - класс, который предоставляет и обрабатывает информацию о людях;

- Manager - адаптированная версия (помним об ООП - адаптация кода) класса Person, модифицирующая унаследованное поведение.

Создадим экземпляры обоих классов и протестируем их. Увидим пример - мы сохраним наши экземпляры в хранилище, в объектно-ориентированной базе данных, обеспечивающей долговременное хранение. Этот шаблон даже можно будет применять для создания своей БД на Питон.

И самое главное - обучение. Мы будем продолжать осваивать основы, постепенно будем создавать классы, чтобы увидеть как из отдельных особенностей составляются законченные программы.

Всё это позволить нам изучить и рассмотреть все основные идеи модели ООП в Питон. И в итоге поймем, что система классов в Питоне, сводится к поиску атрибутов в дереве объектов и наличию спец. первого аргумента (self) в функциях классов.


Шаг 1: создание экземпляров. стр. 729

Начнем создание главного класса Person. Создадим новый файл где будем писать наш код. В Питон есть соглашение, согласно которому имена модулей начинаются со строчной буквы, а имена классов - с прописной. Так, в соотв. с соглаш. первому аргументу методов класса присв-ся имя self. Эти соглаш. не обьязательны, но общеприняты. Итак:

# Файл person.py (начало)

class Person:

Мы можем написать в одном файле много ф-цифй и классов, поэтому название person.py может потерять смысл, если позже мы добавим в него доп. компоненты, никак не связанные с его начальным предназначением.

Но пока будет предполагать, что всё, что нах-ся в этом файле так или иначе связано с классом Person. В идеале так и должно быть - ведь мы знаем, что модуль только выигрывает, когда он создан ради единственной, логически связанной цели.


Конструкторы.

Первое, что нам нужно сделать в классе Person - записать основные сведения о человеке, т.е. заполнить поля записи. В Питон они наз-ся атрибутами объекта и обычно создаются с пом. операций присваивания значений атрибутам аргумента self в методах класса. Обычно первые знач. атрибутам присв-ся в методе конструтора __init__, который вызывается автоматически каждый раз, когда созд-ся новый экземпляр. Добавим конструкцию к классу:

# Добавим инициализацию полей записи

class Person:
    def __init__(self, name, job, pay):	    # Конструктор принимает 3 аргумента		
	self.name = name		    # Заполняет поля при создании
	self.job = job			    # self - новый экземпляр класса
	self.pay = pay	

Итак, мы передаем конструктору (метод __init__) аргументы с данными, которые будут храниться экземпляром, и присваиваем их атрибутам аргумента self.

В терминах ООП аргумент self представляет вновь созданный экземпляр, а аргументы name, job и pay превращаются в информацию о состоянии - данные, сохраняемые в объекте для последующего использования.

Видим, что имена аргументов использ-ся дважды в операциях присваивания. Это может показаться избыточным, но это не так. Аргумент job, например, - это локальная переменная в области видимости ф-ции __init__, а self.job - это атрибут экземпляра, который явл-ся подразумеваемым контекстом вызова метода. Т.е. это две разные переменные, которые по совпадению имеют одно и то же имя.

Присваивая знач. локал. переменной job атрибуту self.job (с пом. операции self.job = job)  мы сохраняем его в экземпляре для последующего использования.

Метод __init__ обычен, кроме того, что он вызывается автоматич. при создании экземпляра и его первый аргумент имеет спец. значение. А так это самая обычная ф-ция, т.е. мы можем определять знач. аргументов по умолчанию, например.

Пример, сделаем job необязательным аргументом - знач. по умолч. будет None (т.е. безработный). И если job = None, то аргумент pay (зарплата) должен быть равен 0 (безработные не получают з\п). На самом деле мы вынуждены указать знач. по умолч. для pay, т.к. это требует синтаксис Питона - любые аргументы в заголовке ф-ции, следующие за первым аргументом, имеющим знач. по умолч., также должны иметь знач. по умолч.:

# Добавим значения по умолчанию для аргументов конструктора

class Person:
    def __init__(self, name, job=None, pay=0):
	self.name = name
	self.job = job
	self.pay = pay	

Теперь, при создании экземпляров, нам достаточно передать только аргумент name, остальные будут по умолч., если их не указать явно.


Тестирование в процессе разработки.

Как видим, программирование на Питон сводится к постепенному наращиванию возможностей - т.е. мы пишем код, тестируем его, потом добавляем еще, снова тестируем и так далее. Т.е. лучше тестировать понемногу, а не всё сразу.

Протестируем наш класс, создав пару экземпляров и просмотрев их атрибуты. Это можно сделать в интерактив. сеансе, но это утомительно, набирать кучу инструкций. Для полного тестирования лучше добавлять программ. код в конец файла, содержащего тестируемые объекты:

# Добавляем код для самопроверки
 
class Person:
    def __init__(self, name, job=None, pay=0):
	self.name = name
	self.job = job
	self.pay = pay

bob = Person('Bob Smith')
sue = Person('Sue Jones', job='dev', pay=100000)

print(bob.name, bob.pay)
print(sue.name, sue.pay) 

- Тестирование класса. Запустит __init__ автоматически, извлечет атрибуты, увидим, что атрибуты в объектах sue и bob отличаются.

Итак, объект bob получает знач. атрибутов по умолч., а для объекта sue  знач. всех атрибутов указываются явно. Причем мы используем для sue именованные аргументы, хотя могли бы и позиционные, однако именованные информативнее и их можно указывать в любом порядке.

Еще раз видим, что __init__ это обычная ф-ция, поддерживающая все особенности ф-ций.

Если запустить файл как сценарий, то увидим:

user@home:~$ python3.4 person.py
Bob Smith 0
Sue Jones 100000


Примечание!!! В gvim я поставил табуляцию = 4 (я так понимаю 1 таб = 4 пробела), ну это для удобства вида просто, а в терминале получил ошибку:

user@home:~$ python3.4 person.py
  File "person.py", line 5
    self.name = name
                   ^
TabError: inconsistent use of tabs and spaces in indentation

- переводится как "Смешение пробелов и табуляции в отступах.", пришлось переоткрывать файл заново и ставить обычные табы (они длинные и некрасиво выглядит, но зато работает).

Посмотрел непечатаемые знаки и вижу, что двойные Табы отображаются как Табы, а одинарный (где def) не отображается как Таб, видимо просто как 4 пробела, почему не знаю, нужно все-таки заняться изучением vim, а не только Питона. Нужно изучить этот вопрос, иначе будут некрасивые лестницы отступов в коде. Ну или пока так попробовать..

Каждый из объектов bob и sue явл-ся независимыми записями с собств. информацией. Технич. они явл-ся пространствами имен - как и все экземпляры классов, каждый из них обладает собств. копией информации о состоянии. Т.о. как и встр. типы, классы играют роль своеобразной фабрики объектов.


Двоякое использование программного кода. стр. 732

Тесты работают без проблем, но есть одно но - инструкции print будут выполняться и при запуске файла как сценария и при импорте как модуля. Это не очень хорошо, т.к. клиентской проге не зачем знать как выглядят наши тесты и вообще тесты не нужны.

Конечно можно тесты убрать в отдельный файл, однако удобнее когда тесты нах-ся в том же файле, что и тестируемый код (может это соглашения Питона, в Руби мы писали тесты отдельным файлом, напр., надеюсь дальше будет понятно, или потом на практике). Но лучше оформим тесты, чтобы они выполнялись когда файл запускается как сценарий, а не при импорте. А поможет нам проверка атрибута __name__ модуля:

# Предусмотрим возможность импорта файла и запуска его,
# как самостоятельный сценарий

class Person:
	def __init__(self, name, job=None, pay=0):
		self.name = name
		self.job = job
		self.pay = pay

if __name__ == '__main__':				# Только когда файл запускается как сценарий
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob.name, bob.pay)
	print(sue.name, sue.pay)

Теперь проверим работает ли тестирование тогда когда нам нужно:

C:\Python34>person.py
Bob Smith 0
Sue Jones 100000

>>> import person				# Всё работает как надо, при импорте тестов нет
>>> 

Замечание. Я снова наступаю на те же грабли, что и всегда. 

После импорта модуля с классом Person, я попытался создать экземпляр класса и потерпел неудачу:

>>> import person
>>> bob = Person('Bob')
...
NameError: name 'Person' is not defined

Интерпретатор выдавал мне сообщение о том, что имя Person не существует, хотя в атрибутах модуля он был:

>>> list(person.__dict__.keys())
['__spec__', 'Person', '__cached__', '__loader__', '__package__', '__builtins__', '__doc__', '__file__', '__name__']

В итоге, в результате долгих поисков проблема была определена - оказывается я напрасно вызывал таким образом класс, потому что его НУЖНО было вызывать вот так:

>>> import person
>>> bob = person.Person('Bob Dilan')
>>> bob.name
'Bob Dilan'

А если мы хотим вызывать так как делали в прошлых примерах, когда классы мы создавали ПРЯМО В оболочке, то нужно импортировать класс Person вот ТАКИМ способом, через from:

>>> from person import Person
>>> bob = Person('Bob')
>>> bob.name
'Bob'

Очень ужасная забывчивость и невнимательность у меня, нужно с ней обязательно бороться, с такими ошибками в программисты не берут.


Шаг 2: добавление методов, определяющих поведение.

Итак, сейчас наш класс играет роль фабрики записей - создает записи и заполняет их поля (атрибуты экземпляров). Теперь мы уже можем применять различ. операции к этим записям.

Большую часть свой работы классы выполняют за счет внедрения и обработки данных базовых типов, таких как списки и строки. Т.е. если мы знаем как работать в базовыми типами, то и с классами разберемся - классы явл-ся лишь небольшой структурной надстрокой.

Напр. поле name в наших объектах явл-ся обычной строкой, поэтому мы можем извлекать фамилии разбивая значение по пробелам и индексированием, т.е. операциями над базовыми типами:

>>> name = 'Bob Smith'			# Простая строка
>>> name.split()				# Извлечение фамилии
['Bob', 'Smith']
>>> name.split()[-1]			# Или и [1] если имя всегда состоит из двух компонентов
'Smith'     

Также можем работать и с зарплатой, изменяя её состояние с пом. присваивания:

>>> pay = 100000			# Простая переменная за пределами класса
>>> pay *= 1.10				# Поднимем з\п на 10% или pay = pay * 1.10
>>> print(pay)				
110000.00000000001

Чтобы применить эти операции к объектам класса Person, просто подставьте имена bob.name и sue.name на место name и pay, т.е. операции будут проводиться над атрибутами класса:

# Обработка встроенных типов: строки, изменяемость

class Person:
	def __init__(self, name, job=None, pay=0):
		self.name = name
		self.job = job
		self.pay = pay

if __name__ == '__main__':
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob.name, bob.pay)
	print(sue.name, sue.pay)
	print(bob.name.split()[-1])			# Извлечь фамилию
	sue.pay *= 1.10						# Повысить з\п
	print(sue.pay) 

- в предпоследней строке мы изменяем значение атрибута pay у объекта sue. В некотором смысле объект sue явл-ся изменяемым - он допускает непосредственное изменение свой информации о состоянии, подобно списку при вызове метода append:

C:\Python34>person.py
Bob Smith 0
Sue Jones 100000
Smith
110000.00000000001

Опытный программист подскажет нам, что такой подход не желателен на практике. Выполнение операций за пределами класса, как у нас, может привести к проблемам при сопровождении.

Представим, что в разных местах программыесть одинаковые фрагменты, извлекающие фамилию. Если нам нужно будет изменить их, то придется искать и изменять ВСЕ такие фрагменты. То же самое относится и к операцией с зарплатой. Один тольк опоиск всех фрагментов может быть проблематичным.


Методы реализации. 

Приступаем к реализации концепции под названием - инкапсуляция. Её идея в том, чтобы спрятать логику операций за интерфейсами, и т.о. каждая операция будет иметь единственную реализацию в программе. Если в будущем нам нужно будет внести изменения в логику, нам нужно будет модифицировать код всего лишь в одном месте, а не по всей программе.

Еще плюс - можно будет изменять реализацию операции как угодно (рефакторинг, оптимизация), не рискуя нарушить работу кода, и опять же - всего лишь в одном месте, а не по всей программе.

В терминах Питона это означает, что мы должны реализовать операции над объектами в виде методов класса, а не разбрасывать их по всей программе. 

Простыми словами опишем - напр. нам нужно переключить скорость передачи в авто, т.е. провести операцию "переключение скорости", для этого у нас есть метод "перемещение рычага КПП" и нас совсем не интересует, что будет делать рычаг КПП внутри самой коробки передач, движения шестерен внутри, валдов и прочее и прочее. У фирмы БМВ масса автомобилей различных моделей и размеров, но концепция операция-метод-реализация остается, для всего многообразия автомобилей, одинакова. Вот это простое описание инкапсуляции.

Вернемся к программированию. Сосредоточив код реализации в одном месте мы устраняем избыточность и упрощаем его сопровождение, что явл-ся одной из сильных сторон классов. Оформление операций в виде методов позволяет применять их к любым экземплярам класса, а не только к тем, которые явно задействованы в обработке.

К практике. Мы переместим реализацию двух операций из программы в методы класса, добившись инкапсуляции и изменим код самопроверки:

# Добавлены методы, инкапсулирующие операции 

class Person:
	def __init__(self, name, job=None, pay=0):
		self.name = name
		self.job = job
		self.pay = pay
	def lastName(self):						# Два метода, реализующие поведение экземпляров
		return self.name.split()[-1]		# self - подразумеваемый экземпляр
	def giveRaise(self, percent):
		self.pay = int(self.pay * (1 + percent))	# если "прибавка к з\п" изменится
													# то изменять нам только один метод 

if __name__ == '__main__':
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob.name, bob.pay)
	print(sue.name, sue.pay)
	print(bob.lastName(), sue.lastName())	# Вместо жестко определенных операций
	sue.giveRaise(.10)						# используем методы				
	print(sue.pay)

- give - давать; Raise - повышение, подъем; percent - процент. Т.е. метод giveRaise дает нам з\п служащего с надбавкой, если она есть (у Sue мы её сделали 10%).

И еще была синтаксическая ошибка, в тестах написал метод lastName с большой буквы "sue.LastName" - внимательнее будьте!

Как мы знаем методы - это обычные ф-ции, которые присоед-ся к классам и предназначены для обработки экземпляров этих классов. Экземпляр - это подразумеваемый контекст вызова метода, который автоматич. передается в виде аргумента self.

С методом giveRaise мы уже разобрались, он выполняет операцию над объектом self (по увеличению з\п, если конечно передавать положительное число, не отрицательное и не 0).

Метод lastName возвращает результат, это фактич. вызов ф-ции - вычисляет значение, которое затем может использ-ся вызывающей программой (у нас рез-т просто выводится для обзора).

Рез-ты сценария будут те же, что и прежде - т.к. мы всего лишь реструктурировали программный код, не изменяя его поведения:

C:\Python34>person.py
Bob Smith 0
Sue Jones 100000
Smith Jones
110000

Обсудим несколько моментов нашего нового кода:

- Первое. Обратим внимание, что поле pay (зарплата) в объекте sue получает целочисленное значение после его увеличения - внутри мы преобразовываем рез-т в целое число с пом. ф-ции int. Конечно нужно самим определять как лучше - int или float, нужно ли округлять или нет.
К тому же мы могли округлить до центов с пом. ф-ции round(N, 2), использовать тип decimal или хранить в виде веществ. чисел и отображать с пом. стркои формата %.2f или {0:.2f}. Еще один способ - можно импортировать ф-цию money и отображать сумму з\п с запятыми, центами и знаком доллара (см. модуль formats.py в гл. 24).

- Второе. Мы добавили вывод фамилии из объекта sue - т.к. теперь логика получения фамилии инкапсулирована в методе и можем применить её к любому экземпляру класса. Интерпретатор сам сообщает методу, какой экземпляр должен обрабатываться, автоматич. передавая его в первом аргументе (self).

Одно слабое место у нас есть, - это нулевая з\п в объекте bob, к нему мы не можем применть метод giveRaise, т.к. в итоге получим тот же 0, а не увеличение з\п.

Ну и как говорилось мной выше - у нас просто подразумевается, что в percent передаются нормальные цифры процентов, но в этом месте все-таки желательна бы проверка значения (мало ли, отрицательное число будет или вообще 1000%). В одной из глав мы разберем способы решения этой проблемы, когда будем изучать декораторы функций и исследовать инструкцию assert - альтернативы, позволяющие реализовать автоматич. проверку в ходе разработки.


Шаг 3: перегрузка операторов. стр. 737

Итак, у нас есть класс, который может инициализировать экземпляры и обладает методами.

Но есть моменты по тестам - нам приходится вручную извлекать и выводить значения отдельных атрибутов (bob.ame, sue.name). Хотелось бы , чтобы вывод экземпляра целиком показывал нам нужную информацию. 

Но формат вывода объектов экземпляров по умолчанию, выглядит неудобно - выводит имя класса и его адрес памяти (зачем он нам?). Чтобы это увидеть измените последнюю строку на вызов print(sue):

C:\Python34>person.py
Bob Smith 0
Sue Jones 100000
Smith Jones
<__main__.Person object at 0x0075F7B0>


Реализация отображения.

В помощь нам придет перегрузка операторов - добавит ьв класс метод, который перехватывает и выполняет встр. операцию, когда она применяется к экземплярам класса.

Нам поможет популярный метод (вторйо после __init__) - метод __str__ (см. пред. главу). Метод __str__ вызывается всякий раз, когда экземпляр преобраз-ся в строку для вывода. Т.о. фактич. всё, что мы получаем при выводе объекта, явл-ся возвращаемым значением метода __str__ этого объекта, который может быть определен в классе объекта или унаследован от суперкласса (методы с подчеркиваниями наследуются так же как любые другие).

Метод __str__ перехватывает определнную операцию и вып-ет специфическую реализацию поведения объекта, участвующего в операции. Добавим его в наш класс:

# Добавлен метод __str__, реализующий вывод объектов 

class Person:
	def __init__(self, name, job=None, pay=0):
		self.name = name
		self.job = job
		self.pay = pay
	def lastName(self):
		return self.name.split()[-1]
	def giveRaise(self, percent):
		self.pay = int(self.pay * (1 + percent))
	def __str__(self):										# Новый спец. метод
		return '[Person: %s, %s]' % (self.name, self.pay)	# Строка для вывода

if __name__ == '__main__':
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob)
	print(sue)
	print(bob.lastName(), sue.lastName())
	sue.giveRaise(.10)
	print(sue)

В методе __str__ в строке вывода мы применили оператор форматирования % - для реализации нужных действий классы могут использ-ть встр. типы объектов и операции. Т.е. запомните - всё, что мы знаем о встр. типах данных и ф-циях, может прим-ся при создании классов. По сути классы лишь добавляют структурный уровень, организующий ф-ции и данные в виде единого объекта и имеющий возможность расширения.

Мы также изменили тесты - теперь выводятся объекты целиком, а не отдельные объекты, смотрим:

C:\Python34>person.py
[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]

Далее мы узнаем, что родственный метод перегрузки __repr__  возвращает представление объекта в виде программ. кода. И иногда классы переопределяют оба метода: __str__ - для удобочитаемого вывода, а __repr__ - для вывода доп. сведений об объектах (для разработчика напр.). Т.к. операция вывода автоматич. вызывает метод __str__, а интерактив. оболочка выводит рез-ты с пом. __repr__, подходящие варианты вывода могут предоставляться обеим категориям клиентов.


Шаг 4: адаптация поведения с помощью подклассов. стр. 739

Сейчас у нас есть большинство механизмов ООП Питона: класс создает экземпляры, есть методы обработки и даже операторы перегрузки. Наш класс фактич. объединяет логику и данные в единый самостоятельный программ. компонент, упрощая поиск и модификацию программ. кода. Также имеется инкапсуляция.

Единственно чего мы еще не делали, это - адаптация программного кода за счет наследования. Конечно наши экземпляры наследуют методы своего класса. Но для полноты обучения принципам ООП нам нужно определить отношения типа суперкласс/подкласс. Ведь основная идея ООП - это возможность адаптации уже имеющегося и действующего программ. кода.


Создание подклассов.

Адаптируем наш класс Person расширив его подклассом Manager, в котором мы заместим унаследованный метод giveRaise. Сначала определим класс:

class Manager(Person):			# Определили подкласс класса Person

Класс Manager наследует и может адаптировать суперкласс Person. В частности подкласс Manager буде треализовать свой спосо бувеличения з\п.

Допустим наш менеджер получает не только прибавку (percent), но и доп. премию, которая по умолч. будет 10%. Напр. если прибавка будет 10%, то увеличение у менеджера будет уже 20%. Наш новый метод замещает и адаптирует оригинальную реализацию в классе Person:

class Manager(Person):
	def giveRaise(self, percent, bonus=.10):
	

Расширение методов: неправильный способ.

Неправильный способ заключается в простом копировании реализации метода giveRaise из класса Person и его изменении в классе Manager:

class Manager(Person):
	def giveRaise(self, percent, bonus=.10):
		self.pay = int(self.pay * (1 + percent + bonus))
		
Конечно этот вариант будет работать. Проблема в том, что всякий раз когда вы копируете программ код, вы фактич. усложняете его сопровождение в будущем. Если в будущем у нас появятся изменения в суперклассе в этом методе, то нам придется делать их в двух местах. Это маленький пример, но наглядно демонстрирует эту проблему.


Расширение методов: правильный способ.

На самом деле нам нужно лишь дополнить оригинальный метод giveRaise, а не заменить его полностью. Правильный способ состоит в том, чтобы вызвать оригинальную версию с измененными аргументами:

class Manager(Person):
	def giveRaise(self, percent, bonus=.10):
		Person.giveRaise(self, percent + bonus)
		
Данная реализация учитывает то обстоятельство, что методы класса могут вызываться либо обращением к экземпляру (обычный способ, когда интерпретатор автоматич. передает экземпляр в аргументе self), либо обращением к классу (менее распространенный метод, когда экземпляр передается вручную). Вспомним, что вызов метода:

instance.method(args...)

автоматич. транслируется интерпретатором в эквивалентную форму:

class.method(instance, args...)

где класс, содержащий вызываемый метод, определяется в соотв. с правилами поиска в дереве наследования, которые действуют и для методов. 

В своих сценариях вы можете использовать любую форму вызова, но не забывайте об их различиях - при обращении непосредственно к классу вы должны передавать объект экземпляра вручную. Метод всегда должен получать объект экземпляра тем или иным способом, однако интерпретатор вып-ет автоматич. передачу только при вызове метода через обращение к экземпляру. 

При вызове метода через обращение к классу вы сами должны передавать экземпляр в аргументе self - внутри метода, такого как giveRaise, аргумент self уже содержит подразумеваемый объект вызова, т.е. сам экземпляр.

Вызов через обращение к классу начинает поиск от класса и выше по дереву классов. Именно поэтому в классе Manager мы должны вызывать оригинальный метод через класс Person.giveRaise(), т.к. если бы мы вызывали его через self.giveRaise(), то у нас появилась бы рекурсия.

На первый взгляд правильная и неправильная версии мало отличаются, но это отличие может иметь огромное значения для сопровождения в будущем - в нашем случае у нас основная логика работы метода по-прежнему остается в одном месте (представьте сотни таких "двойных" методов в проекте, замучаетесь изменять в случае чего).

Приводим полное содержимое файла модуля после последнего шага:

# Добавлен подкласс, адаптирующий поведение суперкласса

class Person:
	def __init__(self, name, job=None, pay=0):
		self.name = name
		self.job = job
		self.pay = pay
	def lastName(self):
		return self.name.split()[-1]
	def giveRaise(self, percent):
		self.pay = int(self.pay * (1 + percent))
	def __str__(self):
		return '[Person: %s, %s]' % (self.name, self.pay)

class Manager(Person):
	def giveRaise(self, percent, bonus=.10):
		Person.giveRaise(self, percent + bonus)	
		
if __name__ == '__main__':
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob)
	print(sue)
	print(bob.lastName(), sue.lastName())
	sue.giveRaise(.10)
	print(sue)
	tom = Manager('Tom Jones', 'mgr', 50000)	# Экземпляр Manager: __init__
	tom.giveRaise(.10)							# Вызов адаптированной версии
	print(tom.lastName())						# Вызов унаследованного метода 
	print(tom)									# Вызов унаследованного __str__    
	
- мы добавили новый код проверки для наших новых изменений.

[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
Jones
[Person: Tom Jones, 60000]		# Видим, что з\п увеличилась не на 10%, как у sue, а на 20%


Полиморфизм в действии. 

Добавим еще код для еще более полного действования наследования:

if __name__ == '__main__':
	...
	print('--All three--')
	for object in (bob, sue, tom):		# Обработка объектов обобщенным способом
		object.giveRaise(.10)			# Вызовет метод giveRaise этого объекта
		print(object)      				# Вызовет общий метод __str__

Результаты работы:

[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
Jones
[Person: Tom Jones, 60000]
--All three--
[Person: Bob Smith, 0]
[Person: Sue Jones, 121000]
[Person: Tom Jones, 72000] 


В добавленном коде переменная object может ссылаться либо на экземпляр класса Person, либо класса Manager, а интерпретатор автоматич. вызовет соотв-щий метод giveRaise - для bob, sue оригинальнй метод из класса Person, а для объекта tom - адаптированная версия из класса Manager.

Этот пример демонстрирует нам понятие полиморфизма в Питон, - действие операции giveRaise зависит от того, к какому объекту она применяется. Именно благодаря полиморфизму, в этом примере sue получает прибавку 10%, а tom - 20%.

С др. стороны, операция вывода вызывает одну и ту же версию метода __str__ для всех трех объектов, потому что в программ. коде присутствует только одна его версия - в классе Person.


Наследование, адаптация и расширение.

Классы могут обладать еще большей гибкостью - могут наследовать, адаптировать, расширять реализацию суперклассов. Напр. в нашем подклассе Manager могли бы быть уникальные методы, отсутствующие в классе Person. Пример, появился новый метод someThingElse:

class Person:
	def lastName(self): ...
	def giveRaise(self, ...): ...
	def __str__(self): ...

class Manager(Person):					# Наследование
	def giveRaise(self, ...): ...		# Адаптация
	def someThingElse(self, ...)		# Расширение
	
tom = Manager()	
tom.lastName()						# Унаследованный метод	
tom.giveRaise()						# Адаптированная версия
tom.someThingElse()					# Дополнительный метод	 	
print(tom)							# Унаследованный метод перегрузки

Доп. методы, такие как метод someThingElse? расширяют возможности существующего ПО и доступны только для объектов класса Manager. В наших примерах мы такие методы не создавали, но назначение и использование их в общем-то понятно.


ООП: основная идея.

Наш небольшой код иллюстрирует основное преимущество ООП: используя объектно-ориентированный стиль, мы адаптируем имеющийся программный код, а не копируем и не изменяем его. В целом применение ООП способно существенно сократить время разработки, по сравнению с др. подходами.

Так в наших примерах мы могли бы реализовать отдельную операцию giveRaise, не прибегая к созданию подкласса, но ни один др. способ не позволил бы нам получить такой же оптимальный код:

- Мы могли бы создать новый, независимый класс Manager, но при этом пришлось бы реализовывать все методы, имеющиеся в классе Person и действующие одинаково в классе Manager.

- Мы могли бы просто изменить класс Person, чтобы удовлетворить требованиям, предъявляемым к методу giveRaise класса Manager, но при этом нарушилась бы корректная работа, там где нужен оригинальный метод класса Person.

- Мы могли бы скопировать класс Person целиком, присвоить копии имя Manager и изменить метод giveRaise, но от этого наш код стал бы избыточным, и это усложнило бы нам задачу - вероятные изменения в будущем в классе Person, не будут отражаться в классе Manager и придется вручную переносить изменения.

Адаптируемые иерархии, на основе классов, обеспечивают оптимальное решение для ПО, которое предполагается развивать в дальнейшем. Адаптация и расширение имеющегося кода с применением ООП - сильный союзник программиста.


Шаг 5: адаптация конструкторов.  стр. 745

Обратим внимание - кажется бессмысленно указывать значение 'mgr' (менеджер) в аргументе job при создании объекта класса Manager: эта должность уже подразумевается названием класса. Нужно заполнять этот атрибут автоматически.

Для этого адаптируем логику работы конструктора в классе Manager так, чтобы он автоматич. подставлял название должности. Т.е. нам нужно переопределить метод __init__ в классе Manаger, чтобы 'mgr' ставилось автоматич. Как и в случае с giveRaise, нам нужно вызывать оригинальный метод __init__ из класса Person.

Приводим новый вид сценария:

# Добавлен адаптированный конструктор в подкласс

class Person:
	def __init__(self, name, job=None, pay=0):
		self.name = name
		self.job = job
		self.pay = pay
	def lastName(self):
		return self.name.split()[-1]
	def giveRaise(self, percent):
		self.pay = int(self.pay * (1 + percent))
	def __str__(self):
		return '[Person: %s, %s]' % (self.name, self.pay)

class Manager(Person):
	
	def __init__(self, name, pay):					# Переопределенный конструктор
		Person.__init__(self, name, 'mgr', pay)		# Вызов оригинального конструктора
													# со значением 'mgr' в аргументе job
	def giveRaise(self, percent, bonus=.10):
		Person.giveRaise(self, percent + bonus)	
		
if __name__ == '__main__':
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob)
	print(sue)
	print(bob.lastName(), sue.lastName())
	sue.giveRaise(.10)
	print(sue)
	tom = Manager('Tom Jones', 50000)			# Указывать должность не требуется:
	tom.giveRaise(.10)							# Подразумевается/устанавливается
	print(tom.lastName())						# классом 
	print(tom)    
   
Здесь мы используем тот же прием расширения конструктора __init__, который использовали для метода giveRaise. Вызываем метод __init__ класса Person, чтобы задействовать его логику и экземпляры класса Manager получили атрибуты.

Такая форма вызова конструктора суперкласса из конструктора подкласса широко использ-ся в программировании на Питон. Положительная сторона такого ступенчатого вызова методов в том, что мы можем явно передать конструктору суперкласса только необходимые аргументы или вообще не вызывать его: возможность отказа от вызова конструктора суперкласса позволяет полностью заместить логику его работы, а не дополнять её.

Результаты работы сценария не изменились - т.к. мы не изменили логику его работы, лишь реструктурировали код, чтобы избавиться от некоторой избыточности:

[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
Jones
[Person: Tom Jones, 60000] 


ООП проще чем может показаться.

Наши небольшие классы задействуют почти все наиболее важные концепции механизма ООП в Питон:

- Создание экземпляров - заполнение атрибутов экземпляров.

- Методы, реализующие поведение - инкапсуляция логики в методах класса.

- Перегрузка операторов - реализация поддержки встроенных операций, таких как вывод.

- Адаптация поведения - переопределение специализированных версий методов в подклассах.

- Адаптация конструкторов - добавление логики инициализации, в дополнение к логике суперкласса.

Большинство этих механизмов основаны на: поиске атрибутов в дереве наследования, спец. аргументе self методов и автоматич. выборе нужного метода перегрузки операторов.

Также мы уменьшили избыточность кода и т.о. повысили простоту изменений в будущем - оформили логику работы классов в виде методов и предусмотрели вызовы методов суперкласса.

Конечно есть ряд доп. концепций классов, такие как декораторы и метаклассы. Но что касается основ, то наши кдассы используют все базовые механизмы ООП.


Другие способы комбинирования классов.

Отчасти, объединение классов в крупных программах это искусство. Поэтому помимо наследования программисты использ. др. способы комбинирования классов. Напр. часто использ. прием вложения объектов друг в друга для создания составных объектов - к примеру мы могли бы использ. это для создания класса Manager, вложив в него объект класса Person, а не наследуя этот класс.

След. альтернатив. реализация использует метод __getattr__ перегрузки операторов, чтобы перехватывать обращения к несуществующим атрибутам и делегировать эти обращения вложенноу объекту, вызовом встр. ф-ции getattr. Здесь также имеется адаптированная версия метода giveRaise, которая изменяет значение аргумента, передаваемого методу вложенного объекта.

В итоге наш класс Manager превращается в контроллер, который вызывае тметоды вложенного объекта, а не методы суперкласса:

# Альтернативная версия класса Manager 

class Person:
	... то же самое ...

class Manager(Person):
	def __init__(self, name, pay):
		self.person = Person(name, 'mgr', pay)		# Влож. объект Person
		
	def giveRaise(self, percent, bonus=.10):		# Перехватывает и делегирует
		self.person.giveRaise(percent + bonus)	
		
	def __getattr__(self, attr):					# Делегирует обращения 
		return getattr(self.person, attr)			# ко всем остальным атрибутам
		
	def __str__(self):
		return str(self.person)						# Требуется перегрузка (в 3.0)
		
if __name__ == '__main__':
	... то же самое ...

Этот вариант класса Manager представляет известный шаблон проектирования под названием - делегирование, - составная структура служит оберткой вокруг вложенного объекта, управляет им и перенаправляет ему вызовы методов.

В нашем случае, для конкретно нашего класса, этот прием конечно же не так хорош как механизм наследования. Реализация сложнее и запутаннее, мы привели этот пример лишь для изученяи альтернативы. Конечно делегирование может быть хорошо для других случаев, но не для наших классов.

Использование вложенных объектов будет успешно когда круг взаимодействий контейнера с влож. объектами уже, чем предполагает прием адаптации. Напр. уровень контроллера альтернативного класса Manager может пригодиться для отслеживания и проверки вызовов методов других объектов.

Для объединения других объектов в виде множества можно было бы использовать гипотетический агрегатный класс Department, как будет показано ниже. Для исследования этого класса можно добавить его в конец файла person.py:

if __name__ == '__main__':
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob)
	print(sue)
	tom = Manager('Tom Jones', 50000)	
	print(tom)
	print('--Department--')
	
class Department:
	def __init__(self, *args):
		self.members = list(args)
	def addMember(self, person):
		self.members.append(person)
	def giveRaises(self, percent):
		for person in self.members:
			person.giveRaise(percent)
	def showAll(self):
		for person in self.members:
			print(person)
			
development = Department(bob, sue)
development.addMember(tom)
development.giveRaises(.10)
development.showAll()      

Результаты вывода:

[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
[Person: Tom Jones, 50000]
--Department--
[Person: Bob Smith, 0]
[Person: Sue Jones, 110000]
[Person: Tom Jones, 60000]

Замечание. Здесь у нас в выводе везде класс Person, хотя у объекта tom должно быть Manager, сначала хотел реализовать свой метод для класса Manager, но не смог переделать его так же элегантно как метод giveRaise. Пробовал передавать атрибут имени класса объекта, но он выводится в неудобной форме, на этом я оставил попытки и не стал реализовывать свой метод __str__ для класса Manager. 

В этом примере использ-ся оба приема, наследование и встраивание - объекты класса Department явл-ся составными объектами, которые управляют другими встр. объектами, но сами встр. объекты классов person и Manager используют механизм наследования для адаптации своего поведения.

Еще один пример - графич. интерфейс пользователя, в его реализации  для адаптации поведения и внеш. вида кнопок и меток может использ-ся механизм наследования, а для создания пакетов встр. виджетов, таких как формы ввода, калькуляторы, текстовые редакторы, - прием встраивания.


Примечание. Перехват обращений к встроенным атрибутам в версии 3.0

В Питон 3.0 альтернатив. реализация класса Manager, основанная не делегировании, не может перехватывать и делегировать вызовы методов перегрузки операторов, таких как __str__, без их определения. Это общая проблема классов с делегированием.

Напоним, что встр. операции, напр вывод и обращение по индексу, неявно вызывают методы перегрузки операторов, такие как __str__ и __getitem__. В 3.0 подобные операции не использ. менеджеры атрибутов для неявного получения ссылок на атрибуты: они не использ. ни метод __getattr__ (вызывается при обращении к неопределенным атрибутам), ни __getattribute__ (вызывается при обращении к любым атрибутам). Именно поэтому нам пришлось переопределить метод __str__ в альтерантив. реализации класса Manager, чтобы обеспечить вызов метода встр. объекта Person при запуске сценария.

Технически это обсуловлено тем, что при работе с обычными классами интерпретатор ищет методы перегрузки операторов в экземплярах, а при работе с классами нового стиля - нет. Он пропускает экземпляр и пытается искать требуемый метод в классе.

Классы, с делегированием, в 3.0 в общем случае могут переопределять методы перегрузки операторов, чтобы делегировать вызовы вложенным объектам, либо вручную, либо с помощью др. инструментов или суперклассов. Мы вернемся позднее к проблеме с управлением атрибутами и снова обсудим эту тему.


Шаг 6: использование инструментов интроспекции.  стр. 750

Добавим последний штрих перед сохранением наших объектов в БД. Нам нужно сгладить две проблемы:

- Если обратить внимание как наши объекты выводятся на экран, то можно заметить, что объект tom, класса Manager, помечается как объект класса Person. Технич. это не ошибка, но было бы более  правильным, чтобы отображалось точное имя класса объекта (т.е. самого нижнего класса в иерархии). Кстати я сам об этом задумывался уже (см. выше).

- Еще более важный момент, в текущей версии отображается информация только о тех атрибутах, которые мы явно указали в методе __str__, чего может оказаться недостаточным в будущем. Напр. сейчас мы не можем убедиться, что атрибут job в объекте tom получает значение 'mgr' в конструкторе класса Manager, потому что метод __str__, который реализован в классе Person, не выводит его. Более того, если мы как-то изменим или расширим набор атрибутов в методе __init__, мы должны будем добавить вывод новых атрибутов в методе __str__.

Как видим у нас есть достаточно вопросов с заделкой "на будущее". И вообще, попытки избежать выполнения лишней работы в будущем вообще достойный поощрения.


Специальные атрибуты классов.

Обе проблемы можно решить с пом. инструментов интроспекции - спец. атрибутов и ф-ций, обеспечивающих доступ к внутр. реализации объектов. Это узкоспециализированные инструменты, и обычно использ-ся программистами, создающими инстурменты для др. программистов, и гораздо реже обычными программами. Эти инструменты позволяют писать программ. код, оперирующий классами обощенными способами. Мы могли бы использовать две особенности:

- Встроенные атрибут instance.__class__ в экземпляре ссылается на класс этого экземпляра. Классы имеют атрибут __name__, подобно модулям, и последовательность __bases__, обеспечивающую доступ к суперклассам. Мы можем использ. эти атрибуты при выводе имени класса, к котормоу принадлежит экземпляр, вместо того, чтобы вывод жестко заданное имя.

- Встр. атрибут object.__dict__ содержит словарь с парами ключ/значение, каждая из которых соответствует определенному атрибуту в пространстве имен объекта (включая модули, классы и экземпляры). Т.к. значением этого атрибута явл-ся словарь, мы можем получать из него список ключей, знач. атрибутов по ключам, выполнять итерации по ключам и т.д., и тем самым обеспечить обобщенный способ обработки всех атрибутов. На основе этого словаря мы можем реализовать вывод всех атрибутов, имеющихся в любом экземпляре, а не тольк ов тех, которые явно будут указаны в методе вывода.

Приведем пример использ-ия этих инструментов в IDLE. Внимание - мы импортируем класс Person с пом. from - имена классов располагаются в модуле и могут импортироваться как обычные ф-ции и переменные:

>>> from person import Person
>>> bob = Person('Bob Smith')
>>> print(bob)								# Вызов метода __str__ объекта bob
[Person: Bob Smith, 0]

>>> bob.__class__						# Выведет класс объекта bob
<class 'person.Person'>
>>> bob.__class__.__name__				# Выведет удобочитаемое имя класса объекта bob
'Person'
 
>>> list(bob.__dict__.keys())			# Атрибуты - это действительно ключи словаря 
['name', 'job', 'pay']

>>> for key in bob.__dict__:
	print(key, '=>', bob.__dict__[key])		# Обращение по индексам
...	
name => Bob Smith
job => None
pay => 0

>>> for key in bob.__dict__:
	print(key, '=>', getattr(bob, key))		# Аналогично выражению obj.attr,
...											# где attr - переменная
name => Bob Smith
job => None
pay => 0              

Как уже отмечалось, некоторые атрибуты экземпляров могут отсутствовать в словаре __dict__, если класс экземпляра определяет атрибут __slots__, который явл-ся дополнительной и малопонятной особенностью классов нового стиля (и всех классов в Питон 3.0), которая использ-ся для организации хранения атрибутов в виде массива и которую мы будем обсуждать в главах 30 и 31. Т.к. на самом деле слоты принадлежат классам, а не экземплярам, и они очень редко использ-ся на практике, мы можем просто игнорировать их в нашем примере и сосредоточиться на обычном атрибуте __dict__.


Обобщенный инструмент отображения.

Мы можем использ-ть эти инструменты в суперклассе для точного отображения имен классов и вывода значений всех атрибутов экземпляров любых классов.

Создадим новый файл - независимый модуль с именем classtools.py, реализующий единственный класс. В методе __str__ этого класса использ-ся инструменты интроспекции, поэтмоу он может работать с любыми экземплярами, независимо от того, как атрибутами они обладают.

А т.к. это - класс, а он автоматич. превращается в обощенный инструмент отображения: благодаря наследованию, он может добавляться в любые классы, где требуется обеспечить вывод данной информации.
А если нам нужно будет когда-нибудь в будущем изменить формат вывода информации, достаточно будет изменить только этот класс:

# Файл classtools.py (новый)
# Различные утилиты и инструменты для работы с классами

class AttrDisplay:
	"""
	реализует наследуемый метод перегрузки операции вывода, отображающий имена классов экземпляров
	и все атрибуты в виде пар имя=значение, имеющиеся в экземплярах (исключая атрибуты,
	наследуемые от классов). Может добавляться в любые классы и работать с любыми экземплярами.
	"""		
	def gatherAttrs(self):
		attrs = []
		for key in sorted(self.__dict__):
			attrs.append('%s=%s' % (key, getattr(self, key)))
		return ', '.join(attrs)
	
	def __str__(self):
		return '[%s: %s]' % (self.__class__.__name__, self.gatherAttrs())
		
if __name__ == '__main__':
	class TopTest(AttrDisplay):
		count = 0
		def __init__(self):
			self.attr1 = TopTest.count
			self.attr2 = TopTest.count+1
			TopTest.count += 2
			
	class SubTest(TopTest):
		pass
		
	X, Y = TopTest(), SubTest()
	print(X)						# Выведет все атрибуты экземпляра	
	print(Y) 						# Выведет имя класса, самого близкого в дереве классов

Обратите внимание на стркои документирования - мы поместили их даже в класс и можем даже в метод, и эти строки доступны ф-цией help и инструментом PyDoc.

Запускаем сценарий и код самопроверки создаст два экземпляра и выведет их - метод __str__ выведет имена классов экземпляров и все их атрибуты в виде пар имя=значение, по именам атрибутов по алфавиту: 

C:\Python34>classtools.py
[TopTest: attr1=0, attr2=1]
[SubTest: attr1=2, attr2=3]


Атрибуты экземпляров и атрибуты классов.

Если изучить код самопроверки модуля classtools, то можно заметить, что класс отображает только атрибуты экземпляров, присоединенные непосредственно к объекту в самом низу дерева - то есть те, что содержатся в атрибуте __dict__ объекта self.

Т.е. мы не получаем инфу об атрибутах, унаследованных экземплярами от классов выше по дереву (атрибут count, напр.). Унаследованные атрибуты класса присоед-ся только к объекту класса и не повторяются в экземплярах.

Если нам нужно узнать унаследованные атрибуты, мы можем с пом. ссылки __class__ получить доступ к классу экземпляра и извлечь из его словаря __dict__ атрибуты класса, а затем выполнит ьитерации через содержимое атрибута __bases__ класса, чтобы подняться до уровня суперклассов (так высоко как будет нужно). Если не усложнять код, вместо __dict__ можно вызывать встр. ф-цию dir, передав ей экземпляр и получить тот же результат:

>>> from person import Person
>>> bob = Person('Bob Smith')

>>> list(bob.__dict__.keys())
['name', 'job', 'pay']
>>> 
>>> dir(bob)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'giveRaise', 'job', 'lastName', 'name', 'pay']


Выбор имен в инструментальных классах.

Еще одна тонкость: т.к. наш класс AttrDisplay в модуле classtools явл-ся обощенным инструментом, чтобы служить суперклассом для любых др. классов, мы должны помнить о возможности случайных конфликтов имен с клиентскими классами.

Напр. если в клиентских подклассах будет переопределено имя gatherAttrs это может нарушить работу нашего класса, т.к. произойдет замещение методов.

Чтобы убедиться в этом добавим реализацию метода gatherAttrs в класс TotTest в коде самопроверки:

class TopTest(AttrDisplay):
	...
	def gatherAttrs(self):			# Replaces method in AttrDisplay! 	
		return 'Spam'

- а вот результат:

C:\Python34>classtools.py
[TopTest: Spam]
[SubTest: Spam]

Конечно это не всегда плохо, иногда нужно создавать др. методы в подклассах, для адаптации или по иным причинам. 

Чтобы минимизировать вероятность конфликта имен, программисты Питон часто добавляют символ подчеркивания в начало имени метода, НЕ предназначенного для использования за пределами класса: _gatherAttrs в нашем случае - конечно это не гарантия (кто мешает нам в подклассе тоже добавить подчерк), но - это общепринятое соглашение об именовании внутренних методов классов в языке Питон.

Лучшее, но реже используемое решение- это два подчеркивания в начало имени метода - __gatherAttrs. Интерпретатор автоматич. дополняет такие имена, включая в них имя вмещающего класса, что обеспечивает им истинную уникальность. Эта особенность обычно называют псевдочастные атрибуты класса.


Окончательные версии наших классов.

Теперь мы можем импортировать наш обощенный инструмент из модуля classtools, добавить в список наследования нашего базового класса и удалить из него реализацию нашего раннего метода __str__. Окончательная реализация модуля person.py:

# Файл person.py (окончательная версия)

from classtools import AttrDisplay			# Импортируем обощенный инструмент
 
class Person(AttrDisplay):
	"""
	Создает и обрабатывает записи с информацией о людях
	"""
	def __init__(self, name, job=None, pay=0):
		self.name = name
		self.job = job
		self.pay = pay
	def lastName(self):						# Предполагается, что фамилия
		return self.name.split()[-1]		# указана последней
	def giveRaise(self, percent):
		self.pay = int(self.pay * (1 + percent))	# Процент - величина в диапазоне 0..1

class Manager(Person):
	"""
	Версия класса Person, адаптированная в соответствии со специальными требованиями
	"""
	def __init__(self, name, pay):
		Person.__init__(self, name, 'mgr', pay)
	def giveRaise(self, percent, bonus=.10):
		Person.giveRaise(self, percent + bonus)
		
if __name__ == '__main__':
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob)
	print(sue)
	print(bob.lastName(), sue.lastName())
	sue.giveRaise(.10)
	print(sue)
	tom = Manager('Tom Jones', 50000)	
	tom.giveRaise(.10)							
	print(tom.lastName())						 
	print(tom)   

В окончательную версию мы добавили несколько комментариев, описывающих наши классы. И теперь наш сценарий выводит все атрибуты, а не только те, что были явно указаны в оригинальной версии метода __str__ (становится немного понятнее частое упоминание явно и неявно указанных атрибутов и прочих элементов кода, надеюсь дальше станет только понятнее что же такое явно и неявно указанные элементы).  

Также корректно указывается имя ближайшего класса, и убедимся, что атрибут job был корректно инициализирован в конструкторе класса Manager:

C:\Python34>person.py
[Person: job=None, name=Bob Smith, pay=0]
[Person: job=dev, name=Sue Jones, pay=100000]
Smith Jones
[Person: job=dev, name=Sue Jones, pay=110000]
Jones
[Manager: job=mgr, name=Tom Jones, pay=60000]

С точки зрения перспективы, наш класс, реализующий вывод атрибутов, можно рассматривать как обощенный инструмент, который можно использовать как суперкласс для любых других классов, обеспечивающий вывод атрибутов.


Шаг 7 (последний): сохранение объектов в базе данных. стр. 757

У нас имеется система из двух модулей, причем один из них можно использ. и в др. программах. Единственный минус - объекты, создаваемые классами не явл-ся настоящими записями БД, они удаляются по завершении программы. И сейчас мы займемся созданием хранилища объектов.


Модули pickle, shelve и dbm.

Эти модули обеспечивают сохранение объектов во всех версиях Питона:

pickle - Преобразует произвольные объекты языка Питон в строку байтов и обратно.

dbm (в Питон 2.6 anydbm) - Реализует сохранение строк в файлах, обеспечивающих возможность обращения по ключу.

shelve - Использует первые два модуля, позволяя сохранять объекты в файлах-хранилищах, обеспчивающих возможность обращения по ключу.

Модуль pickle обеспечивает самые общие средства преобразования объектов: он способен превратить практич. любой объект, находящийся в памяти, в строку байтов, а затем восстанвоить. Почти все объекты, знакомые нам - списки, словари, вложенные комбинации объектов, даже экземпляры классов. Сохраняя объекты в файле в виде строк с пом. модуля pickle, мы обеспечиваем долговременное хранение этих объектов, позднее можно загрузить эти стркои и восстановить данные.

С пом. pickle достаточно просто сделать сохранение объектов в простых файлах и загрузку их из файлов, однако модуль shelve обеспечивает доп. удобсва, позволяя сохранять объекты, обработанные модулем pickle, по ключу. Модуль shelve преобразует объект в строку с пом. модуля pickle и сохраняет её под указанным ключом в файле dbm. Позднее shelve извлекает строку по ключу и воссоздает оригинальный объект в памяти, с пом. модуля pickle. На вид сложно, однако в программе обращение к объектам в хранилище выглядит как обращение к элементам словаря - мы обращаемся к объекту по ключу, сохраняем его, выполняя присваивание по ключу, и можем использ. инструменты словарей, такие как len, in, dict.keys,  и т.п. Модуль shelve автоматич. отображает операции со словарем на объекты, хранящиеся в файле.

Отличие хранилища от словаря в том, что хранилища необходимо предварительно открывать, а затем закрывать после внесения изменений. Т.о. хранилища можно рассматривать как простые БД. Хранилища не поддерживают запросы (напр. SQL), не поддерживают транзакции и т.п., но в целом способны извлекат ьпользу из языка Питон.


Сохранение объектов в хранилище.

Напишем новый сценарий, который сохраняет экземпляры наших классов в хранилище. Назовем его makedb.py. и в него нужно импортировать наши классы.

На самом деле есть два способа импорта, как мы знаем:

import person					# Загружает класс с пом. инструкции import
bob = person.Person(...)		# Обращение к классу через имя модуля

from person import Person		# Загружает класс с пом. инструкции from
bob = Person(...)				# Обращение по непосредственному имени класса

Мы будем использовать инструкцию from (меньше кода нужно писать). Итак создадим нам модуль, с экземплярами, сохранение объектов в хранилище и кодом самопроверки:

# Файл makedb.py: сохраняет объекты Person в хранилище

from person import Person, Manager
bob = Person('Bob Smith')
sue = Person('Sue Jones', job='dev', pay=100000)
tom = Manager('Tom Jones', 50000)

import shelve
db = shelve.open('persondb')			# Имя файла хранилища
for object in (bob, sue, tom):			# В качестве ключа использовать атрибут name
	db[object.name] = object			# и сохранить объект в хранилище
db.close()								# Закрыть после внесения изменений

Заметим, что при присваивании объектов, в качестве ключей используются значения атрибутов name. Это просто для удобства мы сделали - ключами могут быть любые строки, которые можно было бы создать с применением уникальных характеристик, таких как идентификатор процесса и отметка времени (можно получит ьс пом. модулей os и time). Одно ограничение - ключи должны быть только строками и должны быть уникальными, т.к. под каждым ключем можно сохранять только один объект. А вот значения по ключу могут быть объектами любого типа.

Т.к. мы не создали никаких опознавательных выводов инфы, то просто запускаем сценарий и если ошибок нет, то объекты сохранились:

C:\Python34>makedb.py

C:\Python34>

- всё нормально, я конечно ошибся при импорте - забыл после Person указать класс Manager, но интерпретатор всё видит и указал на мою оплошность.
У меня все ошибки от невнимательности, я так понимаю они практически у всех такие же, все-таки логику работы и команды мы продумываем, а не пишем наугад, а вот рассеяность внимания сказывается на простых ошибках.


Исследование хранилища в интерактивном сеансе.

Сейчас у нас в каталоге имеется три файла имя которых начинается с "persondb" (у кого-то может и меньше или больше, у меня 3 файла). Как и ф-ция open, ф-ция shelve.open() создает файлы в текущем рабочем каталоге, если указанное имя не содержит полный путь. Но независимо от этого они обеспечивают доступ по ключу к представлениям объектов, созданных, с пом. модуля pickle.

Эти файлы и явл-ся нашей базой данных, их и нужно копировать если хотите создать копию или перенести БД. Файлы имеют двоичный формат и не имеют большого смысла вне контекста модуля shelve. Кстати у нас Питон 3.0 поэтому 3 файла. Рассмотрим их:

# Модуль, позволяющий получит ьсписок файлов в каталоге:
# проверка наличия файлов

>>> import glob
>>> glob.glob('person*')
['person.py', 'persondb.bak', 'persondb.dat', 'persondb.dir']

# Тип файла: текстовый - для строк, двоичный - для байтов

>>> print(open('persondb.dir').read())
'Tom Jones', (1024, 91)
'Sue Jones', (512, 92)
'Bob Smith', (0, 80)

>>> print(open('persondb.dat', 'rb').read())
b'\x80\x03cperson\nPerson\nq\x00)\x81q\x01}q\x02(X\x04\x00\x00\x00nameq\x03X\t\x00\x00\x00Bob Smithq\x04X\x03\x00\x00\x00jobq\x05NX\x03\x00\x00\x00payq\x06K\x00ub.\x00\x00\x00\x00...
... часть строк опущена...

Такая шифровка может изменяться от платформы к платформе, и точно не может называться дружественным интерфейсом к БД. Мы можем написать сценарий или поработать с хранилищем прямо в интерактивной оболочке.

Т.к. хранилища явл-ся объектами Питон, содержащими другие объекты Питон, мы можем работать с ними, используя обычный синтаксис Питона. Пример листинга интерактивного сеанса, который играет роль клиента базы данных:

>>> import shelve
>>> db = shelve.open('persondb')		# Открыть хранилище 

>>> len(db)								# В хранилище содержится три "записи"	
3
>>> list(db.keys())						# keys - это оглавление	
['Tom Jones', 'Sue Jones', 'Bob Smith']		

>>> bob = db['Bob Smith']					# Извлечь объект bob по ключу
>>> print(bob)								# Вызовет __str__ из AttrDisplay
[Person: job=None, name=Bob Smith, pay=0]

>>> bob.lastName()						# Вызовет lastName из Person
'Smith'

>>> for key in db:						# Итерации, извлечение, вывод 
	print(key, '=>', db[key])
	
Tom Jones => [Manager: job=mgr, name=Tom Jones, pay=50000]
Sue Jones => [Person: job=dev, name=Sue Jones, pay=100000]
Bob Smith => [Person: job=None, name=Bob Smith, pay=0]  
 
>>> for key in sorted(db):				# Итерации через отсортированный		
	print(key, '=>', db[key])			# список ключей
	
Bob Smith => [Person: job=None, name=Bob Smith, pay=0]
Sue Jones => [Person: job=dev, name=Sue Jones, pay=100000]
Tom Jones => [Manager: job=mgr, name=Tom Jones, pay=50000] 


Обратите внимание, нам не нужно импортировать классы Person и Manager. Мы можем вызвать метод lastName объекта bob и вывести его содержимое, даже при том, что класс Person этого объекта находится вне области видимости.

Это обусловлено тем, что, когда модуль pickle преобразует экземпляр класса, он записывает атрибуты экземпляра self вместе с именем класса, из которого был создан, и именем модуля, где находится определение этого класса. Т.о когда объект bob извлекается из хранилища, интерпретатор автоматич. импортирует класс и связывает с ним объект bob.

Благодаря такому поведению после загрузки экземпляры классов автоматич. обретают поведение своего класса. Мы должны импортировать наши классы, только если необходимо создавать новые экземпляры, но не для работы с существующими. Это влечет за собой некторые моменты:

- Недостаток заключ. в том, что позднее, когда вып-ся загрузка экземпляров, классы и их модули должы быть доступны для импорта. Т.е. классы сохраняемых объектов должны быть определены на верхнем уровне модуля, который нах-ся в одном из каталогов в пути поиска sys.path (и не должны нах-ся в модуле __main__ сценария, если только они не использ-ся только в пределах этого модуля). Из-за этих требований, в некоторых приложениях для сохранения использ-ся более простые объекты, такие как словари и списки, особенно если они передаются через Интернет.

- Преимущество заключ-ся в том, что изменения в реализации класса автоматич. будут восприняты экземплярами после их загрузки - часто нет никакой необходимости обновлять сохраненные объекты, потому что обычно изменения касаются только реализации методов класса.

Конечно у модуля shelve есть некоторые ограничения, но в целом shelve и pickle явл-ся отличными инструментами, когда речь идет о реализации простого хранилища объектов.


Обновление объектов в хранилище.

Создадим еще один сценарий, который обновляет экземпляры (записи) при каждом запуске, чтобы мы могли убедиться, что наши объекты действительно сохраняются между запусками программы (т.е. при каждом запуске доступны их текущие значения). Сценарий updatedb.py выводит содержимое БД и увеличивает з\п в одном из объектов при каждом запуске. Благодаря особенностям ООП и механизму наследования updatedb автоматич. вызывает наш метод __str__ и пользуется методом giveRaise:

# Файл updatedb.py: обновляет объекты класса Person в БД

import shelve
db = shelve.open('persondb')			# Открыть хранилище в файле с указанным именем

for key in sorted(db):					# Обойти и отобразить объекты в базе данных
	print(key, '\t=>', db[key])			# Вывод в требуемом формате
	
sue = db['Sue Jones']				# Извлечь объект по ключу
sue.giveRaise(.10)					# Изменить объект в памяти вызовом метода
db['Sue Jones'] = sue				# Присвоить по ключу, чтобы обновить объект в хранилище 

db.close() 							# Закрыть после внесения изменений

Запустим несколько раз сценарий и увидим как повышается з\п у sue:

C:\Python34>updatedb.py
Bob Smith       => [Person: job=None, name=Bob Smith, pay=0]
Sue Jones       => [Person: job=dev, name=Sue Jones, pay=100000]
Tom Jones       => [Manager: job=mgr, name=Tom Jones, pay=50000]

C:\Python34>updatedb.py
Bob Smith       => [Person: job=None, name=Bob Smith, pay=0]
Sue Jones       => [Person: job=dev, name=Sue Jones, pay=110000]
Tom Jones       => [Manager: job=mgr, name=Tom Jones, pay=50000]

C:\Python34>updatedb.py
Bob Smith       => [Person: job=None, name=Bob Smith, pay=0]
Sue Jones       => [Person: job=dev, name=Sue Jones, pay=121000]
Tom Jones       => [Manager: job=mgr, name=Tom Jones, pay=50000]

C:\Python34>updatedb.py
Bob Smith       => [Person: job=None, name=Bob Smith, pay=0]
Sue Jones       => [Person: job=dev, name=Sue Jones, pay=133100]
Tom Jones       => [Manager: job=mgr, name=Tom Jones, pay=50000]


Всё это - результат работы модулей shelve и pickle, и поведения реализованного в наших классах. К тому же мы можем проверить результаты запуска сценария с помощью интерактив. оболочки:

>>> import shelve
>>> db = shelve.open('persondb')
>>> rec = db['Sue Jones']
>>> print(rec)
[Person: job=dev, name=Sue Jones, pay=146410]
>>> rec.lastName()
'Jones'
>>> rec.pay
146410


Рекомендации на будущее.

Мы увидели и применили основные механизмы ООП языка Питон на практике. Создали полноценные классы. Создали настоящую БД. Конечно мы могли бы существенно увеличить ньюансы и тонкие настройки, добавить мелкие детали, но и основы это уже хорошо.

Кроме того, мы могли бы расширить круг наших интересов и использовать инструменты, поставляемые в составе Питона или доступные в мире ПО:

- Графический интерфейс пользователя. Мы могли бы графич. интерфейс для работы с БД (удобнее и дружелюбнее). Это можно с пакетом tkinter или сторонними инструментами WxPython или PyQt.

- Веб-сайты. Веб-интерфейсы опережают графич. интерфейсы в плане доступности, с Интернетом (Сетью) доступ к БД растет. Веб-сайты можно строить на основе CGI-сценариев, или использовать полноценные веб-фреймворки сторонних производителей, такие как Django, TurboGears, Pylons, Zope, Google App Engine. 

- Веб-службы. Мы можем предоставлять более прямой способ (отличный от веб-клиентов) извлечения записей из БД на стороне веб-сервера - посредством интерфейсов веб-служб, таких как SOAP, XML-RPC и т.д.

- Базы данных. Для больших и мощных БД мы могли бы использовать механизм хранения данных такой как ZODB, или традиционные реляционные БД, такие как MySQL, Oracle, PostgreSQL или SQLite.

- Механизмы объектно-реляционных отображений (ORM). При переходе на использование реляционных БД нам не придется отказываться от инструментов ООП, имеющихся в Питон. Механизмы объектно-реляционного отображения (object-relational mapping, ORM), такие как SQLObject и SQLAlchemy, могут автоматич. отображать реляционные таблицы и записи в классы и экземпляры на зяыке Питон и обратно, благодаря чему мы можем обрабатывать хранимые данные, используя привычный синтаксис классов языка Питон. Эти механизмы позволяют объединить сильные стороны реляционных БД и модели классов в Питон.

















Глава 28. Подробнее о программировании классов.  стр. 769


Инструкция class.

Инструкция class в Питон существенно отлич-ся от других ООП языков. Напр. как и в С++ инструкция class явл-ся основным инструментом ООП, но в отличие от С++, в Питон она не явл-ся объявлением. 

Подобно инструкции def инструкция class создает объект и явл-ся неявной инструкцией присваивания (еще одна отсылка к неявному/явному) - когда она выполняется, создается объект класса, ссылка на который сохраняется в имени, использованном в заголовке инструкции.

Как и def, инструкция class явл-ся настоящим выполняемым программ. кодом - класс не существует, пока поток выполнения не достигнет инструкции class, которая определяет его (напр. при импорте модуля).


Общая форма. стр. 770

Инструкция class - это составная инструкция, с блоком операторов, обычно под строкой заголовка. В заголовке, после имени, в круглых скобках, через запятую, перечисляются суперклассы (если они есть). Пример общей формы:

class <name>(superclass, ...):		# Присваивание имени
	data = value					# Совместно используемые данные класса
	def method(self, ...):			# Методы
		self.member = value			# Данные экземпляров

Внутри инструкции class любая операция присваивания создает атрибут класса, а методы со спец. именами перегружают операторы (помним __init__, который вызывается во время создания объекта экземпляра).


Пример.

Как мы знаем, классы - это всего лишь пространства имен, т.е. инструменты, определяющие имена (атрибуты), с пом. которых клиентам экспортируются данные и логика. Как же class порождает пространство имен?

А вот как. Как и в модулях, инструкции, вложенные в тело инструкции class, создают атрибуты класса. Когда интерпретатор доходит до инструкции class (далее просто - class, запомним, что class - это инструкция), а не когда происходит вызов класса, он выполняет все инструкции в её теле. Все присваивания, в итоге, создают имена в локал. области видимости класса, которые становятся атрибутами объекта класса. Поэтмоу классы напоминают модули и ф-ции:

- Подобно ф-циям, class явл-ся локал. областями видимости, где располагаются имена, созданные вложенными операциями присваивания.

- Подобно именам в модуле, имена, созданные внутри class, становятся атрибутами объекта класса.

Основное отличие классов в том, что их пространства имен составляют основу механизма наследования в Питон.

Т.к. class - это составная инструкция, в её тело могут быть вложены любые инструкции - print, =, if, def и т.д. Все инструкции внутри class выполняются, когда выполняется сама инструкция class (а не когда класс вызывается для создания экземпляра). Операции присваивания именам внутри class  создают атрибуты класса, а влож. инструкции def создают методы класса, кроме того атрибуты класса создаются и др. инструкциями, выполняющими присваивание.

Напр. присваивание объекта, не являющегося ф-цией, атрибутам, создает атрибуты данных, совместн оиспользуемых всеми экземплярами:

>>> class ShareData:
	spam = 42				# Присваивание создает атрибут данных класса
...	
>>> x = ShareData()
>>> y = ShareData()
>>> x.spam, y.spam			# Экземпляры наследуют и совместно используют атрибут spam
(42, 42)
      		
spam созд-ся на верхнем уровне в class, имя присоед-ся к классу и поэтому совместно использ-ся всеми экземплярами. 
Можно изменять значение атрибута, выполняя присваивание через имя класса, и обращаться к нему через имена экземпляров или класса:

>>> ShareData.spam = 99
>>> x.spam, y.spam, ShareData.spam
(99, 99, 99) 

Такие атрибуты могут хранить инфу, доступную всем экземплярам (напр. счетчик кол-ва созданных экземпляров, увидим в гл. 31).

А теперь попробуем присвоить знач. атрибуту spam не через имя класса, а через имя экземпляра:

>>> x.spam = 88
>>> x.spam, y.spam, ShareData.spam
(88, 99, 99)

Присваивание атрибуту экземпляра изменяет (или создает) имя в экземпляра, а не в классе (и это логично). Вообще, поиск в дереве наследования производится только при попытке чтения атрибута, но не присваивании: присваивание атрибуту объекта всегда изменяет сам объект, а не что-то другое (при условии, что в классе не переопредлелен метод перегрузки __getattr__, который отвечает за операцию присвавиания).

Приведем более понятный пример:

class MixedNames:							# Определили класс
	data = 'spam'							# Присваивание атрибуту класса
	def __init__(self, value):				# Присваивание имени метода
		self.data = value					# Присваивание атрибуту экземпляра
	def display(self):
		print(self.data, MixedNames.data)	# Атрибут экземпляра, атрибут класса
		
У нас две инстр. def связывают атрибуты класса с методами. Также есть присваивание = . Первое присваивание data идет внутри class, оно создается в локал. области видимости класса и становится атрибутов объекта класса. Как и все атрибуты класса, data наследуется и использ-ся всеми экземплярами класса, которые не имеют собственного атрибута data:

>>> x = MixedNames(1)			# Создаются два объекта экземпляра
>>> y = MixedNames(2)			# каждый из которых имеет свой атрибут data
>>> x.display(); y.display()	# self.data - это другие атрибуты,
1 spam							# а MixedNames.data - тот же самый
2 spam

Суть примера в том, что атрибут data находится в двух местах: в объектах экземпляров (атрибут self.data внутри __init__) и в классе (data = 'spam').

Сохраняя атрибуты в разных объектах мы определяем области их видимости. Атрибуты классов использ-ся всеми экземплярами, а атрибуты экземпляров уникальны для каждого экземпляра.

В прошлом примере выражения x.data и y.data возвращают атрибут экземпляра, которые переопределяют то же самое имя в классе. А выражение MixedNames.data явно обращается к атрибуту класса.


Методы.  стр. 772

Методы - это обычные объекты функций, которые созд-ся инструкциями def в теле class (как я понимаю это тема о методах классов, а не методах вообще). Методы реализуют поведение, наследуемое объектами экземпляров. Технич. методы работают так же как ф-ции, с одним исключением: в первом аргументе методам всегда передается подразумеваемый объект экземпляра.

Т.е. интерпретатор автоматич. отображает вызов метода экземпляра на метод класса следующим образом. 

Вывод метода экземпляра:

instance.method(args...)

автоматически преобразуется в вызов метода класса:

class.method(instance, args...)

где класс определяется в результате поиска имени метода по дереву наследования. Фактич. в Питон оба метода допустимы для использования.

Первый аргумент (отличит. особенность) обычно наз-ся self, в соотв. с общепринятыми соглашениями (технич. можете писать хоть qwerty, т.к. значение имеет позиция аргумента). Этот аргумент обеспечивает доступ к экземпляру, т.е. субъекту вызова - т.к. экземпляров может быть много аргумент self обеспечивает доступ к конкретному экземпляру.

Аргумент self всегда должен использоваться явно, в отличие от др. ЯП, напр. в С++ аргумент self напоминает указатель this, но использ-ся всегда явно.


Пример метода.

Пусть есть следующий класс:

class NextClass:					# Определение класса
	def printer(self, text):		# Определение метода
		self.message = text			# Изменение экземпляра
		print(self.message)			# Обращение к экземпляру

Имя printer ссылается на объект ф-ции, а т.к. оно создается в области (т.е. области видимости) class, оно становится атрибутом объекта класса и буде тунаследовано всеми экземплярами. Обычно такие методы как printer предназначены для обработки экземпляров:

>>> x = NextClass()					# Создаем экземпляр
 
>>> x.printer('instance call')		# Вызываем его метод
instance call
 
>>> x.message						# Экземпляр изменился
'instance call'	

Когда метод вызывается через имя экзмпляра, то сначала находится метод printer, а затем его аругменту self автоматич. присв-ся объект экземпляра (х). В аргумент text записывается строка, переданная в вызов метода ('instance call').

Обратите внимание - интерпретатор автоматич. передает в первом аргументе self ссылку на сам экземпляр, поэтому нам достаточно передать методу только один аргумент (text).

Методы могут вызываться как через экземпляр так и через сам класс:

>>> NextClass.printer(x, 'class call')		# Прямой вызов метода класса
class call
>>> x.message								# Экземпляр снова изменился			
'class call'   
 
Если попытаться вызвать метод без указания конкретного экземпляра, то получим ошибку:

>>> NextClass.printer('bad call')
...
TypeError: printer() missing 1 required positional argument: 'text' 


Вызов конструкторов суперклассов.

Методы обычно вызываются через экземпляры, но и вызов через класс может играть особую роль. Напр. вызов конструктора.

Метод __init__ наслед-ся так же, как и другие атрибуты. Это значит, что во время создания экземпляра интерпретатор отыскивает только один метод __init__. Если в подклассе нужно выполнение действий, предусматриваемых конструктором суперкласса, то нужно вызывать __init__ через имя класса:

class Super:
	def __init__(self, x):
		...программный код по умолчанию...
		
class Sub(Super):
	def __init__(self, x, y):
			Super.__init__(self, x)
			...адаптированный код...

I = Sub(1, 2)

Такое использование конструктора суперкласса нужн овыполнять только при действителньой необходимости. Реальный пример см. в предыдущей главе в классе Manager.


Другие возможности методов.

В главе 31 мы познакомимся с статическими методами, которые не предполагают наличие объекта экземпляра в первом аргументе. Родственные им методы класса принимают в первом аргументе сам класс и могу тиспольз-ся для манипулирования данными, принадлежащими конкретному классу.


Наследование.  стр. 775

Основное назначение class - поддержка наследования имен. Действите наследования заключ-ся в операции поиска в дереве определений атрибутов. Когда использ-ся выражение вида object.attr (где object - это объект экземпляра или класса), интерпретатор ищем первое вхождение атрибута attr в дереве пространств имен снизу вверх, начиная с object. Сюда относятся и ссылки на атрибуты аргумента self внутри методов.


Создание дерева атрибутов.

- Атрибуты экземпляров создаются посредством присваивания атрибутам аргумента self в методах.

- Атрибуты классов создаются инструкциями (присваивания), расположенными внутри инструкции class.

- Ссылки на суперклассы создаются путем перечисления классов в круглых скобках в заголовке class.

В рез-те появл-ся дерево пространств имен с атрибутами, которое иде тот экземпляров к классам, из которых они были созданы, и ко всем суперклассам, перечисленным в class. Поиск идет так же, снизу вверх, от экземпляров к суперклассам.

Рисунок 28.1 Способы создания и заполнения имен в дереве пространств имен. стр. 776


Специализация унаследованных методов.

Наследование - мощный инструмент адаптации и специализации программ, за счет добавления подклассов мы создаем целые системы, без изменения уже существующего кода.

Переопределение унаследованных имен дает множество приемов специализации. Подклассы могут полностью замещать унаследованные атрибуты, предоставлять атрибуты, которые ожидается отыскать в суперклассах, и расширять методы суперклассов за счет их вызова из методов подкласса. Мы уже знаем прием с замещением. Пример как выполняется расширение:

>>> class Super:
	def method(self):
		print('in Super.method')
		
>>> class Sub(Super):
	def method(self):						# Переопределить метод
		print('starting Sub.method')		# Дополнительное действие
		Super.method(self)					# Выполнить действие по умолчанию
		print('ending Sub.method') 

Главное здесь - это прямые вызовы методов суперкласса. Класс Sub замещает метод method класса Super, своей специализированной версией. Но внутри этого спец. метода происходит вызов оригинального метода из класса Super. Т.о. метод Sub.method не замещает полностью метод Super.method, а просто расширяет его:

>>> x = Super()
>>> x.method()			# Вызывается метод Super.method
in Super.method

>>> x = Sub()
>>> x.method()			# Вызывается Sub.method, который вызывает Super.method
starting Sub.method
in Super.method
ending Sub.method		
  
Этот прием расширения часто использ-ся в конструкторах.


Приемы организации взаимодействия классов.

В файле specialize.py определяется неск-ко классов, которые показывают приемы использ-ия классов:

- Super - Определяет метод method и метод delegate, который предполагает наличие метода action в подклассе.

- Inheritor - Не предоставляет никаких новых имен, поэтому он получает всё, что определено тольк ов классе Super.

- Replacer - переопределяет метод method класса Super.

- Extender - Адаптирует метод method класса Super, переопределяя и вызывая его, чтобы выполнить действия, предусмотренные по умолчанию.

- Provider - Реализует метод action, котоырй ожидается методом delegate класса Super.

Рассмотрим как эти классы адаптируют свой общий суперкласс. Содержимое файла:

class Super:
	def method(self):
		print('in Super.method')			# Поведение по умолчанию
	def delegate(self):
		self.action()						# Ожидаемый метод
		
class Inheritor(Super):						# Наследует методы как они есть
	pass
	
class Replacer(Super):						# Полностью замещает метод method
	def method(self):
		print('in Replacer.method')
		
class Extender(Super):						# Расширяет поведение метода method
	def method(self):
		print('starting Extender.method')
		Super.method(self)
		print('ending Extender.method')
		
class Provider(Super):						# Определяет необходимый метод
	def action(self):
		print('in Provider.action')

if __name__ == '__main__':
	for klass in (Inheritor, Replacer, Extender):
		print('\n' + klass.__name__ + '...')
		klass().method()
	print('\nProvider...')
	x = Provider()
	x.delegate()
			
Отметим моменты. Код тестирования создает экземпляры трех разных классов в цикле for. Т.к. классы - это объекты, можно поместить их в кортеж и создавать экземпляры единообразным способом. Кроме того классы, как и модули, имеют атрибут __name__  - он содержит строку с именем класса, указанным в заголовке инструкции class. Запустим файл specialize.py:

C:\Python34>specialize.py

Inheritor...
in Super.method

Replacer...
in Replacer.method

Extender...
starting Extender.method
in Super.method
ending Extender.method

Provider...
in Provider.action


Абстрактные суперклассы.  стр. 778

Обратим внимание как работает класс Provider в прошлом примере. Когда через экземпляр класса Provider вызывается метод delegate, инициируются две независимые процедуры поиска:

1. При вызове x.delegate интерпретатор отыскивает метод delegate в классе Super, начиная поиск от экземпляра класса Provider и двигаясь вверх по дереву наследования. Экземпляр х передается методу в виде аргумента self.

2. Внутри метода Super.delegate выражение self.action приводит к запуску нового, независимого поиска в дереве наследования, начиная от экземпляра self и дальше вверх по дереву. Т.к. аргумент self ссылается на экземпляр класса Provider, метод action будет найден в подклассе Provider.

Такой способ "восполнения пробелов" в реализации - обычное дело для платформ ООП. В терминах метода delegate такие суперклассы, как в этом примере, иногда называют абстрактными суперклассами- классы, которые предполагают, что часть их функциональности будет реализована их подклассами. Если ожидаемый метод не определен в подклассе - получим исключение.

Разработчики иногда делают такие требования к подклассам более очевидныыми, с пом. инструкций assert или возмуждая исключение NotImplementedError с пом. инструкции raise. Пример с assert:

>>> class Super:
	def delegate(self):
		self.action()
	def action(self):
		assert False, 'action must be defined!'
		
>>> X = Super()
>>> X.delegate()
...
    assert False, 'action must be defined!'
AssertionError: action must be defined!  

С assert мы познакомимся  позднее, а пока заметим, что если выражение возвращает ложь, она возбуждает исключение с указанным сообщением об ошибке. В нашем случае выражение всегда возвращает ложь, чтобы появилась ошибка, если метод action нигде не будет переопределен и поиск остановится на оригинальной версии.

В некоторых классах напротив, в таких методах-заглушках исключение NotImplementedError возбуждается напрямую:

>>> class Super:
	def delegate(self):
		self.action()
	def action(self):
		raise NotImplementedError('action must be defined!')
	
>>> X = Super()
>>> X.delegate()
...
    raise NotImplementedError('action must be defined!')
NotImplementedError: action must be defined!  

При работе с экземплярами мы также будем получать исключения, если подклассы не обеспечут свою реализацию ожидаемого метода, замещающего метод суперкласса:

>>> class Sub(Super): pass
>>> X = Sub()
>>> X.delegate()
...
NotImplementedError: action must be defined! 

>>> class Sub(Super):
	def action(self): print('spam')
	
>>> X = Sub()
>>> X.delegate()
spam

Более реалистичный пример использования концепций, представленных в этом разделе, мы получим в упражнениях позднее.


Абстрактные суперклассы в Питон 2.6 и 3.0

В обоих версиях Питон, абстрактные суперклассы могут быть реализованы спец. синтаксической конструкцией определения класса.

В 3.0 для этого использ-ся именованный аргумент в заголовке инструкции class и спец. декоратор @abstract методов:

from abc import ABCMeta, abstractmethod

class Super(metaclass=ABCMeta):
	@absctractmethod
	def method(self, ...):
		pass

В 2.6 вместо именованного аргумента в заголовке class, используется атрибут класса:

class Super:
	__metaclass__ = ABCMeta
	@absctractmethod
	def method(self, ...):
		pass
		
В любом случае получаем одно и то же - мы лишены возможности создавать экземпляры, если метод не будет определен ниже в дереве классов. Пример:

>>> from abc import ABCMeta, abstractmethod
>>> 
>>> class Super(metaclass=ABCMeta):
	def delegate(self):
		self.action()
	@abstractmethod
	def action(self):
		pass 

>>> X = Super()
TypeError: Can't instantiate abstract class Super with abstract methods action

>>> class Sub(Super): pass
...
>>> X = Sub()
TypeError: Can't instantiate abstract class Sub with abstract methods action

>>> class Sub(Super):
	def action(self): print('spam')
...	
>>> X = Sub()
>>> X.delegate()
spam

Такой класс, с абстрактным методом, не может использ-ся для создания экземпляров (т.е. нам не удастся создать экземпляр вызовом этого класса), если все абстрактные методы не будут реализвоаны в подклассах. 

Такой ход имеет свои преимущества - ошибку мы получим уже при попытке создания экземпляра, а не позднее, при попытке вызова отсутствующего метода.

Этот прием основан на декораторах функций и объявлениях метаклассов, с которыми мы познакомимся позднее.


Пространства имен: окончание истории.  стр. 781

Всмоним все правила, используемые при разрешении имен. Первое, что нам нужно запомнить: квалифицированные и неквалифицированные имена интерпретируются по-разному, и некоторые области видимости служат для инициализации пространств имен объектов:

- Неквалифицированные имена (напр. Х) располагаются в областях видимости.

- Квалифицированные имена атрибутов (напр. object.X) принадлежат пространствам имен объектов.

- Некоторые области видимости инициализируют пространства имен объектов (в модулях и классах).


Простые имена: глобальные, пока не выполняется присваивание.

Поиск неквалифицированных простых имен выполняется в соответствии с правилом лексической видимости LEGB, выведенном для функций в гл. 17:

- Присваивание (X = value). Операция присваивания делает имена локальными: создает или изменяет имя Х в текущей локальной области видимости, если имя не объявлено глоабльным.

- Ссылка (Х). Пытается отыскать имя Х в текущей локал. области видимости, затем в области видимости каждой из вмещающих функций, затем в текущей глоабл. области видимости и, наконец, во встроенной области видимости.


Имена атрибутов: пространства имен объектов.

Квалифицированные имена атрибутов ссылаются на атрибуты конкретных объектов и к ним прмиеняются правила, предназначенные для модулей и классов. Для объектов классов и экземпляров правила дополняются процедурой поиска в дереве наследования:

- Присваивание (object.X = value). Создает или изменяет атрибут Х в пространстве имен объекта object, и ничего больше. Поиск по дереву наследования идет только при поптыке получить ссылку на атрибут, но не при операции присваивания.

- Ссылка (object.X). Для объектов, созданных на основе классов, поиск атрибута Х производится сначала в объекте object, затем во всех классах выше в дереве наследования. Если объекты не из класса, напр. модули, атрибут Х извлекается непосредственно из объекта object.


"Дзен" пространств имен в Питон: классификация имен происходит при присваивании.

Из-за различий в процедурах поиска простых и составных имен и нескольких уровней поиска в обеих процедурах, иногда бывает трудно сказать где будет найдено имя.

В Питон, место, где выполняется присваивание, имеет крайне важное значение - оно полностью определяет область видимости или объект, где будет размещаться имя.

Файл manynames.py показывает как эти принципы переводятся в программ. код и обощает идеи, касающиеся пространств имен, которые мы встречали в книге:

# manynames.py

X = 11 					# Глобальное (в модуле) имя/атрибут (X, или manynames.X)

def f():
	print(X)			# Обращение к глобальному имени Х (11)
	
def g():
	X = 22				# Локальная (в ф-ции) переменная (Х, скрывает имя Х в модуле)
	print(X)
	
class C:
	X = 33				# Атрибут класса (С.Х)
	def m(self):
		X = 44			# Локальная переменная в методе (Х)
		self.X = 55		# Атрибут экземпляра (instance.X)


В этом файле пять раз выполняется присваивание имени Х. Но, т.к. присв-ие вып-ся в пяти разных метсах, то все пять Х явл-ся совершенно разными переменными.

Ниже  описывается продолжение файла, где создается экземпляр и выводятся значения всех имеющихся переменных Х:

# manynames.py, продолжение

if __name__ == '__main__':
	print(X)			# 11: модуль (за пределами файла manynames.py)
	f()					# 11: глобальная
	g()					# 22: локальная
	print(X)			# 11: переменная модуля не изменилась
	
	obj = C()			# Создать экземпляр
	print(obj.X)		# 33: переменная класса, унаследованная экземпляром
	
	obj.m()				# Присоединить атрибут Х к экземпляру
	print(obj.X)		# 55: экземпляр
	print(C.X)			# 33: класс (она же obj.X, если в экземпляре нет Х)
	
	#print(C.m.X)		# ОШИБКА: видима только в методе
	#print(g.X) 		# ОШИБКА: видима только в ф-ции


Обратите внимание, что мы можем добарться до атрибута класса (С.Х), но никогда не сможем получить доступ к локальным переменным в ф-циях или методах, находясь за пределами соотв. инструкций def. Локал. переменные видны только программ. коду внутри инструкции def и существуют в памяти только во время выполнения ф-ции или метода.

Некоторые имена из этого файла видны и в других модулях, но сначала мы должны импортировать модуль  manynames.py:

# otherfile.py

import manynames

X = 66
print(X)					# 66: здешняя глобальная переменная
print(manynames.X)			# 11: глобальная, ставшая атрибутом в результате импорта 

manynames.f()				# 11: X в manynames, не здешняя глобальная!
manynames.g()				# 22: локальная в ф-ции, в другом файле

print(manynames.C.X)		# 33: атрибут класса в другом модуле
I = manynames.C()
print(I.X)					# 33: всё еще атрибут класса
I.m()
print(I.X)					# 55: а теперь атрибут экземпляра!
	

Отметим, что manynames.f() выводи тзначение Х из модуля manynames, а не переменной из текущего модуля - обасть видимости всегда определяется местоположением инструкции присваивания в программ. коде (т.е. лексически) и не зависит от того, что импортируется и куда.

Крмое того, собственный атрибут Х в экземпляре отсутствовал, пока не был вызван метод I.m(), - атрибуты, как и любые переменные, появл-ся на свет во время операции присваивания, а не до неё.

Как мы знаем с помощью инструкций global и nonlocal функции могут изменять переменные, находящиеся за их пределами - эти инструкции не только обеспечивают доступ к переменным для записи, но и изменяют правила приявязки инструкций присваивания к пространствам имен:

X = 11					# Глобальная в модуле

def g1():
	print(X)			# Ссылка на глоабльную переменную в модуле
	
def g2():
	global X
	X = 22				# Изменит глобальную переменную в модуле

def h1():
	X = 33				# Локальная в функции
	def nested():
		print(X)		# Ссылка на локальную переменную в объемлющей функции

def h2():
	X = 33				# Локальная в функции	
	def nested():
		nonlocal X		# Инструкция из Питон 3.0	
		X = 44			# Изменит локальную переменную в объемлющей функции
		
		
Конечно пространства имен в Питон позволяют предотвратить случайный конфликт имен, но это совсем не значит, что мы должны использовать переменные с одинаковыми именами, желательно так совсем не делать. 


Словари пространств имен.

Мы знаем, что пространства имен модулей фактически реализованы как словари и доступны в виде встроенного атрибута __dict__. То же относится к объектам классов и экземпляров: обращение к квалифицированному имени атрибута фактич. явл-ся операцией доступа к эклементу словаря, а механизм наследования атрибута работает лишь как поиск в связанных словарях.

Фактич. объекты экземпляра и класса - это просто словари со ссылками ведущими вглубь интерпретатора.

Проследим, с пом. интерактив. оболочки, как растут словари пространств имен, когда в игру вступают классы (суперкласс и подкласс со своими данными):

>>> class Super:
	def hello(self):
		self.data1 = 'spam'
		
>>> class Sub(Super):
	def hola(self):
		self.data2 = 'eggs'  

Когда мы создаем экземпляр подкласса, он начинает своё существование с пустым словарем пространства имен, но имеет ссылку на суперкласс. Фактич. дерево наследования доступно в виде спец. атрибутов, которые мы можем проверить. Экземпляры обладают атрибутом __class__, который ссылается на класс, а классы имеют атрибут __bases__, который явл-ся кортежем, содержащим ссылки на суперклассы выше в дереве наследования:

>>> X = Sub()
>>> X.__dict__					# Словарь пространства имен экземпляра
{}

>>> X.__class__					# Класс экземпляра
<class '__main__.Sub'>

>>> Sub.__bases__				# Суперклассы данного класса
(<class '__main__.Super'>,)

>>> Super.__bases__				# В Питон 2.6 возвращает пустой кортеж ()
(<class 'object'>,)

Т.к. в классах вып-ся присваивание атрибутам аргумента self, тем самым они заполняют объекты экземпляров, т.е. атрибуты включаются в словари пространств имен экземпляров, а не классов.

В пространство имен объекта экземпляра записываются данные, которые могут отличаться для разных экземпляров, и аргумент self явл-ся точкой входа в это пространство имен:

>>> Y = Sub()
 
>>> X.hello()
>>> X.__dict__
{'data1': 'spam'}
 
>>> X.hola()
>>> X.__dict__
{'data1': 'spam', 'data2': 'eggs'}

>>> list(Sub.__dict__.keys())
['__module__', 'hola', '__doc__']
 
>>> list(Super.__dict__.keys())
['__dict__', '__weakref__', '__doc__', '__module__', 'hello']
 
>>> Y.__dict__
{} 

Обратите внимание на имена в словарях классов, содержащие символы подчеркивания, - эти имена определяются интерпретатором автоматич. Большинство из них обычно не использ-ся в программах, но сущ-ют такие инструменты, которые используют некоторые из этих имен (напр. __doc__ - хранит строки документирования).

А на примере второго экземпляра Y мы видим, что экземпляры имеют каждый свой независимый словарь, который изначально пуст, что мы и видим - несмотря на полный словарь экземпляра Х, словарь экземпляра Y по-прежнему пуст.

Т.к. атрибуты фактич. явл-ся ключами словаря, существует два способа получать и изменять их значения - по квалифицированным именам и индексированием по ключу:

>>> X.data1, X.__dict__['data1']
('spam', 'spam')

>>> X.data3 = 'toast'
>>> X.__dict__
{'data1': 'spam', 'data3': 'toast', 'data2': 'eggs'}
 
>>> X.__dict__['data3'] = 'ham'
>>> X.data3
'ham' 

Такая эквивалентность применяется только к атрибутам, фактич. присоединенным к экземпляру. Т.к. обращение по квалифиц. имени запускает поиск по дереву наследования, такой сопосб может обеспечивать доступ к атрибутам, которые нельзя получить индексирвоанием словаря. Напр. унаследованный атрибут X.hello недоступен через выражение X.__dict__['hello'].

Ниже увидим работу ф-ции dir с объектами классов и экземпляров. Эта ф-ция прим-ся к объектам, имеющим атрибуты: dir(object) напоминает вызов object.__dict__.keys(). Ф-ция dir сортирует свой список и включает в него некоторые системные атрибуты, а в 3.0 она добавляет имена, унаследованные от класса object, котоырй явл-ся суперклассом всех классов:

>>> X.__dict__, Y.__dict__
({'data1': 'spam', 'data3': 'ham', 'data2': 'eggs'}, {})
>>> list(X.__dict__.keys())
['data1', 'data3', 'data2']

>>> dir(X)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'data1', 'data2', 'data3', 'hello', 'hola']
>>> 
>>> dir(Sub)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'hello', 'hola']
>>> 
>>> dir(Super)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'hello']


Ссылки на пространства имен.

Атрибуты __class__ и __bases__ позволяют осматриват ьиерархии наследования в нашем коде. Напр. их можно использ. для отображения дерева классов на экране, пример:

# classtree.py

"""
Выполянет обход дерева наследования снизу вверх, используя ссылки на пространства имен, и отображает суперклассы с отступами
"""

def classtree(cls, indent):
	print('.' * indent + cls.__name__)		# Вывести имя класса
	for supercls in cls.__bases__:			# Рекурсивный обход всех суперклассов
		classtree(supercls, indent+3)		# Каждый суперкласс может быть посещен
											# более одного раза
def instancetree(inst):
	print('Tree of', inst)					# Показать экземпляр
	classtree(inst.__class__, 3)			# Взойти к его классу
	
def selftest():
	class A:		pass	
	class B(A):		pass
	class C(A):		pass
	class D(B, C):	pass
	class E:		pass
	class F(D, E):	pass
	
	instancetree(B())
	instancetree(F())

if __name__ == '__main__': selftest()


Функция classtree в этом сценарии явл-ся рекурсивной - она выводит имя класса, используя атрибут __name__, и затем начинает подъем к суперклассам, вызывая саму себя. Это позволяет ф-ции выполнять обход деревьев классов произвольной формы - в процессе рекурсии выполняется подъем по дереву и заканчивается по достижении корневых суперклассов, у которых атрибут __bases__ пуст.

Запустим наш сценарий, он построи тпустое дерево классов, создаст два экземпляра и выведет структуры классов, соотв. им:

C:\Python34>classtree.py
Tree of <__main__.selftest.<locals>.B object at 0x017CF7D0>
...B
......A
.........object
Tree of <__main__.selftest.<locals>.F object at 0x017CF7D0>
...F
......D
.........B
............A
...............object
.........C
............A
...............object
......E
.........object

В 3.0 у нас появляется суперкласс всех объектов object (в 2.6 его нет). Отступы, отмеченные точками, обозначают высоту в дереве классов.

Мы можем импортировать эту ф-цию везде где нам нужно будет отобразить дерево классов:

>>> class Emp: pass

>>> class Person(Emp): pass

>>> bob = Person()

>>> import classtree
>>> 
>>> classtree.instancetree(bob)
Tree of <__main__.Person object at 0x026B64F0>
...Person
......Emp
.........object


Еще раз о строках документирования. 

Строки, описывающие модули так же могут использ-ся для описания компонентов класса, причем они могут быть везде, во всех инструкциях программы.

Пример, docstr.py - показаны места в коде, где могут быть строки документирования:


"I am: docstr.__doc__"

def func(args):
	"I am: docstr.func.__doc__"
	pass

class spam:
	"I am: spam.__doc__ or docstr.spam.__doc__"
	def method(self, arg):
		"I am: spam.method.__doc__ or self.method.__doc__"
		pass

Преимущество строк документирования в том, что их содержимое доступно во время выполнения. Т.е. если текст оформлен в виде строк документирования, можно будет обратиться к атрибуту __doc__ объекта, чтобы получить его описание:

>>> import docstr
>>> docstr.__doc__
'I am: docstr.__doc__'

>>> docstr.func.__doc__
'I am: docstr.func.__doc__'
 
>>> docstr.spam.__doc__
'I am: spam.__doc__ or docstr.spam.__doc__'
 
>>> docstr.spam.method.__doc__
'I am: spam.method.__doc__ or self.method.__doc__'
           

Есть еще PyDoc - инструмент, который позволяет формировать отчеты из всех этих строк. Пример:

>>> help(docstr)
Help on module docstr:

NAME
    docstr - I am: docstr.__doc__

CLASSES
    builtins.object
        spam
    
    class spam(builtins.object)
     |  I am: spam.__doc__ or docstr.spam.__doc__
     |  
     |  Methods defined here:
     |  
     |  method(self, arg)
     |      I am: spam.method.__doc__ or self.method.__doc__
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

FUNCTIONS
    func(args)
        I am: docstr.func.__doc__

FILE
    /home/user/docstr.py

Строки документирования лучше использ-ть для функционального описания (что делают объекты), а комментарии "#" - для небольших пояснений (как действуют выражения, напр.).



Классы и модули.  стр. 791 

Различия заметить трудно. Опишем объекты в двух словах.

Модули:

- Это пакеты данных и исполняемого кода;

- Создаются как файлы с программным кодом на языке Питон или как расширения на языке С;

- Задействуются операцией импортирования.

Классы:

- Реализуют новые объекты;

- Создаются с помощью инструкции class;

- Задействуются операцией вызова;

- Всегда располагаются внутри модуля.

Классы так же поддерживают перегрузку операторов, создание множества экземпляров и наследование.

Нужно понимать, что несмотря на то, что классы и модуля явл-ся пространствами имен, между ними есть существенные различия.


















Глава 29. Перегрузка операторов.  стр. 794


Основы.







 
         


