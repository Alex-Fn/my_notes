
Часть 5. Классы и ООП.  стр. 693


Глава 25. ООП: общая картина.  стр. 695

Весь написанный нами код до этого, был основан  на объектах (object-based) - в сценариях мы передавали объекты, использовали в выражениях, вызывали их методы и т.д. Но чтобы наш код стал по-настоящему объектно-ориентированным (ОО), наши объекты должны участвовать в иерархии наследования.

Мы присутпаем к изучению классов - программных компонентов, используемых для реализации новых типов объектов, поддерживающих наследование. Классы - основные инструменты ООП в Питон. ООП представляет подход к программированию, при котором мы разлагаем код программ на составляющие, чтобы уменьшить его избыточность, и пишем новые программы, адаптируя имеющийся код, а не изменяя его.

Классы создаются с пом. инструкции class. Увидим, чт ообъекты, определяемые с пом. классов, очень напоминают встр. типы знакомые нам. На самом деле классы лишь применяют и дополняют понятия, которые мы уже рассмотрели. Проще - они представляют собой пакеты ф-ций, которые в основном использ. и обрабатывают объекты встр. типов. Основное назнач. классов в том, чтобы создавать и манипулировать новыми объектами, кроме того они поддерживают механизм наследования - иной способ адапатции кода и его повторного использ., чем мы узнали до этого.

ООП в Питно явл-ся необязательным и на первых порах нам можно не использ. классы. Они больше нужны для стратегического программирования (долгосрочная разработка). Но тем неменее классы полезный и мощный инструмент.


Зачем нужны классы?

Помните - "программы выполняют некоторые действия над чем-то"? Так вот классы - это лишь способ определить новое "что-то", они явл-ся отражением реальных объектов в мире программ. Напр. хотим сделать машину для готовки пиццы. Если реализовать её на основе классов, то мы могли бы смоделировать более близкое к реальности строение машины взаимосвязь между её механизмами. Здесь нам полезны два аспекта ООП:

- Наследование. Машина по изготовлению пиццы - это машина и должна иметь характеристики машин как таковых. В терминах ООП это наз-ся "наследованием" свойств более общей категории машин. Эти свойства нужно реализовать всего один раз и их можн обудет использ. для создания любых типов машин нужных нам.

- Композиция. Машина для пиццы состоит из множества компонентов, которые работают как единое целое. Напр. у нас будут манипуляторы (раскатывать тесто напр.), двигатели (надо же чем-то двигать машину) и т.д. На языке ООП наша машина - это пример композиции; она содержит др. объекты, которые активизируются для выполнения определенных действий. Каждый компонент можно оформить как класс.

Общие идеи ООП, как наследование и композиция, применимы к любым приложениям, которые можно разложить на объекты. Напр. интерфейс - набор визуальных элементов управления, кнопок, меток и т.д., которые рисуются на экране в момент, когда выполняется рисование их контейнеров (композиция). Также мы можем создать свои элементы - кнопки с уникальными шрифтами, новые цвета у элементов, вообщем свои специализированные версии общих эелементов (наследование).

Классы - это программ. компоненты Питона, как ф-ции и модули: они представляют собой еще один способ упаковки кода и данных. У классов есть свое пространство имен. Но есть и три важных отличия:

- Множество экземпляров. Классы это как-бы фабрики по созданию объектов. Каждый раз когда вызывается класс, создается объект со своим пространством имен. Объект, созданный из класса, имеет доступ к атрибутам класса и получает своё пространство имен для своих собственных данных, отличных от др. объектов. 

- Адаптация через наследование. Наследование - мы можем расширять возможности класса, переопределяя его атрибуты за пределами самого класса. Классы могут создавать иерархии пространства имен, которые определяют имена для использ-ия объектами, созданными из классов в иерархии.

Перегрузка операторов. Со спец. протоколом оформления методов, классы могут определять объекты, над которыми можно делать операции, которые мы знаем по встр. типам (напр. извлечение среза, конкатенация, индексация и т.д.). Питон предоставляет спец. обработчики для классов, для перехвата и реализации любой встр. операции.



ООП с высоты 30000 футов.  стр. 697

Поиск унаследованных атрибутов.

ООП в Питон проще в изучении и использ-ии чем в С++ или Java. Фактически ООП в Питон сводится к выражению:

object.attribute

Оно нам знакомо и мы его много использовали. Однако когда это выражение применяется к объекту, полученному с пом. class, интерпретатор начинает поиск - поиск в дереве связанных объектов, который заканчивается, как только будет встречено первое появление атрибута attribute. Когда в деле классы это выражение можно перевести так:

- Найти первое вхождение атрибута attribute, просмотрев объект object, а потом все классы в дереве наследования выше него, снизу вверх и слева направо.

Эта процедура поиска также еще наз-ся поиском в дереве наследования. Объекты ниже наследуют атрибуты у объектов выше по дереву.

Т.е. с пом. программ. кода мы действительно создаем деервья связанных объектов и интерпретатор поднимается по этому дереву вверх в поисках атрибутов.

Рисунок 25.1 Дерево классов.  стр. 698 

На рисунке дерево из 5 объектов, помеченных именами переменных. Два эземпляра внизу (I1, I2), класс выше их (С1) и два суперкласса в самом верху (С2 и С3), т.е. два объекта экземпляров и три объекта классов. Эти объекты явл-ся пространствами имен (пакетами переменных), а наследование означает просто поиск снизу вверх, с целью найти самое нижнее вхождение атрибута с нужным именем. Программ. код задает структуру таких деревьев.

Итак, каждый из этих объектов обладает набором атрибутов, а именно - I1.name; I2.name; C1.x, C1.y; C2.x, C2.z; C3.w, C3.z. Заметим, что классы и экземпляры порождаются от двух разных типов объектов:

- Классы. Играют роль фабрик экземпляров. Их атрибуты обеспечивают поведение - данные и функции - т.е. наследуются всеми экземплярами, созданными от них (напр. ф-ция, считающая зарплату, исходя из часового тарифа).

- Экземпляры. Представляют конкретные элементы программы. Их атрибуты хранят данные, которые могут отличаться в конкретных объектах (напр. номер карточки соц. страхования).

Т.о., по дереву, экземпляры наследуют атрибуты своих классов, а классы наследуют атрибуты классов выше по дереву.

Классы, выше по дереву (С2 и С3), обычно наз. суперклассами (или родительские, базовые), а классы ниже по дереву (С1), обычно наз. подклассами (или дочерние). Суперклассы реализуют общее поведения для подклассов, а подклассы могут переопределять поведение наследуемое от суперкласса, переопределяя имена суперклассов ниже в дереве.

Допустим мы создали дерево по рис. 25.1 и пишем:

I2.w

Этот код демонстрирует наследование. Т.к. это выражение вида object.attribute, оно приводит к запуску  поиска в дереве - интерпретатор ищет атрибут w начиная с I2 и идет вверх. Порядок такой - I2, C1, C2, C3.
Остановится когда найдет атрибут или возбудит исключение если w не найдет вообще. Т.о. автоматич. поиск найдет имя I2.w как C2.w. В терминологии ООП это наз-ся I2 "наследует" атрибут w от C3.

В итоге видим, что два экземпляра наследуют от своих классов 4 атрибута: w, x, y, z. Другие атрибуты будут анйдены в различ. местах в дереве. Например:

- Для I1.x  и I2.x атрибут х будет найден в С1, где поиск остановится, т.к. С1 нах-ся ниже в дереве чем С2.

- Для I1.y и I2.y атрибут y будет найден в С1, где поиск остановится, т.к. это единственное место где он появл-ся.

- Для I1.z и I2.z атрибут z будет найден в С2, т.к. С2 нах-ся в дереве левее чем С3.

- Для I2.name атрибут name будет найден в I2, т.к. в этом случае поиск вообще не будет идти по дереву.

Обратите внимание на атрибут х в С1, т.к. мы видим, что С1 переопределяет этот атрибут ниже в дереве, тем самым замещая версию атрибута, расположенную выше в С2. Ниже мы увидим, что такие переопределения составляют основу адаптации программ. обеспечения в ООП.


Классы и экземпляры.  стр. 700

Классы и экземпляры (отдельные типы объектов) вып-ют почти одну роль: каждый из этих типов служит неким представлением пространства имен - пакета переменных и места, где определяются атрибуты. Т.о. можно сказать, что классы и экземпляры похожи на модули, при этом объекты в деревьях классов содержат автоматически определяемые ссылки на др. объекты пространств имен, и классы соотв. инструкциям, а не файлам.

Различие между ними такое, что классы представляют собой своего рода фабрики по производству экземпляров. Напр. есть класс Employee, определяющих характеристики служащего - из этого класса мы можем создавать фактические экземпляры класса Employee.
Это еще одно отличие классов от модулей: у нас всегда есть всего один экземпляр модуля в памяти (поэтмоу мы его и перезагружаем при необходимости), но экземпляров класса мы можем сделать сколько хотим.

У классов обычно есть ф-ции, присоединенные к ним (пр. computeSalary), а у экземпляров - элементы данных, используемые ф-циями класса (пр. hoursWorked). Фактически модель ООП не так сильн оотличается от классич. модели обработки данных, основанной на программах и записях, - в ООП экземпляры подобны записям с "данными", а классы - "программам", обрабатывающим эти данные. Однако в ООП есть еще иерархия наследования.


Вызовы методов классов.

Выше мы видели как атрибут I2.w в нашем дереве классов транслируется в C3.w при поиске. Нуэно понимать и знать, что точно так же наследуются и методы (т.е. ф-ции, присоединенные к классам в виде атрибутов).

Если ссылка I2.w - это вызов ф-ции, то оно означает: "вызвать ф-цию C3.w для обработки I2". Т.е. интерпретатор автоматич. отобразит вызов I2.w() на вызов C3.w(), передав унаследованной ф-ции экземпляр в виде первого аргумента.

Фактич. всякий раз когда вызывается ф-ция, присоединенная к классу, подразумевается не класс целиком, а экземпляр класса. Этот экземпляр, или контекст, явл-ся одной из причин, почему данная модель названа объектно-ориентированной, - всегда существует объект, над которым выполняются действия. Напр. мы вызываем метод giveRaise, присоедиенный как атрибут к классу Employee, - вызов этого метода не имел бы смысла без указания служащего, которому дается надбавка к зарплате.

Как мы узнаем далее, Питон передает методам подразумеваемый экземпляр в виде спец. первого аргумента, в соответствии с соглашением именуемого self. Также узнаем, что методы могут вызываться как через экземпляры (bob.giveRaise()), так и через классы (Employee.giveRaise(bob)).


Создание деревьев классов.

За всеми идеями ООП стоит реальный код. Мы создаем деревья и объекты в них с пом. инструкций class и вызовов классов, которые рассмотрим позднее. В двух словах:

- Каждая инструкция class создает новый объект класса.

- Каждый раз, когда вызывается класс, он создает новый объект экземпляра.

- Экземпляры автомат. свзываются с классами, из которых они были созданы.

- Классы связаны со своими суперклассами, перечисленными в круглых скобках в заголовке инструкции class, при этом порядок следования в списке определяет порядок расположения в дереве.

Например чтобы создать деревео на рис. 25.1 мы можем написать такой код (без реализации классов конечно, она пока не нужна):

class C2: ...				# Создать объекты классов (на рис. это овалы)
class C3: ...
class C1(C2, C3): ...		# Создаем объект класса связанного с суперклассами

I1 = C1()				# Создаем объекты экземпляров (на рис. прямоугольники)
I2 = C1()				# связанные со своими классами

- как видим экземпляры конструируем вызвав класс С1 дважды, как если бы это была обычная ф-ция. Экземпляры помнят класс, из которого они созданы, а класс С1 помнит свои суперклассы.

В этом примере использ-ся т.н. множественное наследование, которое означает, что некий класс имеет более одного суперкласса над собой в дереве классов. А порядок суперклассов с кобках определяет порядок поиска атрибутов.

Большое значени имеет  то, к какому из объектов присоединяется тот или иной атрибут - что определяет его область видимости. Атрибуты, присоединямые к экземплярам, принадлежат только этим конкретным экземплярам, но атрибуты, присоединенные к классам, использ-ся и подклассами и экземплярами. Далее увидим, что:

- Атрибуты обычно присоед-ся к классам с пом. инструкций присваивания внутри class, а не во вложенных инструкциях def, определяющих ф-ции.

- Атрибуты обычно присоед-ся к экземплярам с пом. присваивания значений спец. аргументу с именем self, передаваемому ф-циям внутри классов.

Напр. классы поределяют поведение своих экземпляров с пом. ф-ций, создаваемых def внутри инструкций class. А т.к. такие влож. инструкции def выполняют присваивание именам внутри класса, они присоед-ся к объектам классов в виде атрибутов и будут унаследованы всеми экземплярами и подклассами:

class C1(C2, C3):					# Создать и связать класс С1
	def setname(self, who):			# Присвоить: С1.setname
		self.name = who				# self - либо I1, либо I2

I1 = C1()						# Создать два экземпляра
I2 = C1()
I1.setname('bob')				# Записать 'bob' в I1.name
I2.setname('mel')				# Записать 'mel' в I2.name 
print(I1.name)					# Выведет 'bob'

Синтаксис инструкции def здесь самый обычный. С функциональной точки зрения, когда def появл-ся внутри инструкции class, как в нашем примере, она обычно наз-ся методом и автомат. принимает спец. первый аргумент с именем self, который содержит ссылку на обрабатываемый экземпляр.

Примечание. Если бы мы ранее изучали С++ или Java, то заметили бы, что в Питон имя self - это то же, что и указатель this, но в языке Питон аргумент self всегда использ-ся явно, чтобы сделать обращения к атрибутам более очевидным.

Т.к. классы способны делать множество экземпляров их методы использ-т этот, получаемый автоматически, аргумент self для получения или изменения атрибутов конкретного экземпляра, который обрабатывается методом. В нашем прим. имя self использ-ся для сохранения имени служащего в конкретном экземпляре.

Как и простые переменные, атрибуты классов и экземпляров не объявляются заранее, а появл-ся когда им присв-ся значение. Когда метод присв-ет значение атрибуту с пом. имени self, он т.о. создает атрибут экземпляра, находящегося в нижнем уровне дерева классов, потмоу что имя self автоматич. ссылается на обрабатываемый экземпляр.

Благодаря тому, что все объекты дерева классов - всего лишь объекты пространств имен, можно получать или устанавливать любой из их атрибутов, используя соотв. имена. Например выражение C1.setname явл-ся таким же допустимым, как и I1.setname, с условием, что имена C1 и I1 находятся в области видимости программ. кода.

Сейчас класс С1 не присоед-ет атрибут name к экземплярам, пока не будет вызван метод setname. Если нужно, чтобы атрибут name всегда присутствовал в экземплярах, то он должен создаваться на этапе создания калсса:

class C1(C2, C3):					
	def __init__(self, who):		# Создать имя при создании класса
		self.name = who				# self - либо I1, либо I2

I1 = C1('bob')					# Записать 'bob' в I1.name
I2 = C1('mel')					# Записать 'mel' в I2.name 
print(I1.name)					# Выведет 'bob'
 
При таком решении интерпретатор автоматич. будет вызывать метод с именем __init__ каждый раз при создании экземпляра класса. Новый экземпляр будут передаваться методу __init__ в виде первого аргумента self, а любые значения, перечисленные в круглых скобках при вызове класса, будут передаваться во втором и последующих аргументах. Т.о. инициализация экземпляров будет выполняться в момент их создания.

Метод __init__ известен как конструктор, т.к. он запускается на этапе конструирования экземпляра. Этот метод явл-ся представителем класса методов, которые наз-ся методами перегрузки операторов. Такие методы наслед-ся в дереве как обычно, а их миена нач-ся и закан-ся двумя подчеркиваниями. Интерпретатор вызывает их автоматич. когда экземпляры, поддерживающие их, участвуют в соответствующих операциях, и они, глав. образом, явл-ся альтернативой вызовам простых методов. Так же они не обязательны, если их нет то соотв. операции просто не поддерживаются экземплярами.


ООП - это многократное использование программного кода.

Конечно в ООП есть не только наследование. Напр. перегрузка операторов может применяться в др. случаях - классы могут предоставлять свои реализации таких операций как доступ по индексу, получение значений атрибутов, выво ди мн. др. Но вообще ООП реализует поиск атрибутов в деревьях.

Используя классы мы адаптируем программы, вместо того, чтобы изменять код или писать новый в каждом проекте - ООП дает нам способы многократного использования программ. кода.             

Классы это действительно лишь пакеты ф-ций и др. имен, которые напоминают во многом модули. Но также они обеспечивают удобную структуру размещения кода и переменных. И, в отличие от ф-ций и модулей, благодаря дереву наследования и поиску в нем, дают широкие возможности по адаптации программ. кода.

Напр. методы - это обычные ф-ции со спец. первым аргументом, поэтому мы можем подражать некоторым их чертам поведения, вручную передавая объекты для обработки обычным ф-циям. Методы в наследовании классов дают возможность адаптировать существующее программное обеспечение, создавая новые подклассы, определяющие новые методы, вместо того, чтобы изменять сущзествующий код. Такое невозможно в случае с модулями или ф-циями.

Пример. Пусть нас привлекли к реализации БД, где хранится информация о служащих. На базе ООП мы могли бы начать с реализации суперкласса с общими категориями для служащих:

class Employee:
	def computeSalary(self): ...
	def giveRaise(self): ...
	def promote(self): ...
	def retire(self): ...
	
Реализовав общее можно специализировать его для каждой категории служащих (у них же есть отличия). Т.е. можно создать подклассы, в которых будут изменения на основе отличий от типового представления служащего - а общие черты останутся от суперкласса. Напр. з\п инженера начисляется по особым правилам (не по часовому тарифу например), т.о. нам нужно переопределить всего один метод:

class Engineer(Employee):			# Специализированный подкласс
	def computeSalary(self): ... 	# Особенная реализация метода

- Новая версия computeSalary будет нах-ся в дереве классов ниже и будет замещать (переопределять) общую версию метода в классе Employee. Далее можно будет создавтаь экземпляры разновидностей классов служащих	соответственно с принадлежностью:

bob = Employee()		# Поведение по умолчанию
mel = Engineer()		# Особые правила начисления з\п 

Обратите внимание, что можно создавать экземпляры любых классов в дереве, - класс, экземпляр которого создается, определяет уровень, откуда будет начинаться поиск атрибутов. Напр. в дальнейшем эти два объекта экземпляров (bob и mel) могли бы быть встроены в большой контейнерный объект (напр. список или экземпляр др. класса), котоый представляет отдел или компанию, реализуя идею композиции (см. начало главы).

Если нам понадобится узнать з\п этих служащих можно вычислить её в соотв. с правилами классов этих объектов, благодаря поиску в дереве наследования:

company = [bob, mel]				# Составной объект
for emp in company:
	print(emp.computeSalary())		# Вызвать версию метода данного объекта 

Отметим, что список company мог бы храниться в файле (удобно для БД), например с пом. модуля pickle. Кроме того в Питон входит модуль shelve, который мог бы сохранять экземпляры классов в файлах с доступом по ключу, то же самое обеспечивает сторонняя разработка ZDOB и даже более качественно.


Последний пример - это еще одна разновидность полиморфизма (см. гл. 4 и 16). Т.е. смысл операции зависит от объекта, над которым она выполняется. Здесь метод computeSalary определяется для каждого объекта в дереве наследования. 

В др. приложениях полиморфизм может применяться для сокрытия (т.е. для инкапсуляции) различий интерфейсов. Напр. программа, которая обрабатывает потоки данных, может работать с объектами, имеющими методы ввода и вывода, не заботясь о том, что эти методы делают в действительности:

def processor(reader, converter, writer):
	while 1:
		data = reader.read()
		if not data: break
		data = converter(data)
		writer.rwite(data)
		
Передавая экземпляры классов с необходимыми интерфейсными методами read и write, специализированными под различные источники данных, мы можем использовать одну и ту же ф-цию processor для работы с любыми источниками данных, как уже существующими, так и с тем, что появятся в будущем:

class Reader:
	def read(self): ...				# Поведение и инструменты оп умолчанию
	def other(self): ...
class FileReader(Reader):
	def read(self): ...				# Чтение из локального файла
class SocketReader(Reader): ...
	def read(self): ...				# Чтение из сокета

...
processor(FileReader(...), 		   Converter, FileWriter(...))
processor(SocketReaderReader(...), Converter, TapeWriter(...))
processor(FtpReader(...), 		   Converter, XmlWriter(...))


Благодаря тому, что внутр. реализация методов read и write была разделена по типам источников данных, их можно изменять, не трогая программный код, подобный приведенному, который использует их.
Фактически ф-ция processor сама может быть классом, реализующим логику работы ф-ции преобразования converter, которую могут унаследовать подклассы, и позволяющим встраивать экземпляры, выполняющие чтение и запись, в соотв. с принципом композиции.

Когда мы привыкнем программировать в ООП, то обнаружим, что наша задача сводится к тому, чтобы в новом проекте подобрать уже имеющиеся суперклассы для нашей задачи.

На практике мы можем найти или купить уже готовые библиотеки суперклассов, известные как "фреймворки", в которых задачи программирования реализвоаны в классах. Напр. интерфейсы к БД, протоколы тестирования, создание графич. интерфейса и мн. др.

Конечно для понимания ООП и адаптации кода нужно время, нужно много работать и учиться. Кстати, ряд программистов изучают и составляют списки наиболее часто встречающихся решений в ООП, сейчас они известны как - шаблоны проектирования.    


















Глава 26. Основы программирования классов.  стр. 709 

Теперь мы приступим к изучению синтаксиса модели классов в Питон. В этой главе рассмотрим неск-ко простых классов в действии.

Классы обладают тремя основными отличительными особенностями. На самом простом уровне они представляют собой лиш ьпространства имен, во многом похожие на модули, которые мы изучали в пятой части книги. Но, в отличие от модулей, классы также поддерживают создание множества объектов, реализуют наследуемое пространство имен и перегрузку операторов.


Классы генерируют множество экземпляров объектов.

Чтобы понять эту возможность, для начала нужно понимать, что в ОО модели Питон существует две разновидности объектов: объекты классов и объекты экземпляров. 

Объекты классов реализуют поведение по умолчанию и играют роль фабрик по производству объектов экземпляров.  

Объекты экземпляров - это настоящие объекты, обрабатываемые программой, - каждый представляет собой самостоятельное пространство имен, но наследует имена (т.е. автоматич. имеет доступ к ним) класса, из которого был создан.

Объекты классов считаются инструкциями, а объекты экземпляров - вызовами. Каждый раз когда мы вызываем класс, мы получаем новый экземпляр этого класса. Классы - это фабрики, которые могут воспроизводит ьмножество экземпляров. В противоположность этому каждый модуль может присутствовать в программе в единственном экземпляре.

Как мы увидим ниже классы в Питон сочетают в себе черты, напоминающие ф-ции и модули, но они совершенно не похожи на классы в др. ЯП.


Объекты классов реализуют поведение по умолчанию.

Когда вып-ся инструкция class, она создает объект класса. Приведем неск-ко отличительных характеристик классов в Питон.

- Инструкция class создает объект класса и присваивает ему имя. Как и def, class явл-ся выполняемой инструкцией. Когда она вып-ся она создает новый объект класса и присваивает его имени, указанному в заголовке class. Как и def инструкция class обычно вып-ся при первом импорте содержащих их файлов.

- Операции присваивания внутри инструкции class создают атрибуты класса. Как и в модулях, операции присваивания на верх. уровне (не влож. в инструкции def создают атрибуты объекта класса. Инструкция class преобразует свою область видимости в пространство имен атрибутов объекта класса, так же, как глоабльная область видимости модуля преобразуется в его пространство имен. При выполнении инструкции class атрибуты класса становятся доступны по их составным (полным) именам: object.name.

- Атрибуты класса описывают состояние объекта и его поведение. Т.е. атрибуты хранят информацию о состоянии и описывают поведение, которым обладают все экземпляры класса, - инструкции def, вложенные в class, создают методы, которые обрабатывают экзмепляры.


Объекты экземпляров - это конкретные элементы.

Когда выз-ся объект класса, возвращается объект экземпляра. Приведем неск-ко характеристик экземпляров.

- Вызов объекта класса как функции создает новый объект экземпляра. Когда вызываем класс создается и  возвращается новый объект экземпляра. Экземпляры - это конкретные элементы данных в нашей проге.

- Каждый объект экземпляра наследует атрибуты класса и приобретает свое собственное пространство имен. Экземпляры созд-ся из классов и представляют собой новые пространства имен, они первоначальн опустые, но наследуют атрибуты класса из которого созданы.

- Операции присваивания значений атрибутам, через ссылку self в методах, создают атрибуты в каждом отдельном экземпляре. Методы класса, в первом аргументе (с именем self), получают ссылку на обрабатываемый объект экземпляра - присв-ие атрибутам через ссылку self создает или изменяет даннеы экземпляра, а не класса.


Первый пример.

Определим класс FirstClass в интерактив. оболочке:

>>> class FirstClass:					# Определяет объект класса
		def setdata(self, value):		# Определяет метод класса
			self.data = value			# self - это экземпляр
		def display(self):
			print(self.data)			# self.data - данные экземпляра

Здесь мы работаем в оболочке, но обычно такие инструкции вып-ся во время импорта вмещающего файл модуля. Как и ф-ции, классы не существуют пока интерпретатор не достигнет инструкций class и не выполнит их.

class нач-ся с заголовка (имя класса), затем идет тело класса (как обычно с отступами если нужно). У нас влож. инструкции это инструкции def - они определяют ф-ции, реализующие поведение класса.

Как мы знаем def на самом деле явл-ся операциями присв-ия - в нашем случае они присваивают объекты ф-ций именам setdata и display в области видимости инструкции class и тем самым создают атрибуты, присоединяемые к классу: FirstClass.setdata и FirstClass.display. Т.е. любое имя, которому присв-ся знач. на верх уровне во вложенном блоке класса становится атрибутом этого класса.

Ф-ции внутри классов обычно наз-ся методами. Но в первом аргументы они автоматич. получают подразумеваемый объект экземпляра - конекст вызова метода. Создадим пару экземпляров:

>>> x = FirstClass()
>>> y = FirstClass()

- Создаются два экземпляра с отдельными пространствами имен.

Вызывая класс таким образом мы создаем объекты экземпляров (обратите внимание на круглые скобки), которые явл-ся лишь пространством имен и имеют доступ к атрибутам класса.

Теперь у нас есть три объекта - два экземпляра и класс. Они связаны пространствами имен, по ООП объект х "наследует" класс FirstClass как и y.

Здесь у нас, в дереве наследования, атрибут "data" обнаруживается в экземплярах, а "setdata" и "display" - в классе, расположенном выше их.

Изначально оба экземпляра пустые, но они свзяаны с классом, из которого были созданы. Если через имя экземпляра обратиться к атрибуту объекта класса, то поиск вернет нам значение атрибута класса (при условии, что в экземпляре отсутствует одноименный атрибут):

>>> x.setdata("King Arthur")		# Вызов метода: self - это х
>>> y.setdata(3.14159)				# Эквивалентно: FirstClass.setdata(y, 3.14159)

Ни x, ни y не имеют атрибута setdata, поэтмоу интерпретатор идет по ссылке от экземпляра к классу. В этом и проявл-ся суть наследования в Питон - поиск имен в связанных объектах.

В ф-ции setdata внутри класса FirstClass значение аргумента записывается в self.data. Имя self внутри метода - имя самого первого аргумента, в соответствии с принятым соглашением, - автоматич. ссылается на обрабатываемый экземпляр (x или y), поэтмоу присваивание сохраняет значения в пространстве имен экземпляра, а не класса (так созд-ся имена-атрибуты "data" у экземпляров).

По причине того, что классы могут делать много экземпляров, методы должны использ-ть аргумент self, чтобы получит ьдоступ к обрабатываемому экземпляру. Пр ивызове метода display, чтобы вывести значение атрибутов self.data, мы увидим, что для каждого экземпляра они разные; с др. стороны, имя display само по себе одинаковое в x и y, т.к. оно пришло (унаследовано) из класса:

>>> x.display()			# В каждом экземпляре свои значения self.data
King Arthur
>>> y.display()
3.14159   

Видите - в атрибутах data экземпляров мы сохранили объекты различных типов (строку и число). Как и везде в Питон, атрибуты экземпляров (иногда наз-ся членами) никак не объявл-ся - они появл-ся, как только будет выполнена первая опреация присваивания (как и переменные). Т.е. если вызвать метод display до вызова метода setdata, то получим сообщение об ошибке.

Еще один способ позволяет изменять атрибуты экземпляров в самом классе, выполняя присваивание как с пом. аргумента self внутри методов, так и за пределами класса, когда экземпляр явно участвует в операции присваивания:

>>> x.data = "New value"
>>> x.display()
New value

Хоть это и редко применяется, но сущ-ет возможность создания новых атрибутов в пространстве имен экземпляра, присваивая значение за пределами методов класса:

>>> x.anothername = "spam"

Эта операция присоединит новый атрибут anothername, который затем сможет использ-ся любыми методами класса в объекте экземпляра х. Обычно классы создают все атрибуты экземпляров за счет присваивания значений аргументу self, но это не обязательно - программы могут получать, изменять или создавать атрибуты в любых объектах, к которым имеют доступ.


Классы адаптируются посредством наследования.

Помимо роли фабрик классы позволяют нам вводить новые компоненты (за счет подклассов), а не изменением существующего кода. Объекты экземпляров, созданнеы из класса, наследуют атрибуты класса. Классы могут наследовать др. классы, что открывает нам путь к иерархии классов, поведение которых специализируется за счет переопределения обощенных атрибутов, находящихся выше в дереве классов, подклассами, находящимися ниже. Т.е. чем ниже подклассы тем они спецрализированнее.

В Питон экземпляры наследуют классы, а классы наследуют суперклассы. Опишем основные идеи, лежащие в основе механизма наследования атрибутов:

- Суперклассы перечисляются в круглых скобках в заголовке инструкции class. Т.е., чтобы унаследовать атрибуты класса нужно указать его в кругл. скобках в заголовке инструкции class. Наследующий класс наз-ся подклассом, а наследуемый - суперклассом.

- Классы наследуют атрибуты своих суперклассов. Как экземпляры наследуют атрибуты своих классов, так и классы наследуют все атрибуты, определяемые в суперклассах.

- Экземпляры наследуют атрибуты всех доступных классов. Экземпляр наследует атрибуты своего класса, а также всех суперклассов. Поиск имен сначала проверяет сам экземпляр, потом его класс и потом все суперклассы.     

- Каждое обращение object.attribute вызывает новый независимый поиск. Интерпретатор проводит отдельный поиск в дереве классов для каждого атрибута, который ему встречается в выражении запроса. Сюда входят ссылки на экземпляры и классы из инструкции class (напр. X.attr), а также ссылки на атрибуты аргумента экземпляра self в методах класса. Каждое выражение self.attr в методе вызывает поиск attr в self и выше.

- Изменения в подклассах не затрагивают суперклассы. Замещение имен суперкласса в подклассах изменяет подклассы и тем самым изменяет унаследованное поведение.

Классы обеспечивают разложение на отдельные операции и адаптацию кода лучше, чем это могут сделать др. компоненты языка. Классы позволяют минимизировать избыточность программ. кода, а с др. - позволяют адаптировать уже существующий код, вместо его изменения.


Второй пример.

Итак, второй пример будет основан на предыдущем. Определим новый класс SecondClass, который наследует класс FirstClass и добавляет кое-что своё:

>>> class SecondClass(FirstClass):						# Наследует метод setdata
		def display(self):								# Изменяет метод display				
			print('Current value = "%s"' % self.data)

- т.о. SecondClass замещает атрибут display своего суперкласса.

В этом случае мы говорим, что класс SecondClass переопределяет метод display класса FirstClass. Иногда такая замена атрибутов, за счет переопределения, называется перегрузкой.

Сейчас класс SecondClass специализирует класс FirstClass, изменяя поведение метода display. С др. стороны он наследует метод setdata (как и все экземпляры подкласса). Создадим экземпляр:

>>> z = SecondClass()
>>> z.setdata(42)				# Найдет setdata в FirstClass
>>> z.display()					# Найдет переопределенный метод в SecondClass
Current value = "42"

- думаю нам понятны наследование и поиск и схема пространства имен в этом примере.

Заметим. Специализация, выполненная в классе SecondClass, находится полностью за пределами класса FirstClass. Т.е. она не оказывает влияние на уже созданнеы или создаваемые впоследствии объекты класса FirstClass, напр. х:

>>> x.display()		# Старое значение х (см. выше)
New value 

Т.о. мы не изменяли класс FirstClass, мы адаптировали его. Этот пример показывает нам как можно вносить изменения с пом. внеш. компонентов (подклассов).


Классы - это атрибуты в модулях.

Напомним, что в именах классов нет ничего необычного, это всего лишь переменные, которым присваиваются объекты во время выполнения инструкции class, а ссылки на объекты можно получить с пом. обычных выражений.

Напр. если бы определение класса FirstClass находилось в файле модуля, а не было введено в оболочке, мы могли бы импортировать этот модуль и использовать имя в строке заголовка инструкции class:

from modulename import FirstClass		# Скопировать имя в мою область видимости
class SecondClass(FirstClass):			# Использовать имя класса непосредственно	
	def display(self): ...

Или эквивалентный вариант:

import modulename								# Доступ ко всему модулю целиком
class SecondClass(modulename.FirstClass):		# Указать полное имя 
	def display(self): ...

Имена классов, как и всё остальное, всегда нах-ся в модулях, и поэтому при их употреблении необходимо следовать правилам, которые мы рассматривали в пятой части книги. Напр. в одном модуле могут нах-ся определения сразу нескольких классов - подобно другим инструкциям в модулях, инструкции class выполняются в ходе операции импорта и определяют имена, которые в свою очередь становятся атрибутами модуля.

Вообще любой модуль может содержать самые произвольные сочетания из любого числа переменных, ф-ций и классов, и все эти имена будут вести себя в модуле одинаково. Рассмотрим файл food.py:

# food.py

var = 1			# food.var

def func():		# food.func
	...
class spam:		# food.spam
	...
class ham:		# food.ham
	...
class eggs:		# food.eggs
	...

Это правило остается справедливым даже если модуль и класс имеют одинаковые имена. Например имеется файл person.py:

class person:
	...
	
Чтобы получить доступ к классу нам нужно обратиться к модулю как обычно:

import person				# Импортируем модуль
x = person.person()			# Класс внутри модуля

Имя person.person ссылается на класс person внутри модуля person, если мы просто будем использ-ть имя person, то обратимся к модулю, а не классу, но только если мы не использовали from:

from person import person
x = person()

Как и любые др. переменные, мы не увидим класс в файле модуля, пока не импортируем его или как-то не извлечем класс из вмещающего файла. Если для вас это сложно, то не используйте одинаковые имена для модулей и классов.

Согласно соглашениям, имена классов в Питон должны начинаться с заглавной буквы, для визуального отличия:

import person
x = person.Person()

И еще, несмотря на то, что классы и модули явл-ся пространствами имен для подключения атрибутов, они представляют собой совершенно разные структуры: модуль это отражение целого файла, а класс - лишь инструкция внутри файла.


Классы могут переопределять операторы языка Питон. стр. 717

Перегрузка операторов позволяет объектам, созданным из классов, перехватывать и участвовать в операциях, которые применяются к встроенным типам: сложение, получение среза, вывод, квалификация имен и т.д. 

Можно полностью реализовать класс в виде методов, однако перегрузка операторов позволяет объектам теснее интегрироваться в объектную модель Питона. Кроме того перегрузка позволяет нашим объектам действовать так же, как действуют встр. объекты, потому что она позволяет создавать менее противоречивые и более простые в изучении интерфейсы объектов и обеспечивает возможность обрабатывать объекты, созданные из классов, программным кодом, который предполагает взаимодействие со встр. типами.

Опишем основные идеи, лежащие в основе мехханизма перегрузки операторов:

- Имена методов, начинающиеся и заканчивающиеся двумя символами подчеркивания (__Х__), имеют специальное назначение. Перегрузка реализуется за счет создания методов со спец. именами для перехватывания операций. Питон определяет фиксированные и неизменяемые имена методов для каждой из операций.

- Такие методы вызываются автоматически, когда экземпляр участвует во встроенных операциях. Напр. если объект экземпляра наследует метод __add__, этот метод будет вызываться всякий раз, когда объект будет появл-ся в операции сложения (+). Возвращаемое значение метода становится результатом соотв. операции.

- Классы могут переопределять большинство встроенных операторов. Есть много спец. имен методов для реализации перегрузки почти всех операторов встр. типов. Это операторы выражений, базовые операции, такие как вывод и создание объекта.

- В методах перегрузки операторов не существует аргументов со значениями по умолчанию, и ни один из таких методов не явл-ся обязательным для реализации. Если класс не определяе ти не наследует методы перегрузки операторов, то это значит, что экземпляры класса не поддерживают эти операции. Напр. если нет метода __add__, попытка выполнить операцию + приведет к ошибке.

- Операторы позволяют интегрировать классы в объектную модель Питона. Благодаря перегрузке операторов, объекты, реализованные на базе классов, действуют подобно встр. типам и тем самым обеспечивают непротиворечивые и совместимые интерфейсы.

Вообще перегрузка не явл-ся обязательной функциональной особенностью, если она не нужна в вашем классе, то и хорошо, используйте стандартные методы. Напр. приложению работающему с БД не нужны такие операторы как * и + (нам нечего умножать и складывать в БД, со всеми задачами справятся стандартные методы работы с БД).

Мы не будем изучать перегрузку каждого оператора, доступного в Питон. Но есть один метод перегрузки оператора, который можно встретить практически в любом классе: метод __init__, который известен как конструктор и использ-ся для инициализации состояния объектов. Наряду с self он явл-ся одним из ключей понимания ООП в Питон.


Третий пример.

Определим подкласс, производный от SecondClass и реализующий три спец. метода, которые будут вызываться интерпретатором автоматически. 

И не путайте имя метода __init__ с файлом __init__.py в пакетах модулей!!!

- Метод __init__ вызывается, когда создается новый объект экземпляра (аргумент self представляет новый объект ThirdClass).

- Метод __add__ вызывается, когда экземпляр ThirdClass участвует в операции +.

- Метод __str__ вызывается при выводе объекта (точнее когда он преобразуется в строку для вывода вызовом встр. ф-ции str или её эквивалентом внутри интерпретатора).

Новый подкласс также определяет метод mul, котоырй изменяет сам объект в памяти. Приступим к испытаниям:

class ThirdClass(SecondClass):					# Наследует SecondClass
	def __init__(self, value):					# Вызывается из ThirdClass(value)
		self.data = value
	def __add__(self, other):					# Для выражения "self + other"
		return ThirdClass(self.data + other)
	def __str__(self):							# Вызывается из print(self), str()
		return '[ThirdClass: %s]' % self.data
	def mul(self, other):						# Изменяет сам объект: обычный метод
		self.data *= other  

>>> a = ThirdClass("abc")					# Вызывается новый метод __init__
>>> a.display()								# Унаследованный метод
Current value = "abc"
>>> print(a)								# __str__ : возвращает строку
[ThirdClass: abc] 

>>> b = a + 'xyz'							# Новый __add__ : создается новый экземпляр
>>> b.display()
Current value = "abcxyz"
>>> print(b)								# __str__ : возвращает строку
[ThirdClass: abcxyz]

>>> a.mul(3)								# mul: изменяет сам экземпляр
>>> print(a)
[ThirdClass: abcabcabc]

Класс ThirdClass "наследует" класс SecondClass, поэтмоу ег оэкземпляры наследуют метод display от SecondClass. Но теперь, при создании экземпляра ThirdClass ему передается доп. аргумент (напр. "abc"). Это значение передается конструктору __init__ в аргументе value, где присв-ся атрибуту self.data. В итоге при создании экземпляра класса ThirdClass значение атрибута data устанавливается автоматически, благодаря чему отпадает необходимость вызывать метод setdata после создания экземпляра.

Далее, объекты ThirdClass могут участвовать в операциях + и в вызовах ф-ции print. При операции сложения (+) объект экземпляра слева от оператора передается методу __add__ в виде аргумента self, а значение справа - в виде аргумента other. 

Т.е. механизм перегрузки операторов отображает операторы выражений и другие встр. операции, выполняемые над экземплярами классов, на спец. имена методов в классе. Здесь у нас использ-е оператора "+" приводит к вызову метода __add__.

Как видим в метод __add__ передается два аргумента и поэтому, из выражения вида a + "xyz", объект экземпляра (self) а и аргумент (other) "xyz" складываются. И получается строка. Т.о. независимо от того что вернет метод __add__, это значение будет интерпретироваться как результат операции сложения.

Когда объект будет участвовать в вызове print(), интерпретатор вызывает метод __str__ объекта и передает ему сам объект - любая строка, которую вернет метод, будет расцениваться, как строковое представление объекта для вывода. Переопределив метод __str__, мы получим возможность использ. ф-цию print для отображения объектиов этого класса, вместо того, чтобы вызывать метод display.

Методы со псец. именами наследуются подклассами и экземплярами, как любые др. имена, которые присв-ся в инструкции class. Если методы отсутствуют в классе идет их поиск в суперклассах. Имена методов пепегрузки не явл-ся встроенными именами или зарезервированными словами - это обычные атрибуты, которые отыскиваются интерпретатором в случае появления объектов в различ. контекстах. Обычно интерпретатор вызывает их автоматич., но они могут вызываться и программным кодом - метод __init__, часто взывается вручную, чтобы запустить конструктор суперкласса.

Внимание! Посмотрите, что метод __add__ создает и возвращает НОВЫЙ объект экземпляра этого класса (вызывая ThirdClass, которому передается значение результата), а метод mul ИЗМЕНЯЕТ текущий объект экземпляра (выполняя присваивание атрибуту аргумента self). Т.к. перегрузка - это всего лишь механизм отображения выражений на методы, мы можем интерпретировать операторы в своих объектах классов, как нам угодно.


Когда следует использовать перегрузку операторов?

Конечно использовать или нет перегрузку мы определяем сами. Выбор зависит от того, насколько близко наш класс должен имитировать поведение встр. типов. Как мы знаем, если метод перегрузки оператора отсутствует в определении класса и не наследуется из суперкласса, соотв. операция не будет поддерживаться экземплярами этого класса - при попытке вып-ть такую операцию мы получим исключение (или действие по умолч.).

Вообще перегрузка операторов чаще использ. при реализации объектов с матем. природой - класс вектора или матрицы (напр. перегрузка сложения). Для упрощения классов можно не использ. перегрузку, а использ. явные методы.

С др. стороны мы можем использовать перегрузку операторов, чтобы иметь возможность передавать объекты, определяемые пользователем, в ф-цию, которая вып-ет операции, поддерживаемые встр. типами (списки или словари напр.). Наличие того же набора операторов в нашем классе обеспечит поддержку нашими объектами тех же самых интерфейсов и т.о. совместимость с используемой ф-цией. В гл. 29 мы ознакомимся с длоп. приемами перегрузки операторов в примерах.

Метод-конструктор __init__ присутствует почти во всех реалистичных классах. Он позволяет классам немедленно заполнять атрибуты вновь созданных экземпляров, поэтому конструктор полезно использ. практически во всех разновидностях наших классов. Фактически, даже при том, что в Питон атрибуты не оьновляются, мы сможем без труда определить какие атрибуты принадлежат экземплярам, просмотрев программ. код метода __init__.


Самый простой в мире класс на языке Python.

Приступим к детальному изучению синтаксиса инструкции class, и еще раз вспомним, что модель наследования, на которой основаны классы, очень проста - суть её заключается в организации поиска атрибутов в деревьях взаимосвязанных объектов. Фактически можно создавать вообще пустые классы. Создадим класс без атрибутов (объект пустого пространства имен):

>>> class rec: pass

- вот нам и пригодилась пустая операция pass.

Теперь можем начинать присоединять атрибуты выполняя присваивание за пределами класса:

>>> rec.name = 'Bob'
>>> rec.age = 40

Когда атрибуты созданы можно обращаться к ним с пом. обычного синтаксиса. Классы - это полноценные объекты, даже если нет ни одного экземпляра. Фактич. они лишь самостоятельные пространства имен, поэтмоу пока есть ссылка на класс, мы можем в любое время добавлять или изменять его атрибуты по своему усмотрению. Посмотрим, что будет если создать два экземпляра класса:

>>> y = rec()		# Экземпляры наследуют имена из класса
>>> x = rec()  

Они начинают свое существование как объекты абсолютно пустых пространств имен. Однако они наследуют из класса атрибуты:

>>> x.name, y.name
('Bob', 'Bob')

- Эти экземпляры получили атрибут name из класса, своих атрибутов у них пока нет.

Но если сейчас атрибуту экземпляра присвоить др. значение, то будет создан (изменен) атрибут именно этого объекта. Т.е. операция присваивания значеняи атрибуту действует только на тот объект, к которому она прмиеняется. Экземпляр х получает собственный атрибут name, а экземпляр y по-прежнему наследует name от класса:

>>> x.name = 'Sue'
>>> rec.name, x.name, y.name
('Bob', 'Sue', 'Bob')

Фактич. атрибуты объекта пространства имен обычно реализованы в виде словарей, и деревья наследования классов тоже всего лишь словари со ссылками на др. словари.

Напр. в большинстве объектов, созданных на базе классов, есть атрибут __dict__, который явл-ся словарем пространства имен. Пример - порядок следования имен и перечень внутренних имен вида __X__ может изменяться от версии к версии интерпретатора, но имена, которые использовали, присутствует везде:

>>> list(rec.__dict__.keys())
['age', '__dict__', 'name', '__weakref__', '__module__', '__doc__']

>>> list(x.__dict__.keys())
['name']

>>> list(y.__dict__.keys())
[]

Видим, что в классе есть атрибуты age и name, объект х имеет только свой атрибут name, а объект y по-прежнему пуст.

Каждый экземпляр имеет ссылку на свой наследумый класс, она наз-ся __class__ :

>>> x.__class__
<class '__main__.rec'>

Классы также имеют атрибут __bases__ , который представляет собой кортеж его суперклассов:

>>> rec.__bases__
(<class 'object'>,)

>>> ThirdClass.__bases__
(<class '__main__.SecondClass'>,)       

Главное, что нужно понимать - модель классов в Питон очень динамична. Классы и экземпляры - это всего лишь объекты пространств имен с атрибутами, создаваемыми на лету присваиванием.

Даже методы, которые созда-ся def, влож. в инструкцию class, могут создаваться независимо от объекта класса. Пример поределения простой ф-ции вне класса:

>>> def upperName(self):
	return self.name.upper()		# Аргумент self по-прежнему необходим

Это простая ф-ция и она может вызываться как обычная ф-ция, при услови, что объект, получаемый ею, имеет атрибут name (в данном случае имя аргумента self не имеет никакого особого смысла).

>>> upperName(x)		# Вызов как обычной ф-ции
'SUE' 

Однако, если эту ф-цию присвоить атрибуту нашего класса, она станет методом, вызываемым из любого экземпляра (и через имя самого класса, при условии, что ф-ции будет вручную передан экземпляр):

>>> rec.method = upperName

>>> x.method()					# Вызват ьметод для обработки х
'SUE'

>>> y.method()					# То же самое, но в self передается y 	
'BOB'

>>> rec.method(x)				# Можно вызвать через имя экземпляра или класса
'SUE'        

Обычно заполнение классов произв-ся внутри инструкции class, а атрибуты экземпляров создаются присваиванием значений атрибутам аргумента self в методах. Но это не явл-ся обязательным.


Классы и словари. стр. 723 

Мы познакомились с основными особенностями модели классов. В гл. 8 мы увидели как можно использ. словари для хранения записей свойств сущностей в программах. Оказывается классы тоже могут играть эту роль - хранить информацию, как словари, но при этом могут включать логику обработки этой информации в методах.

Пример со словарем:

>>> rec = {}
>>> rec['name'] = 'mel'
>>> rec['age'] = 40
>>> rec['job'] = 'trainer/writer'
>>> 
>>> print(rec['name'])
mel

А теперь пример записи на основе класса, с заменой ключей атрибутами:

>>> class rec: pass

>>> rec.name = 'mel'
>>> rec.age = 40
>>> rec.job = 'trainer/writer'
>>> 
>>> print(rec.age)
40

Создав пустой класс мы заполняем его, присваивая значения его атрибутам.

Этот прием работает, но для каждой отдельной записи придется писать новую инструкцию class. Все-таки более удобно будет создавать экземпляры класса для новых записей:

>>> class rec: pass

>>> pers1 = rec()
>>> pers1.name = 'mel'
>>> pers1.age = 40
>>> pers1.job = 'trainer'
>>> 
>>> pers2 = rec()
>>> pers2.name = 'dave'
>>> pers2.job = 'developer'
>>> 
>>> pers1.name, pers2.name
('mel', 'dave')

Два отдельных объекта экземпляра и, соответственно, два разных атрибута name. И даже кол-во атрибутов у экземпляров может быть разным (напр. age). Т.о. каждый экземпляр имеет своё пространство имен, т.е. свой словарь атрибутов.

Мы могли бы создать более полноценный класс:

>>> class Person:
	def __init__(self, name, job):
		self.name = name
		self.job = job
	def info(self):
		return (self.name, self.job)

>>> rec1 = Person('mel', 'trainer')
>>> rec2 = Person('vls', 'developer')
>>> 
>>> rec1.job, rec2.info()
('trainer', ('vls', 'developer'))

В этот класс мы добавили логику (методы) инициализации экземпляров на этапе создания и сбора атрибутов в кортеж. Конструктор налагает некоторые ограничения целостности, требуя значения для двух атрибутов - name и job. Методы класса и атрибуты экземпляра вместе образуют пакет, объединяющий данные и логику.

Классы - это гибкость и универсальность, недоступные встр. типам и функциям.











Глава 27. Более реалистичный пример.  стр. 728

В этой главе мы создадим множество классов, решающих конкретные задачи - сохранение и обработку инфомрации о людях. Те компоненты, которые мы называем экземпляры и классы, часто могут играть роль записей и программ в традиционном понимании.

Мы создадим два класса:   
 
- Person - класс, который предоставляет и обрабатывает информацию о людях;

- Manager - адаптированная версия (помним об ООП - адаптация кода) класса Person, модифицирующая унаследованное поведение.

Создадим экземпляры обоих классов и протестируем их. Увидим пример - мы сохраним наши экземпляры в хранилище, в объектно-ориентированной базе данных, обеспечивающей долговременное хранение. Этот шаблон даже можно будет применять для создания своей БД на Питон.

И самое главное - обучение. Мы будем продолжать осваивать основы, постепенно будем создавать классы, чтобы увидеть как из отдельных особенностей составляются законченные программы.

Всё это позволить нам изучить и рассмотреть все основные идеи модели ООП в Питон. И в итоге поймем, что система классов в Питоне, сводится к поиску атрибутов в дереве объектов и наличию спец. первого аргумента (self) в функциях классов.


Шаг 1: создание экземпляров. стр. 729

Начнем создание главного класса Person. Создадим новый файл где будем писать наш код. В Питон есть соглашение, согласно которому имена модулей начинаются со строчной буквы, а имена классов - с прописной. Так, в соотв. с соглаш. первому аргументу методов класса присв-ся имя self. Эти соглаш. не обьязательны, но общеприняты. Итак:

# Файл person.py (начало)

class Person:

Мы можем написать в одном файле много ф-цифй и классов, поэтому название person.py может потерять смысл, если позже мы добавим в него доп. компоненты, никак не связанные с его начальным предназначением.

Но пока будет предполагать, что всё, что нах-ся в этом файле так или иначе связано с классом Person. В идеале так и должно быть - ведь мы знаем, что модуль только выигрывает, когда он создан ради единственной, логически связанной цели.


Конструкторы.

Первое, что нам нужно сделать в классе Person - записать основные сведения о человеке, т.е. заполнить поля записи. В Питон они наз-ся атрибутами объекта и обычно создаются с пом. операций присваивания значений атрибутам аргумента self в методах класса. Обычно первые знач. атрибутам присв-ся в методе конструтора __init__, который вызывается автоматически каждый раз, когда созд-ся новый экземпляр. Добавим конструкцию к классу:

# Добавим инициализацию полей записи

class Person:
    def __init__(self, name, job, pay):	    # Конструктор принимает 3 аргумента		
	self.name = name		    # Заполняет поля при создании
	self.job = job			    # self - новый экземпляр класса
	self.pay = pay	

Итак, мы передаем конструктору (метод __init__) аргументы с данными, которые будут храниться экземпляром, и присваиваем их атрибутам аргумента self.

В терминах ООП аргумент self представляет вновь созданный экземпляр, а аргументы name, job и pay превращаются в информацию о состоянии - данные, сохраняемые в объекте для последующего использования.

Видим, что имена аргументов использ-ся дважды в операциях присваивания. Это может показаться избыточным, но это не так. Аргумент job, например, - это локальная переменная в области видимости ф-ции __init__, а self.job - это атрибут экземпляра, который явл-ся подразумеваемым контекстом вызова метода. Т.е. это две разные переменные, которые по совпадению имеют одно и то же имя.

Присваивая знач. локал. переменной job атрибуту self.job (с пом. операции self.job = job)  мы сохраняем его в экземпляре для последующего использования.

Метод __init__ обычен, кроме того, что он вызывается автоматич. при создании экземпляра и его первый аргумент имеет спец. значение. А так это самая обычная ф-ция, т.е. мы можем определять знач. аргументов по умолчанию, например.

Пример, сделаем job необязательным аргументом - знач. по умолч. будет None (т.е. безработный). И если job = None, то аргумент pay (зарплата) должен быть равен 0 (безработные не получают з\п). На самом деле мы вынуждены указать знач. по умолч. для pay, т.к. это требует синтаксис Питона - любые аргументы в заголовке ф-ции, следующие за первым аргументом, имеющим знач. по умолч., также должны иметь знач. по умолч.:

# Добавим значения по умолчанию для аргументов конструктора

class Person:
    def __init__(self, name, job=None, pay=0):
	self.name = name
	self.job = job
	self.pay = pay	

Теперь, при создании экземпляров, нам достаточно передать только аргумент name, остальные будут по умолч., если их не указать явно.


Тестирование в процессе разработки.

Как видим, программирование на Питон сводится к постепенному наращиванию возможностей - т.е. мы пишем код, тестируем его, потом добавляем еще, снова тестируем и так далее. Т.е. лучше тестировать понемногу, а не всё сразу.

Протестируем наш класс, создав пару экземпляров и просмотрев их атрибуты. Это можно сделать в интерактив. сеансе, но это утомительно, набирать кучу инструкций. Для полного тестирования лучше добавлять программ. код в конец файла, содержащего тестируемые объекты:

# Добавляем код для самопроверки
 
class Person:
    def __init__(self, name, job=None, pay=0):
	self.name = name
	self.job = job
	self.pay = pay

bob = Person('Bob Smith')
sue = Person('Sue Jones', job='dev', pay=100000)

print(bob.name, bob.pay)
print(sue.name, sue.pay) 

- Тестирование класса. Запустит __init__ автоматически, извлечет атрибуты, увидим, что атрибуты в объектах sue и bob отличаются.

Итак, объект bob получает знач. атрибутов по умолч., а для объекта sue  знач. всех атрибутов указываются явно. Причем мы используем для sue именованные аргументы, хотя могли бы и позиционные, однако именованные информативнее и их можно указывать в любом порядке.

Еще раз видим, что __init__ это обычная ф-ция, поддерживающая все особенности ф-ций.

Если запустить файл как сценарий, то увидим:

user@home:~$ python3.4 person.py
Bob Smith 0
Sue Jones 100000


Примечание!!! В gvim я поставил табуляцию = 4 (я так понимаю 1 таб = 4 пробела), ну это для удобства вида просто, а в терминале получил ошибку:

user@home:~$ python3.4 person.py
  File "person.py", line 5
    self.name = name
                   ^
TabError: inconsistent use of tabs and spaces in indentation

- переводится как "Смешение пробелов и табуляции в отступах.", пришлось переоткрывать файл заново и ставить обычные табы (они длинные и некрасиво выглядит, но зато работает).

Посмотрел непечатаемые знаки и вижу, что двойные Табы отображаются как Табы, а одинарный (где def) не отображается как Таб, видимо просто как 4 пробела, почему не знаю, нужно все-таки заняться изучением vim, а не только Питона. Нужно изучить этот вопрос, иначе будут некрасивые лестницы отступов в коде. Ну или пока так попробовать..

Каждый из объектов bob и sue явл-ся независимыми записями с собств. информацией. Технич. они явл-ся пространствами имен - как и все экземпляры классов, каждый из них обладает собств. копией информации о состоянии. Т.о. как и встр. типы, классы играют роль своеобразной фабрики объектов.


Двоякое использование программного кода. стр. 732

Тесты работают без проблем, но есть одно но - инструкции print будут выполняться и при запуске файла как сценария и при импорте как модуля. Это не очень хорошо, т.к. клиентской проге не зачем знать как выглядят наши тесты и вообще тесты не нужны.

Конечно можно тесты убрать в отдельный файл, однако удобнее когда тесты нах-ся в том же файле, что и тестируемый код (может это соглашения Питона, в Руби мы писали тесты отдельным файлом, напр., надеюсь дальше будет понятно, или потом на практике). Но лучше оформим тесты, чтобы они выполнялись когда файл запускается как сценарий, а не при импорте. А поможет нам проверка атрибута __name__ модуля:

# Предусмотрим возможность импорта файла и запуска его,
# как самостоятельный сценарий

class Person:
	def __init__(self, name, job=None, pay=0):
		self.name = name
		self.job = job
		self.pay = pay

if __name__ == '__main__':				# Только когда файл запускается как сценарий
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob.name, bob.pay)
	print(sue.name, sue.pay)

Теперь проверим работает ли тестирование тогда когда нам нужно:

C:\Python34>person.py
Bob Smith 0
Sue Jones 100000

>>> import person				# Всё работает как надо, при импорте тестов нет
>>> 

Замечание. Я снова наступаю на те же грабли, что и всегда. 

После импорта модуля с классом Person, я попытался создать экземпляр класса и потерпел неудачу:

>>> import person
>>> bob = Person('Bob')
...
NameError: name 'Person' is not defined

Интерпретатор выдавал мне сообщение о том, что имя Person не существует, хотя в атрибутах модуля он был:

>>> list(person.__dict__.keys())
['__spec__', 'Person', '__cached__', '__loader__', '__package__', '__builtins__', '__doc__', '__file__', '__name__']

В итоге, в результате долгих поисков проблема была определена - оказывается я напрасно вызывал таким образом класс, потому что его НУЖНО было вызывать вот так:

>>> import person
>>> bob = person.Person('Bob Dilan')
>>> bob.name
'Bob Dilan'

А если мы хотим вызывать так как делали в прошлых примерах, когда классы мы создавали ПРЯМО В оболочке, то нужно импортировать класс Person вот ТАКИМ способом, через from:

>>> from person import Person
>>> bob = Person('Bob')
>>> bob.name
'Bob'

Очень ужасная забывчивость и невнимательность у меня, нужно с ней обязательно бороться, с такими ошибками в программисты не берут.


Шаг 2: добавление методов, определяющих поведение.

Итак, сейчас наш класс играет роль фабрики записей - создает записи и заполняет их поля (атрибуты экземпляров). Теперь мы уже можем применять различ. операции к этим записям.

Большую часть свой работы классы выполняют за счет внедрения и обработки данных базовых типов, таких как списки и строки. Т.е. если мы знаем как работать в базовыми типами, то и с классами разберемся - классы явл-ся лишь небольшой структурной надстрокой.

Напр. поле name в наших объектах явл-ся обычной строкой, поэтому мы можем извлекать фамилии разбивая значение по пробелам и индексированием, т.е. операциями над базовыми типами:

>>> name = 'Bob Smith'			# Простая строка
>>> name.split()				# Извлечение фамилии
['Bob', 'Smith']
>>> name.split()[-1]			# Или и [1] если имя всегда состоит из двух компонентов
'Smith'     

Также можем работать и с зарплатой, изменяя её состояние с пом. присваивания:

>>> pay = 100000			# Простая переменная за пределами класса
>>> pay *= 1.10				# Поднимем з\п на 10% или pay = pay * 1.10
>>> print(pay)				
110000.00000000001

Чтобы применить эти операции к объектам класса Person, просто подставьте имена bob.name и sue.name на место name и pay, т.е. операции будут проводиться над атрибутами класса:

# Обработка встроенных типов: строки, изменяемость

class Person:
	def __init__(self, name, job=None, pay=0):
		self.name = name
		self.job = job
		self.pay = pay

if __name__ == '__main__':
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob.name, bob.pay)
	print(sue.name, sue.pay)
	print(bob.name.split()[-1])			# Извлечь фамилию
	sue.pay *= 1.10						# Повысить з\п
	print(sue.pay) 

- в предпоследней строке мы изменяем значение атрибута pay у объекта sue. В некотором смысле объект sue явл-ся изменяемым - он допускает непосредственное изменение свой информации о состоянии, подобно списку при вызове метода append:

C:\Python34>person.py
Bob Smith 0
Sue Jones 100000
Smith
110000.00000000001

Опытный программист подскажет нам, что такой подход не желателен на практике. Выполнение операций за пределами класса, как у нас, может привести к проблемам при сопровождении.

Представим, что в разных местах программыесть одинаковые фрагменты, извлекающие фамилию. Если нам нужно будет изменить их, то придется искать и изменять ВСЕ такие фрагменты. То же самое относится и к операцией с зарплатой. Один тольк опоиск всех фрагментов может быть проблематичным.


Методы реализации. 

Приступаем к реализации концепции под названием - инкапсуляция. Её идея в том, чтобы спрятать логику операций за интерфейсами, и т.о. каждая операция будет иметь единственную реализацию в программе. Если в будущем нам нужно будет внести изменения в логику, нам нужно будет модифицировать код всего лишь в одном месте, а не по всей программе.

Еще плюс - можно будет изменять реализацию операции как угодно (рефакторинг, оптимизация), не рискуя нарушить работу кода, и опять же - всего лишь в одном месте, а не по всей программе.

В терминах Питона это означает, что мы должны реализовать операции над объектами в виде методов класса, а не разбрасывать их по всей программе. 

Простыми словами опишем - напр. нам нужно переключить скорость передачи в авто, т.е. провести операцию "переключение скорости", для этого у нас есть метод "перемещение рычага КПП" и нас совсем не интересует, что будет делать рычаг КПП внутри самой коробки передач, движения шестерен внутри, валдов и прочее и прочее. У фирмы БМВ масса автомобилей различных моделей и размеров, но концепция операция-метод-реализация остается, для всего многообразия автомобилей, одинакова. Вот это простое описание инкапсуляции.

Вернемся к программированию. Сосредоточив код реализации в одном месте мы устраняем избыточность и упрощаем его сопровождение, что явл-ся одной из сильных сторон классов. Оформление операций в виде методов позволяет применять их к любым экземплярам класса, а не только к тем, которые явно задействованы в обработке.

К практике. Мы переместим реализацию двух операций из программы в методы класса, добившись инкапсуляции и изменим код самопроверки:

# Добавлены методы, инкапсулирующие операции 

class Person:
	def __init__(self, name, job=None, pay=0):
		self.name = name
		self.job = job
		self.pay = pay
	def lastName(self):						# Два метода, реализующие поведение экземпляров
		return self.name.split()[-1]		# self - подразумеваемый экземпляр
	def giveRaise(self, percent):
		self.pay = int(self.pay * (1 + percent))	# если "прибавка к з\п" изменится
													# то изменять нам только один метод 

if __name__ == '__main__':
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob.name, bob.pay)
	print(sue.name, sue.pay)
	print(bob.lastName(), sue.lastName())	# Вместо жестко определенных операций
	sue.giveRaise(.10)						# используем методы				
	print(sue.pay)

- give - давать; Raise - повышение, подъем; percent - процент. Т.е. метод giveRaise дает нам з\п служащего с надбавкой, если она есть (у Sue мы её сделали 10%).

И еще была синтаксическая ошибка, в тестах написал метод lastName с большой буквы "sue.LastName" - внимательнее будьте!

Как мы знаем методы - это обычные ф-ции, которые присоед-ся к классам и предназначены для обработки экземпляров этих классов. Экземпляр - это подразумеваемый контекст вызова метода, который автоматич. передается в виде аргумента self.

С методом giveRaise мы уже разобрались, он выполняет операцию над объектом self (по увеличению з\п, если конечно передавать положительное число, не отрицательное и не 0).

Метод lastName возвращает результат, это фактич. вызов ф-ции - вычисляет значение, которое затем может использ-ся вызывающей программой (у нас рез-т просто выводится для обзора).

Рез-ты сценария будут те же, что и прежде - т.к. мы всего лишь реструктурировали программный код, не изменяя его поведения:

C:\Python34>person.py
Bob Smith 0
Sue Jones 100000
Smith Jones
110000

Обсудим несколько моментов нашего нового кода:

- Первое. Обратим внимание, что поле pay (зарплата) в объекте sue получает целочисленное значение после его увеличения - внутри мы преобразовываем рез-т в целое число с пом. ф-ции int. Конечно нужно самим определять как лучше - int или float, нужно ли округлять или нет.
К тому же мы могли округлить до центов с пом. ф-ции round(N, 2), использовать тип decimal или хранить в виде веществ. чисел и отображать с пом. стркои формата %.2f или {0:.2f}. Еще один способ - можно импортировать ф-цию money и отображать сумму з\п с запятыми, центами и знаком доллара (см. модуль formats.py в гл. 24).

- Второе. Мы добавили вывод фамилии из объекта sue - т.к. теперь логика получения фамилии инкапсулирована в методе и можем применить её к любому экземпляру класса. Интерпретатор сам сообщает методу, какой экземпляр должен обрабатываться, автоматич. передавая его в первом аргументе (self).

Одно слабое место у нас есть, - это нулевая з\п в объекте bob, к нему мы не можем применть метод giveRaise, т.к. в итоге получим тот же 0, а не увеличение з\п.

Ну и как говорилось мной выше - у нас просто подразумевается, что в percent передаются нормальные цифры процентов, но в этом месте все-таки желательна бы проверка значения (мало ли, отрицательное число будет или вообще 1000%). В одной из глав мы разберем способы решения этой проблемы, когда будем изучать декораторы функций и исследовать инструкцию assert - альтернативы, позволяющие реализовать автоматич. проверку в ходе разработки.


Шаг 3: перегрузка операторов. стр. 737

Итак, у нас есть класс, который может инициализировать экземпляры и обладает методами.

Но есть моменты по тестам - нам приходится вручную извлекать и выводить значения отдельных атрибутов (bob.ame, sue.name). Хотелось бы , чтобы вывод экземпляра целиком показывал нам нужную информацию. 

Но формат вывода объектов экземпляров по умолчанию, выглядит неудобно - выводит имя класса и его адрес памяти (зачем он нам?). Чтобы это увидеть измените последнюю строку на вызов print(sue):

C:\Python34>person.py
Bob Smith 0
Sue Jones 100000
Smith Jones
<__main__.Person object at 0x0075F7B0>


Реализация отображения.

В помощь нам придет перегрузка операторов - добавит ьв класс метод, который перехватывает и выполняет встр. операцию, когда она применяется к экземплярам класса.

Нам поможет популярный метод (вторйо после __init__) - метод __str__ (см. пред. главу). Метод __str__ вызывается всякий раз, когда экземпляр преобраз-ся в строку для вывода. Т.о. фактич. всё, что мы получаем при выводе объекта, явл-ся возвращаемым значением метода __str__ этого объекта, который может быть определен в классе объекта или унаследован от суперкласса (методы с подчеркиваниями наследуются так же как любые другие).

Метод __str__ перехватывает определнную операцию и вып-ет специфическую реализацию поведения объекта, участвующего в операции. Добавим его в наш класс:

# Добавлен метод __str__, реализующий вывод объектов 

class Person:
	def __init__(self, name, job=None, pay=0):
		self.name = name
		self.job = job
		self.pay = pay
	def lastName(self):
		return self.name.split()[-1]
	def giveRaise(self, percent):
		self.pay = int(self.pay * (1 + percent))
	def __str__(self):										# Новый спец. метод
		return '[Person: %s, %s]' % (self.name, self.pay)	# Строка для вывода

if __name__ == '__main__':
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob)
	print(sue)
	print(bob.lastName(), sue.lastName())
	sue.giveRaise(.10)
	print(sue)

В методе __str__ в строке вывода мы применили оператор форматирования % - для реализации нужных действий классы могут использ-ть встр. типы объектов и операции. Т.е. запомните - всё, что мы знаем о встр. типах данных и ф-циях, может прим-ся при создании классов. По сути классы лишь добавляют структурный уровень, организующий ф-ции и данные в виде единого объекта и имеющий возможность расширения.

Мы также изменили тесты - теперь выводятся объекты целиком, а не отдельные объекты, смотрим:

C:\Python34>person.py
[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]

Далее мы узнаем, что родственный метод перегрузки __repr__  возвращает представление объекта в виде программ. кода. И иногда классы переопределяют оба метода: __str__ - для удобочитаемого вывода, а __repr__ - для вывода доп. сведений об объектах (для разработчика напр.). Т.к. операция вывода автоматич. вызывает метод __str__, а интерактив. оболочка выводит рез-ты с пом. __repr__, подходящие варианты вывода могут предоставляться обеим категориям клиентов.


Шаг 4: адаптация поведения с помощью подклассов. стр. 739

Сейчас у нас есть большинство механизмов ООП Питона: класс создает экземпляры, есть методы обработки и даже операторы перегрузки. Наш класс фактич. объединяет логику и данные в единый самостоятельный программ. компонент, упрощая поиск и модификацию программ. кода. Также имеется инкапсуляция.

Единственно чего мы еще не делали, это - адаптация программного кода за счет наследования. Конечно наши экземпляры наследуют методы своего класса. Но для полноты обучения принципам ООП нам нужно определить отношения типа суперкласс/подкласс. Ведь основная идея ООП - это возможность адаптации уже имеющегося и действующего программ. кода.


Создание подклассов.

Адаптируем наш класс Person расширив его подклассом Manager, в котором мы заместим унаследованный метод giveRaise. Сначала определим класс:

class Manager(Person):			# Определили подкласс класса Person

Класс Manager наследует и может адаптировать суперкласс Person. В частности подкласс Manager буде треализовать свой спосо бувеличения з\п.

Допустим наш менеджер получает не только прибавку (percent), но и доп. премию, которая по умолч. будет 10%. Напр. если прибавка будет 10%, то увеличение у менеджера будет уже 20%. Наш новый метод замещает и адаптирует оригинальную реализацию в классе Person:

class Manager(Person):
	def giveRaise(self, percent, bonus=.10):
	

Расширение методов: неправильный способ.

Неправильный способ заключается в простом копировании реализации метода giveRaise из класса Person и его изменении в классе Manager:

class Manager(Person):
	def giveRaise(self, percent, bonus=.10):
		self.pay = int(self.pay * (1 + percent + bonus))
		
Конечно этот вариант будет работать. Проблема в том, что всякий раз когда вы копируете программ код, вы фактич. усложняете его сопровождение в будущем. Если в будущем у нас появятся изменения в суперклассе в этом методе, то нам придется делать их в двух местах. Это маленький пример, но наглядно демонстрирует эту проблему.


Расширение методов: правильный способ.

На самом деле нам нужно лишь дополнить оригинальный метод giveRaise, а не заменить его полностью. Правильный способ состоит в том, чтобы вызвать оригинальную версию с измененными аргументами:

class Manager(Person):
	def giveRaise(self, percent, bonus=.10):
		Person.giveRaise(self, percent + bonus)
		
Данная реализация учитывает то обстоятельство, что методы класса могут вызываться либо обращением к экземпляру (обычный способ, когда интерпретатор автоматич. передает экземпляр в аргументе self), либо обращением к классу (менее распространенный метод, когда экземпляр передается вручную). Вспомним, что вызов метода:

instance.method(args...)

автоматич. транслируется интерпретатором в эквивалентную форму:

class.method(instance, args...)

где класс, содержащий вызываемый метод, определяется в соотв. с правилами поиска в дереве наследования, которые действуют и для методов. 

В своих сценариях вы можете использовать любую форму вызова, но не забывайте об их различиях - при обращении непосредственно к классу вы должны передавать объект экземпляра вручную. Метод всегда должен получать объект экземпляра тем или иным способом, однако интерпретатор вып-ет автоматич. передачу только при вызове метода через обращение к экземпляру. 

При вызове метода через обращение к классу вы сами должны передавать экземпляр в аргументе self - внутри метода, такого как giveRaise, аргумент self уже содержит подразумеваемый объект вызова, т.е. сам экземпляр.

Вызов через обращение к классу начинает поиск от класса и выше по дереву классов. Именно поэтому в классе Manager мы должны вызывать оригинальный метод через класс Person.giveRaise(), т.к. если бы мы вызывали его через self.giveRaise(), то у нас появилась бы рекурсия.

На первый взгляд правильная и неправильная версии мало отличаются, но это отличие может иметь огромное значения для сопровождения в будущем - в нашем случае у нас основная логика работы метода по-прежнему остается в одном месте (представьте сотни таких "двойных" методов в проекте, замучаетесь изменять в случае чего).

Приводим полное содержимое файла модуля после последнего шага:

# Добавлен подкласс, адаптирующий поведение суперкласса

class Person:
	def __init__(self, name, job=None, pay=0):
		self.name = name
		self.job = job
		self.pay = pay
	def lastName(self):
		return self.name.split()[-1]
	def giveRaise(self, percent):
		self.pay = int(self.pay * (1 + percent))
	def __str__(self):
		return '[Person: %s, %s]' % (self.name, self.pay)

class Manager(Person):
	def giveRaise(self, percent, bonus=.10):
		Person.giveRaise(self, percent + bonus)	
		
if __name__ == '__main__':
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob)
	print(sue)
	print(bob.lastName(), sue.lastName())
	sue.giveRaise(.10)
	print(sue)
	tom = Manager('Tom Jones', 'mgr', 50000)	# Экземпляр Manager: __init__
	tom.giveRaise(.10)							# Вызов адаптированной версии
	print(tom.lastName())						# Вызов унаследованного метода 
	print(tom)									# Вызов унаследованного __str__    
	
- мы добавили новый код проверки для наших новых изменений.

[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
Jones
[Person: Tom Jones, 60000]		# Видим, что з\п увеличилась не на 10%, как у sue, а на 20%


Полиморфизм в действии. 

Добавим еще код для еще более полного действования наследования:

if __name__ == '__main__':
	...
	print('--All three--')
	for object in (bob, sue, tom):		# Обработка объектов обобщенным способом
		object.giveRaise(.10)			# Вызовет метод giveRaise этого объекта
		print(object)      				# Вызовет общий метод __str__

Результаты работы:

[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
Jones
[Person: Tom Jones, 60000]
--All three--
[Person: Bob Smith, 0]
[Person: Sue Jones, 121000]
[Person: Tom Jones, 72000] 


В добавленном коде переменная object может ссылаться либо на экземпляр класса Person, либо класса Manager, а интерпретатор автоматич. вызовет соотв-щий метод giveRaise - для bob, sue оригинальнй метод из класса Person, а для объекта tom - адаптированная версия из класса Manager.

Этот пример демонстрирует нам понятие полиморфизма в Питон, - действие операции giveRaise зависит от того, к какому объекту она применяется. Именно благодаря полиморфизму, в этом примере sue получает прибавку 10%, а tom - 20%.

С др. стороны, операция вывода вызывает одну и ту же версию метода __str__ для всех трех объектов, потому что в программ. коде присутствует только одна его версия - в классе Person.


Наследование, адаптация и расширение.

Классы могут обладать еще большей гибкостью - могут наследовать, адаптировать, расширять реализацию суперклассов. Напр. в нашем подклассе Manager могли бы быть уникальные методы, отсутствующие в классе Person. Пример, появился новый метод someThingElse:

class Person:
	def lastName(self): ...
	def giveRaise(self, ...): ...
	def __str__(self): ...

class Manager(Person):					# Наследование
	def giveRaise(self, ...): ...		# Адаптация
	def someThingElse(self, ...)		# Расширение
	
tom = Manager()	
tom.lastName()						# Унаследованный метод	
tom.giveRaise()						# Адаптированная версия
tom.someThingElse()					# Дополнительный метод	 	
print(tom)							# Унаследованный метод перегрузки

Доп. методы, такие как метод someThingElse? расширяют возможности существующего ПО и доступны только для объектов класса Manager. В наших примерах мы такие методы не создавали, но назначение и использование их в общем-то понятно.


ООП: основная идея.

Наш небольшой код иллюстрирует основное преимущество ООП: используя объектно-ориентированный стиль, мы адаптируем имеющийся программный код, а не копируем и не изменяем его. В целом применение ООП способно существенно сократить время разработки, по сравнению с др. подходами.

Так в наших примерах мы могли бы реализовать отдельную операцию giveRaise, не прибегая к созданию подкласса, но ни один др. способ не позволил бы нам получить такой же оптимальный код:

- Мы могли бы создать новый, независимый класс Manager, но при этом пришлось бы реализовывать все методы, имеющиеся в классе Person и действующие одинаково в классе Manager.

- Мы могли бы просто изменить класс Person, чтобы удовлетворить требованиям, предъявляемым к методу giveRaise класса Manager, но при этом нарушилась бы корректная работа, там где нужен оригинальный метод класса Person.

- Мы могли бы скопировать класс Person целиком, присвоить копии имя Manager и изменить метод giveRaise, но от этого наш код стал бы избыточным, и это усложнило бы нам задачу - вероятные изменения в будущем в классе Person, не будут отражаться в классе Manager и придется вручную переносить изменения.

Адаптируемые иерархии, на основе классов, обеспечивают оптимальное решение для ПО, которое предполагается развивать в дальнейшем. Адаптация и расширение имеющегося кода с применением ООП - сильный союзник программиста.


Шаг 5: адаптация конструкторов.  стр. 745

Обратим внимание - кажется бессмысленно указывать значение 'mgr' (менеджер) в аргументе job при создании объекта класса Manager: эта должность уже подразумевается названием класса. Нужно заполнять этот атрибут автоматически.

Для этого адаптируем логику работы конструктора в классе Manager так, чтобы он автоматич. подставлял название должности. Т.е. нам нужно переопределить метод __init__ в классе Manаger, чтобы 'mgr' ставилось автоматич. Как и в случае с giveRaise, нам нужно вызывать оригинальный метод __init__ из класса Person.

Приводим новый вид сценария:

# Добавлен адаптированный конструктор в подкласс

class Person:
	def __init__(self, name, job=None, pay=0):
		self.name = name
		self.job = job
		self.pay = pay
	def lastName(self):
		return self.name.split()[-1]
	def giveRaise(self, percent):
		self.pay = int(self.pay * (1 + percent))
	def __str__(self):
		return '[Person: %s, %s]' % (self.name, self.pay)

class Manager(Person):
	
	def __init__(self, name, pay):					# Переопределенный конструктор
		Person.__init__(self, name, 'mgr', pay)		# Вызов оригинального конструктора
													# со значением 'mgr' в аргументе job
	def giveRaise(self, percent, bonus=.10):
		Person.giveRaise(self, percent + bonus)	
		
if __name__ == '__main__':
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob)
	print(sue)
	print(bob.lastName(), sue.lastName())
	sue.giveRaise(.10)
	print(sue)
	tom = Manager('Tom Jones', 50000)			# Указывать должность не требуется:
	tom.giveRaise(.10)							# Подразумевается/устанавливается
	print(tom.lastName())						# классом 
	print(tom)    
   
Здесь мы используем тот же прием расширения конструктора __init__, который использовали для метода giveRaise. Вызываем метод __init__ класса Person, чтобы задействовать его логику и экземпляры класса Manager получили атрибуты.

Такая форма вызова конструктора суперкласса из конструктора подкласса широко использ-ся в программировании на Питон. Положительная сторона такого ступенчатого вызова методов в том, что мы можем явно передать конструктору суперкласса только необходимые аргументы или вообще не вызывать его: возможность отказа от вызова конструктора суперкласса позволяет полностью заместить логику его работы, а не дополнять её.

Результаты работы сценария не изменились - т.к. мы не изменили логику его работы, лишь реструктурировали код, чтобы избавиться от некоторой избыточности:

[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
Jones
[Person: Tom Jones, 60000] 


ООП проще чем может показаться.

Наши небольшие классы задействуют почти все наиболее важные концепции механизма ООП в Питон:

- Создание экземпляров - заполнение атрибутов экземпляров.

- Методы, реализующие поведение - инкапсуляция логики в методах класса.

- Перегрузка операторов - реализация поддержки встроенных операций, таких как вывод.

- Адаптация поведения - переопределение специализированных версий методов в подклассах.

- Адаптация конструкторов - добавление логики инициализации, в дополнение к логике суперкласса.

Большинство этих механизмов основаны на: поиске атрибутов в дереве наследования, спец. аргументе self методов и автоматич. выборе нужного метода перегрузки операторов.

Также мы уменьшили избыточность кода и т.о. повысили простоту изменений в будущем - оформили логику работы классов в виде методов и предусмотрели вызовы методов суперкласса.

Конечно есть ряд доп. концепций классов, такие как декораторы и метаклассы. Но что касается основ, то наши кдассы используют все базовые механизмы ООП.


Другие способы комбинирования классов.

Отчасти, объединение классов в крупных программах это искусство. Поэтому помимо наследования программисты использ. др. способы комбинирования классов. Напр. часто использ. прием вложения объектов друг в друга для создания составных объектов - к примеру мы могли бы использ. это для создания класса Manager, вложив в него объект класса Person, а не наследуя этот класс.

След. альтернатив. реализация использует метод __getattr__ перегрузки операторов, чтобы перехватывать обращения к несуществующим атрибутам и делегировать эти обращения вложенноу объекту, вызовом встр. ф-ции getattr. Здесь также имеется адаптированная версия метода giveRaise, которая изменяет значение аргумента, передаваемого методу вложенного объекта.

В итоге наш класс Manager превращается в контроллер, который вызывае тметоды вложенного объекта, а не методы суперкласса:

# Альтернативная версия класса Manager 

class Person:
	... то же самое ...

class Manager(Person):
	def __init__(self, name, pay):
		self.person = Person(name, 'mgr', pay)		# Влож. объект Person
		
	def giveRaise(self, percent, bonus=.10):		# Перехватывает и делегирует
		self.person.giveRaise(percent + bonus)	
		
	def __getattr__(self, attr):					# Делегирует обращения 
		return getattr(self.person, attr)			# ко всем остальным атрибутам
		
	def __str__(self):
		return str(self.person)						# Требуется перегрузка (в 3.0)
		
if __name__ == '__main__':
	... то же самое ...

Этот вариант класса Manager представляет известный шаблон проектирования под названием - делегирование, - составная структура служит оберткой вокруг вложенного объекта, управляет им и перенаправляет ему вызовы методов.

В нашем случае, для конкретно нашего класса, этот прием конечно же не так хорош как механизм наследования. Реализация сложнее и запутаннее, мы привели этот пример лишь для изученяи альтернативы. Конечно делегирование может быть хорошо для других случаев, но не для наших классов.

Использование вложенных объектов будет успешно когда круг взаимодействий контейнера с влож. объектами уже, чем предполагает прием адаптации. Напр. уровень контроллера альтернативного класса Manager может пригодиться для отслеживания и проверки вызовов методов других объектов.

Для объединения других объектов в виде множества можно было бы использовать гипотетический агрегатный класс Department, как будет показано ниже. Для исследования этого класса можно добавить его в конец файла person.py:

if __name__ == '__main__':
	bob = Person('Bob Smith')
	sue = Person('Sue Jones', job='dev', pay=100000)
	print(bob)
	print(sue)
	tom = Manager('Tom Jones', 50000)	
	print(tom)
	print('--Department--')
	
class Department:
	def __init__(self, *args):
		self.members = list(args)
	def addMember(self, person):
		self.members.append(person)
	def giveRaises(self, percent):
		for person in self.members:
			person.giveRaise(percent)
	def showAll(self):
		for person in self.members:
			print(person)
			
development = Department(bob, sue)
development.addMember(tom)
development.giveRaises(.10)
development.showAll()      

Результаты вывода:

[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
[Person: Tom Jones, 50000]
--Department--
[Person: Bob Smith, 0]
[Person: Sue Jones, 110000]
[Person: Tom Jones, 60000]

Замечание. Здесь у нас в выводе везде класс Person, хотя у объекта tom должно быть Manager, сначала хотел реализовать свой метод для класса Manager, но не смог переделать его так же элегантно как метод giveRaise. Пробовал передавать атрибут имени класса объекта, но он выводится в неудобной форме, на этом я оставил попытки и не стал реализовывать свой метод __str__ для класса Manager. 

В этом примере использ-ся оба приема, наследование и встраивание - объекты класса Department явл-ся составными объектами, которые управляют другими встр. объектами, но сами встр. объекты классов person и Manager используют механизм наследования для адаптации своего поведения.

Еще один пример - графич. интерфейс пользователя, в его реализации  для адаптации поведения и внеш. вида кнопок и меток может использ-ся механизм наследования, а для создания пакетов встр. виджетов, таких как формы ввода, калькуляторы, текстовые редакторы, - прием встраивания.


Примечание. Перехват обращений к встроенным атрибутам в версии 3.0  стр. 749

 







 



 
         


