
Часть 5. Классы и ООП.  стр. 693


Глава 25. ООП: общая картина.  стр. 695

Весь написанный нами код до этого, был основан  на объектах (object-based) - в сценариях мы передавали объекты, использовали в выражениях, вызывали их методы и т.д. Но чтобы наш код стал по-настоящему объектно-ориентированным (ОО), наши объекты должны участвовать в иерархии наследования.

Мы присутпаем к изучению классов - программных компонентов, используемых для реализации новых типов объектов, поддерживающих наследование. Классы - основные инструменты ООП в Питон. ООП представляет подход к программированию, при котором мы разлагаем код программ на составляющие, чтобы уменьшить его избыточность, и пишем новые программы, адаптируя имеющийся код, а не изменяя его.

Классы создаются с пом. инструкции class. Увидим, чт ообъекты, определяемые с пом. классов, очень напоминают встр. типы знакомые нам. На самом деле классы лишь применяют и дополняют понятия, которые мы уже рассмотрели. Проще - они представляют собой пакеты ф-ций, которые в основном использ. и обрабатывают объекты встр. типов. Основное назнач. классов в том, чтобы создавать и манипулировать новыми объектами, кроме того они поддерживают механизм наследования - иной способ адапатции кода и его повторного использ., чем мы узнали до этого.

ООП в Питно явл-ся необязательным и на первых порах нам можно не использ. классы. Они больше нужны для стратегического программирования (долгосрочная разработка). Но тем неменее классы полезный и мощный инструмент.


Зачем нужны классы?

Помните - "программы выполняют некоторые действия над чем-то"? Так вот классы - это лишь способ определить новое "что-то", они явл-ся отражением реальных объектов в мире программ. Напр. хотим сделать машину для готовки пиццы. Если реализовать её на основе классов, то мы могли бы смоделировать более близкое к реальности строение машины взаимосвязь между её механизмами. Здесь нам полезны два аспекта ООП:

- Наследование. Машина по изготовлению пиццы - это машина и должна иметь характеристики машин как таковых. В терминах ООП это наз-ся "наследованием" свойств более общей категории машин. Эти свойства нужно реализовать всего один раз и их можн обудет использ. для создания любых типов машин нужных нам.

- Композиция. Машина для пиццы состоит из множества компонентов, которые работают как единое целое. Напр. у нас будут манипуляторы (раскатывать тесто напр.), двигатели (надо же чем-то двигать машину) и т.д. На языке ООП наша машина - это пример композиции; она содержит др. объекты, которые активизируются для выполнения определенных действий. Каждый компонент можно оформить как класс.

Общие идеи ООП, как наследование и композиция, применимы к любым приложениям, которые можно разложить на объекты. Напр. интерфейс - набор визуальных элементов управления, кнопок, меток и т.д., которые рисуются на экране в момент, когда выполняется рисование их контейнеров (композиция). Также мы можем создать свои элементы - кнопки с уникальными шрифтами, новые цвета у элементов, вообщем свои специализированные версии общих эелементов (наследование).

Классы - это программ. компоненты Питона, как ф-ции и модули: они представляют собой еще один способ упаковки кода и данных. У классов есть свое пространство имен. Но есть и три важных отличия:

- Множество экземпляров. Классы это как-бы фабрики по созданию объектов. Каждый раз когда вызывается класс, создается объект со своим пространством имен. Объект, созданный из класса, имеет доступ к атрибутам класса и получает своё пространство имен для своих собственных данных, отличных от др. объектов. 

- Адаптация через наследование. Наследование - мы можем расширять возможности класса, переопределяя его атрибуты за пределами самого класса. Классы могут создавать иерархии пространства имен, которые определяют имена для использ-ия объектами, созданными из классов в иерархии.

Перегрузка операторов. Со спец. протоколом оформления методов, классы могут определять объекты, над которыми можно делать операции, которые мы знаем по встр. типам (напр. извлечение среза, конкатенация, индексация и т.д.). Питон предоставляет спец. обработчики для классов, для перехвата и реализации любой встр. операции.



ООП с высоты 30000 футов.  стр. 697

Поиск унаследованных атрибутов.

ООП в Питон проще в изучении и использ-ии чем в С++ или Java. Фактически ООП в Питон сводится к выражению:

object.attribute

Оно нам знакомо и мы его много использовали. Однако когда это выражение применяется к объекту, полученному с пом. class, интерпретатор начинает поиск - поиск в дереве связанных объектов, который заканчивается, как только будет встречено первое появление атрибута attribute. Когда в деле классы это выражение можно перевести так:

- Найти первое вхождение атрибута attribute, просмотрев объект object, а потом все классы в дереве наследования выше него, снизу вверх и слева направо.

Эта процедура поиска также еще наз-ся поиском в дереве наследования. Объекты ниже наследуют атрибуты у объектов выше по дереву.

Т.е. с пом. программ. кода мы действительно создаем деервья связанных объектов и интерпретатор поднимается по этому дереву вверх в поисках атрибутов.

Рисунок 25.1 Дерево классов.  стр. 698 

На рисунке дерево из 5 объектов, помеченных именами переменных. Два эземпляра внизу (I1, I2), класс выше их (С1) и два суперкласса в самом верху (С2 и С3), т.е. два объекта экземпляров и три объекта классов. Эти объекты явл-ся пространствами имен (пакетами переменных), а наследование означает просто поиск снизу вверх, с целью найти самое нижнее вхождение атрибута с нужным именем. Программ. код задает структуру таких деревьев.

Итак, каждый из этих объектов обладает набором атрибутов, а именно - I1.name; I2.name; C1.x, C1.y; C2.x, C2.z; C3.w, C3.z. Заметим, что классы и экземпляры порождаются от двух разных типов объектов:

- Классы. Играют роль фабрик экземпляров. Их атрибуты обеспечивают поведение - данные и функции - т.е. наследуются всеми экземплярами, созданными от них (напр. ф-ция, считающая зарплату, исходя из часового тарифа).

- Экземпляры. Представляют конкретные элементы программы. Их атрибуты хранят данные, которые могут отличаться в конкретных объектах (напр. номер карточки соц. страхования).

Т.о., по дереву, экземпляры наследуют атрибуты своих классов, а классы наследуют атрибуты классов выше по дереву.

Классы, выше по дереву (С2 и С3), обычно наз. суперклассами (или родительские, базовые), а классы ниже по дереву (С1), обычно наз. подклассами (или дочерние). Суперклассы реализуют общее поведения для подклассов, а подклассы могут переопределять поведение наследуемое от суперкласса, переопределяя имена суперклассов ниже в дереве.

Допустим мы создали дерево по рис. 25.1 и пишем:

I2.w

Этот код демонстрирует наследование. Т.к. это выражение вида object.attribute, оно приводит к запуску  поиска в дереве - интерпретатор ищет атрибут w начиная с I2 и идет вверх. Порядок такой - I2, C1, C2, C3.
Остановится когда найдет атрибут или возбудит исключение если w не найдет вообще. Т.о. автоматич. поиск найдет имя I2.w как C2.w. В терминологии ООП это наз-ся I2 "наследует" атрибут w от C3.

В итоге видим, что два экземпляра наследуют от своих классов 4 атрибута: w, x, y, z. Другие атрибуты будут анйдены в различ. местах в дереве. Например:

- Для I1.x  и I2.x атрибут х будет найден в С1, где поиск остановится, т.к. С1 нах-ся ниже в дереве чем С2.

- Для I1.y и I2.y атрибут y будет найден в С1, где поиск остановится, т.к. это единственное место где он появл-ся.

- Для I1.z и I2.z атрибут z будет найден в С2, т.к. С2 нах-ся в дереве левее чем С3.

- Для I2.name атрибут name будет найден в I2, т.к. в этом случае поиск вообще не будет идти по дереву.

Обратите внимание на атрибут х в С1, т.к. мы видим, что С1 переопределяет этот атрибут ниже в дереве, тем самым замещая версию атрибута, расположенную выше в С2. Ниже мы увидим, что такие переопределения составляют основу адаптации программ. обеспечения в ООП.


Классы и экземпляры.  стр. 700

Классы и экземпляры (отдельные типы объектов) вып-ют почти одну роль: каждый из этих типов служит неким представлением пространства имен - пакета переменных и места, где определяются атрибуты. Т.о. можно сказать, что классы и экземпляры похожи на модули, при этом объекты в деревьях классов содержат автоматически определяемые ссылки на др. объекты пространств имен, и классы соотв. инструкциям, а не файлам.

Различие между ними такое, что классы представляют собой своего рода фабрики по производству экземпляров. Напр. есть класс Employee, определяющих характеристики служащего - из этого класса мы можем создавать фактические экземпляры класса Employee.
Это еще одно отличие классов от модулей: у нас всегда есть всего один экземпляр модуля в памяти (поэтмоу мы его и перезагружаем при необходимости), но экземпляров класса мы можем сделать сколько хотим.

У классов обычно есть ф-ции, присоединенные к ним (пр. computeSalary), а у экземпляров - элементы данных, используемые ф-циями класса (пр. hoursWorked). Фактически модель ООП не так сильн оотличается от классич. модели обработки данных, основанной на программах и записях, - в ООП экземпляры подобны записям с "данными", а классы - "программам", обрабатывающим эти данные. Однако в ООП есть еще иерархия наследования.


Вызовы методов классов.

Выше мы видели как атрибут I2.w в нашем дереве классов транслируется в C3.w при поиске. Нуэно понимать и знать, что точно так же наследуются и методы (т.е. ф-ции, присоединенные к классам в виде атрибутов).

Если ссылка I2.w - это вызов ф-ции, то оно означает: "вызвать ф-цию C3.w для обработки I2". Т.е. интерпретатор автоматич. отобразит вызов I2.w() на вызов C3.w(), передав унаследованной ф-ции экземпляр в виде первого аргумента.

Фактич. всякий раз когда вызывается ф-ция, присоединенная к классу, подразумевается не класс целиком, а экземпляр класса. Этот экземпляр, или контекст, явл-ся одной из причин, почему данная модель названа объектно-ориентированной, - всегда существует объект, над которым выполняются действия. Напр. мы вызываем метод giveRaise, присоедиенный как атрибут к классу Employee, - вызов этого метода не имел бы смысла без указания служащего, которому дается надбавка к зарплате.

Как мы узнаем далее, Питон передает методам подразумеваемый экземпляр в виде спец. первого аргумента, в соответствии с соглашением именуемого self. Также узнаем, что методы могут вызываться как через экземпляры (bob.giveRaise()), так и через классы (Employee.giveRaise(bob)).


Создание деревьев классов.

За всеми идеями ООП стоит реальный код. Мы создаем деревья и объекты в них с пом. инструкций class и вызовов классов, которые рассмотрим позднее. В двух словах:

- Каждая инструкция class создает новый объект класса.

- Каждый раз, когда вызывается класс, он создает новый объект экземпляра.

- Экземпляры автомат. свзываются с классами, из которых они были созданы.

- Классы связаны со своими суперклассами, перечисленными в круглых скобках в заголовке инструкции class, при этом порядок следования в списке определяет порядок расположения в дереве.

Например чтобы создать деревео на рис. 25.1 мы можем написать такой код (без реализации классов конечно, она пока не нужна):

class C2: ...				# Создать объекты классов (на рис. это овалы)
class C3: ...
class C1(C2, C3): ...		# Создаем объект класса связанного с суперклассами

I1 = C1()				# Создаем объекты экземпляров (на рис. прямоугольники)
I2 = C1()				# связанные со своими классами

- как видим экземпляры конструируем вызвав класс С1 дважды, как если бы это была обычная ф-ция. Экземпляры помнят класс, из которого они созданы, а класс С1 помнит свои суперклассы.

В этом примере использ-ся т.н. множественное наследование, которое означает, что некий класс имеет более одного суперкласса над собой в дереве классов. А порядок суперклассов с кобках определяет порядок поиска атрибутов.

Большое значени имеет  то, к какому из объектов присоединяется тот или иной атрибут - что определяет его область видимости. Атрибуты, присоединямые к экземплярам, принадлежат только этим конкретным экземплярам, но атрибуты, присоединенные к классам, использ-ся и подклассами и экземплярами. Далее увидим, что:

- Атрибуты обычно присоед-ся к классам с пом. инструкций присваивания внутри class, а не во вложенных инструкциях def, определяющих ф-ции.

- Атрибуты обычно присоед-ся к экземплярам с пом. присваивания значений спец. аргументу с именем self, передаваемому ф-циям внутри классов.

Напр. классы поределяют поведение своих экземпляров с пом. ф-ций, создаваемых def внутри инструкций class. А т.к. такие влож. инструкции def выполняют присваивание именам внутри класса, они присоед-ся к объектам классов в виде атрибутов и будут унаследованы всеми экземплярами и подклассами:

class C1(C2, C3):					# Создать и связать класс С1
	def setname(self, who):			# Присвоить: С1.setname
		self.name = who				# self - либо I1, либо I2

I1 = C1()						# Создать два экземпляра
I2 = C1()
I1.setname('bob')				# Записать 'bob' в I1.name
I2.setname('mel')				# Записать 'mel' в I2.name 
print(I1.name)					# Выведет 'bob'

Синтаксис инструкции def здесь самый обычный. С функциональной точки зрения, когда def появл-ся внутри инструкции class, как в нашем примере, она обычно наз-ся методом и автомат. принимает спец. первый аргумент с именем self, который содержит ссылку на обрабатываемый экземпляр.

Примечание. Если бы мы ранее изучали С++ или Java, то заметили бы, что в Питон имя self - это то же, что и указатель this, но в языке Питон аргумент self всегда использ-ся явно, чтобы сделать обращения к атрибутам более очевидным.

Т.к. классы способны делать множество экземпляров их методы использ-т этот, получаемый автоматически, аргумент self для получения или изменения атрибутов конкретного экземпляра, который обрабатывается методом. В нашем прим. имя self использ-ся для сохранения имени служащего в конкретном экземпляре.

Как и простые переменные, атрибуты классов и экземпляров не объявляются заранее, а появл-ся когда им присв-ся значение. Когда метод присв-ет значение атрибуту с пом. имени self, он т.о. создает атрибут экземпляра, находящегося в нижнем уровне дерева классов, потмоу что имя self автоматич. ссылается на обрабатываемый экземпляр.

Благодаря тому, что все объекты дерева классов - всего лишь объекты пространств имен, можно получать или устанавливать любой из их атрибутов, используя соотв. имена. Например выражение C1.setname явл-ся таким же допустимым, как и I1.setname, с условием, что имена C1 и I1 находятся в области видимости программ. кода.

Сейчас класс С1 не присоед-ет атрибут name к экземплярам, пока не будет вызван метод setname. Если нужно, чтобы атрибут name всегда присутствовал в экземплярах, то он должен создаваться на этапе создания калсса:

class C1(C2, C3):					
	def __init__(self, who):		# Создать имя при создании класса
		self.name = who				# self - либо I1, либо I2

I1 = C1('bob')					# Записать 'bob' в I1.name
I2 = C1('mel')					# Записать 'mel' в I2.name 
print(I1.name)					# Выведет 'bob'
 
При таком решении интерпретатор автоматич. будет вызывать метод с именем __init__ каждый раз при создании экземпляра класса. Новый экземпляр будут передаваться методу __init__ в виде первого аргумента self, а любые значения, перечисленные в круглых скобках при вызове класса, будут передаваться во втором и последующих аргументах. Т.о. инициализация экземпляров будет выполняться в момент их создания.

Метод __init__ известен как конструктор, т.к. он запускается на этапе конструирования экземпляра. Этот метод явл-ся представителем класса методов, которые наз-ся методами перегрузки операторов. Такие методы наслед-ся в дереве как обычно, а их миена нач-ся и закан-ся двумя подчеркиваниями. Интерпретатор вызывает их автоматич. когда экземпляры, поддерживающие их, участвуют в соответствующих операциях, и они, глав. образом, явл-ся альтернативой вызовам простых методов. Так же они не обязательны, если их нет то соотв. операции просто не поддерживаются экземплярами.


ООП - это многократное использование программного кода.

Конечно в ООП есть не только наследование. Напр. перегрузка операторов может применяться в др. случаях - классы могут предоставлять свои реализации таких операций как доступ по индексу, получение значений атрибутов, выво ди мн. др. Но вообще ООП реализует поиск атрибутов в деревьях.

Используя классы мы адаптируем программы, вместо того, чтобы изменять код или писать новый в каждом проекте - ООП дает нам способы многократного использования программ. кода.             

Классы это действительно лишь пакеты ф-ций и др. имен, которые напоминают во многом модули. Но также они обеспечивают удобную структуру размещения кода и переменных. И, в отличие от ф-ций и модулей, благодаря дереву наследования и поиску в нем, дают широкие возможности по адаптации программ. кода.

Напр. методы - это обычные ф-ции со спец. первым аргументом, поэтому мы можем подражать некоторым их чертам поведения, вручную передавая объекты для обработки обычным ф-циям. Методы в наследовании классов дают возможность адаптировать существующее программное обеспечение, создавая новые подклассы, определяющие новые методы, вместо того, чтобы изменять сущзествующий код. Такое невозможно в случае с модулями или ф-циями.

Пример. Пусть нас привлекли к реализации БД, где хранится информация о служащих. На базе ООП мы могли бы начать с реализации суперкласса с общими категориями для служащих:

class Employee:
	def computeSalary(self): ...
	def giveRaise(self): ...
	def promote(self): ...
	def retire(self): ...
	
Реализовав общее можно специализировать его для каждой категории служащих (у них же есть отличия). Т.е. можно создать подклассы, в которых будут изменения на основе отличий от типового представления служащего - а общие черты останутся от суперкласса. Напр. з\п инженера начисляется по особым правилам (не по часовому тарифу например), т.о. нам нужно переопределить всего один метод:

class Engineer(Employee):			# Специализированный подкласс
	def computeSalary(self): ... 	# Особенная реализация метода

- Новая версия computeSalary будет нах-ся в дереве классов ниже и будет замещать (переопределять) общую версию метода в классе Employee. Далее можно будет создавтаь экземпляры разновидностей классов служащих	соответственно с принадлежностью:

bob = Employee()		# Поведение по умолчанию
mel = Engineer()		# Особые правила начисления з\п 

Обратите внимание, что можно создавать экземпляры любых классов в дереве, - класс, экземпляр которого создается, определяет уровень, откуда будет начинаться поиск атрибутов. Напр. в дальнейшем эти два объекта экземпляров (bob и mel) могли бы быть встроены в большой контейнерный объект (напр. список или экземпляр др. класса), котоый представляет отдел или компанию, реализуя идею композиции (см. начало главы).

Если нам понадобится узнать з\п этих служащих можно вычислить её в соотв. с правилами классов этих объектов, благодаря поиску в дереве наследования:

company = [bob, mel]				# Составной объект
for emp in company:
	print(emp.computeSalary())		# Вызвать версию метода данного объекта 

Отметим, что список company мог бы храниться в файле (удобно для БД), например с пом. модуля pickle. Кроме того в Питон входит модуль shelve, который мог бы сохранять экземпляры классов в файлах с доступом по ключу, то же самое обеспечивает сторонняя разработка ZDOB и даже более качественно.


Последний пример - это еще одна разновидность полиморфизма (см. гл. 4 и 16). Т.е. смысл операции зависит от объекта, над которым она выполняется. Здесь метод computeSalary определяется для каждого объекта в дереве наследования. 

В др. приложениях полиморфизм может применяться для сокрытия (т.е. для инкапсуляции) различий интерфейсов. Напр. программа, которая обрабатывает потоки данных, может работать с объектами, имеющими методы ввода и вывода, не заботясь о том, что эти методы делают в действительности:

def processor(reader, converter, writer):
	while 1:
		data = reader.read()
		if not data: break
		data = converter(data)
		writer.rwite(data)
		
Передавая экземпляры классов с необходимыми интерфейсными методами read и write, специализированными под различные источники данных, мы можем использовать одну и ту же ф-цию processor для работы с любыми источниками данных, как уже существующими, так и с тем, что появятся в будущем:

class Reader:
	def read(self): ...				# Поведение и инструменты оп умолчанию
	def other(self): ...
class FileReader(Reader):
	def read(self): ...				# Чтение из локального файла
class SocketReader(Reader): ...
	def read(self): ...				# Чтение из сокета

...
processor(FileReader(...), 		   Converter, FileWriter(...))
processor(SocketReaderReader(...), Converter, TapeWriter(...))
processor(FtpReader(...), 		   Converter, XmlWriter(...))


Благодаря тому, что внутр. реализация методов read и write была разделена по типам источников данных, их можно изменять, не трогая программный код, подобный приведенному, который использует их.
Фактически ф-ция processor сама может быть классом, реализующим логику работы ф-ции преобразования converter, которую могут унаследовать подклассы, и позволяющим встраивать экземпляры, выполняющие чтение и запись, в соотв. с принципом композиции.

Когда мы привыкнем программировать в ООП, то обнаружим, что наша задача сводится к тому, чтобы в новом проекте подобрать уже имеющиеся суперклассы для нашей задачи.

На практике мы можем найти или купить уже готовые библиотеки суперклассов, известные как "фреймворки", в которых задачи программирования реализвоаны в классах. Напр. интерфейсы к БД, протоколы тестирования, создание графич. интерфейса и мн. др.

Конечно для понимания ООП и адаптации кода нужно время, нужно много работать и учиться. Кстати, ряд программистов изучают и составляют списки наиболее часто встречающихся решений в ООП, сейчас они известны как - шаблоны проектирования.    


















Глава 26. Основы программирования классов.  стр. 709 

Теперь мы приступим к изучению синтаксиса модели классов в Питон. В этой главе рассмотрим неск-ко простых классов в действии.

Классы обладают тремя основными отличительными особенностями. На самом простом уровне они представляют собой лиш ьпространства имен, во многом похожие на модули, которые мы изучали в пятой части книги. Но, в отличие от модулей, классы также поддерживают создание множества объектов, реализуют наследуемое пространство имен и перегрузку операторов.


Классы генерируют множество экземпляров объектов.

Чтобы понять эту возможность, для начала нужно понимать, что в ОО модели Питон существует две разновидности объектов: объекты классов и объекты экземпляров. 

Объекты классов реализуют поведение по умолчанию и играют роль фабрик по производству объектов экземпляров.  

Объекты экземпляров - это настоящие объекты, обрабатываемые программой, - каждый представляет собой самостоятельное пространство имен, но наследует имена (т.е. автоматич. имеет доступ к ним) класса, из которого был создан.

Объекты классов считаются инструкциями, а объекты экземпляров - вызовами. Каждый раз когда мы вызываем класс, мы получаем новый экземпляр этого класса. Классы - это фабрики, которые могут воспроизводит ьмножество экземпляров. В противоположность этому каждый модуль может присутствовать в программе в единственном экземпляре.

Как мы увидим ниже классы в Питон сочетают в себе черты, напоминающие ф-ции и модули, но они совершенно не похожи на классы в др. ЯП.


Объекты классов реализуют поведение по умолчанию.

Когда вып-ся инструкция class, она создает объект класса. Приведем неск-ко отличительных характеристик классов в Питон.

- Инструкция class создает объект класса и присваивает ему имя. Как и def, class явл-ся выполняемой инструкцией. Когда она вып-ся она создает новый объект класса и присваивает его имени, указанному в заголовке class. Как и def инструкция class обычно вып-ся при первом импорте содержащих их файлов.

- Операции присваивания внутри инструкции class создают атрибуты класса. Как и в модулях, операции присваивания на верх. уровне (не влож. в инструкции def создают атрибуты объекта класса. Инструкция class преобразует свою область видимости в пространство имен атрибутов объекта класса, так же, как глоабльная область видимости модуля преобразуется в его пространство имен. При выполнении инструкции class атрибуты класса становятся доступны по их составным (полным) именам: object.name.

- Атрибуты класса описывают состояние объекта и его поведение. Т.е. атрибуты хранят информацию о состоянии и описывают поведение, которым обладают все экземпляры класса, - инструкции def, вложенные в class, создают методы, которые обрабатывают экзмепляры.


Объекты экземпляров - это конкретные элементы.

Когда выз-ся объект класса, возвращается объект экземпляра. Приведем неск-ко характеристик экземпляров.

- Вызов объекта класса как функции создает новый объект экземпляра. Когда вызываем класс создается и  возвращается новый объект экземпляра. Экземпляры - это конкретные элементы данных в нашей проге.

- Каждый объект экземпляра наследует атрибуты класса и приобретает свое собственное пространство имен. Экземпляры созд-ся из классов и представляют собой новые пространства имен, они первоначальн опустые, но наследуют атрибуты класса из которого созданы.

- Операции присваивания значений атрибутам, через ссылку self в методах, создают атрибуты в каждом отдельном экземпляре. Методы класса, в первом аргументе (с именем self), получают ссылку на обрабатываемый объект экземпляра - присв-ие атрибутам через ссылку self создает или изменяет даннеы экземпляра, а не класса.


Первый пример.

Определим класс FirstClass в интерактив. оболочке:

>>> class FirstClass:					# Определяет объект класса
		def setdata(self, value):		# Определяет метод класса
			self.data = value			# self - это экземпляр
		def display(self):
			print(self.data)			# self.data - данные экземпляра

Здесь мы работаем в оболочке, но обычно такие инструкции вып-ся во время импорта вмещающего файл модуля. Как и ф-ции, классы не существуют пока интерпретатор не достигнет инструкций class и не выполнит их.

class нач-ся с заголовка (имя класса), затем идет тело класса (как обычно с отступами если нужно). У нас влож. инструкции это инструкции def - они определяют ф-ции, реализующие поведение класса.

Как мы знаем def на самом деле явл-ся операциями присв-ия - в нашем случае они присваивают объекты ф-ций именам setdata и display в области видимости инструкции class и тем самым создают атрибуты, присоединяемые к классу: FirstClass.setdata и FirstClass.display. Т.е. любое имя, которому присв-ся знач. на верх уровне во вложенном блоке класса становится атрибутом этого класса.

Ф-ции внутри классов обычно наз-ся методами. Но в первом аргументы они автоматич. получают подразумеваемый объект экземпляра - конекст вызова метода. Создадим пару экземпляров:

>>> x = FirstClass()
>>> y = FirstClass()

- Создаются два экземпляра с отдельными пространствами имен.

Вызывая класс таким образом мы создаем объекты экземпляров (обратите внимание на круглые скобки), которые явл-ся лишь пространством имен и имеют доступ к атрибутам класса.

Теперь у нас есть три объекта - два экземпляра и класс. Они связаны пространствами имен, по ООП объект х "наследует" класс FirstClass как и y.

Здесь у нас, в дереве наследования, атрибут "data" обнаруживается в экземплярах, а "setdata" и "display" - в классе, расположенном выше их.

Изначально оба экземпляра пустые, но они свзяаны с классом, из которого были созданы. Если через имя экземпляра обратиться к атрибуту объекта класса, то поиск вернет нам значение атрибута класса (при условии, что в экземпляре отсутствует одноименный атрибут):

>>> x.setdata("King Arthur")		# Вызов метода: self - это х
>>> y.setdata(3.14159)				# Эквивалентно: FirstClass.setdata(y, 3.14159)

Ни x, ни y не имеют атрибута setdata, поэтмоу интерпретатор идет по ссылке от экземпляра к классу. В этом и проявл-ся суть наследования в Питон - поиск имен в связанных объектах.

В ф-ции setdata внутри класса FirstClass значение аргумента записывается в self.data. Имя self внутри метода - имя самого первого аргумента, в соответствии с принятым соглашением, - автоматич. ссылается на обрабатываемый экземпляр (x или y), поэтмоу присваивание сохраняет значения в пространстве имен экземпляра, а не класса (так созд-ся имена-атрибуты "data" у экземпляров).

По причине того, что классы могут делать много экземпляров, методы должны использ-ть аргумент self, чтобы получит ьдоступ к обрабатываемому экземпляру. Пр ивызове метода display, чтобы вывести значение атрибутов self.data, мы увидим, что для каждого экземпляра они разные; с др. стороны, имя display само по себе одинаковое в x и y, т.к. оно пришло (унаследовано) из класса:

>>> x.display()			# В каждом экземпляре свои значения self.data
King Arthur
>>> y.display()
3.14159   

Видите - в атрибутах data экземпляров мы сохранили объекты различных типов (строку и число). Как и везде в Питон, атрибуты экземпляров (иногда наз-ся членами) никак не объявл-ся - они появл-ся, как только будет выполнена первая опреация присваивания (как и переменные). Т.е. если вызвать метод display до вызова метода setdata, то получим сообщение об ошибке.

Еще один способ позволяет изменять атрибуты экземпляров в самом классе, выполняя присваивание как с пом. аргумента self внутри методов, так и за пределами класса, когда экземпляр явно участвует в операции присваивания:

>>> x.data = "New value"
>>> x.display()
New value

Хоть это и редко применяется, но сущ-ет возможность создания новых атрибутов в пространстве имен экземпляра, присваивая значение за пределами методов класса:

>>> x.anothername = "spam"

Эта операция присоединит новый атрибут anothername, который затем сможет использ-ся любыми методами класса в объекте экземпляра х. Обычно классы создают все атрибуты экземпляров за счет присваивания значений аргументу self, но это не обязательно - программы могут получать, изменять или создавать атрибуты в любых объектах, к которым имеют доступ.


Классы адаптируются посредством наследования.

Помимо роли фабрик классы позволяют нам вводить новые компоненты (за счет подклассов), а не изменением существующего кода. Объекты экземпляров, созданнеы из класса, наследуют атрибуты класса. Классы могут наследовать др. классы, что открывает нам путь к иерархии классов, поведение которых специализируется за счет переопределения обощенных атрибутов, находящихся выше в дереве классов, подклассами, находящимися ниже. Т.е. чем ниже подклассы тем они спецрализированнее.

В Питон экземпляры наследуют классы, а классы наследуют суперклассы. Опишем основные идеи, лежащие в основе механизма наследования атрибутов:

- Суперклассы перечисляются в круглых скобках в заголовке инструкции class. Т.е., чтобы унаследовать атрибуты класса нужно указать его в кругл. скобках в заголовке инструкции class. Наследующий класс наз-ся подклассом, а наследуемый - суперклассом.

- Классы наследуют атрибуты своих суперклассов. Как экземпляры наследуют атрибуты своих классов, так и классы наследуют все атрибуты, определяемые в суперклассах.

- Экземпляры наследуют атрибуты всех доступных классов. Экземпляр наследует атрибуты своего класса, а также всех суперклассов. Поиск имен сначала проверяет сам экземпляр, потом его класс и потом все суперклассы.     

- Каждое обращение object.attribute вызывает новый независимый поиск. Интерпретатор проводит отдельный поиск в дереве классов для каждого атрибута, который ему встречается в выражении запроса. Сюда входят ссылки на экземпляры и классы из инструкции class (напр. X.attr), а также ссылки на атрибуты аргумента экземпляра self в методах класса. Каждое выражение self.attr в методе вызывает поиск attr в self и выше.

- Изменения в подклассах не затрагивают суперклассы. Замещение имен суперкласса в подклассах изменяет подклассы и тем самым изменяет унаследованное поведение.

Классы обеспечивают разложение на отдельные операции и адаптацию кода лучше, чем это могут сделать др. компоненты языка. Классы позволяют минимизировать избыточность программ. кода, а с др. - позволяют адаптировать уже существующий код, вместо его изменения.


Второй пример.

Итак, второй пример будет основан на предыдущем. Определим новый класс SecondClass, который наследует класс FirstClass и добавляет кое-что своё:

>>> class SecondClass(FirstClass):						# Наследует метод setdata
		def display(self):								# Изменяет метод display				
			print('Current value = "%s"' % self.data)

- т.о. SecondClass замещает атрибут display своего суперкласса.

В этом случае мы говорим, что класс SecondClass переопределяет метод display класса FirstClass. Иногда такая замена атрибутов, за счет переопределения, называется перегрузкой.

Сейчас класс SecondClass специализирует класс FirstClass, изменяя поведение метода display. С др. стороны он наследует метод setdata (как и все экземпляры подкласса). Создадим экземпляр:

>>> z = SecondClass()
>>> z.setdata(42)				# Найдет setdata в FirstClass
>>> z.display()					# Найдет переопределенный метод в SecondClass
Current value = "42"

- думаю нам понятны наследование и поиск и схема пространства имен в этом примере.

Заметим. Специализация, выполненная в классе SecondClass, находится полностью за пределами класса FirstClass. Т.е. она не оказывает влияние на уже созданнеы или создаваемые впоследствии объекты класса FirstClass, напр. х:

>>> x.display()		# Старое значение х (см. выше)
New value 

Т.о. мы не изменяли класс FirstClass, мы адаптировали его. Этот пример показывает нам как можно вносить изменения с пом. внеш. компонентов (подклассов).


Классы - это атрибуты в модулях.

Напомним, что в именах классов нет ничего необычного, это всего лишь переменные, которым присваиваются объекты во время выполнения инструкции class, а ссылки на объекты можно получить с пом. обычных выражений.

Напр. если бы определение класса FirstClass находилось в файле модуля, а не было введено в оболочке, мы могли бы импортировать этот модуль и использовать имя в строке заголовка инструкции class:

from modulename import FirstClass		# Скопировать имя в мою область видимости
class SecondClass(FirstClass):			# Использовать имя класса непосредственно	
	def display(self): ...

Или эквивалентный вариант:

import modulename								# Доступ ко всему модулю целиком
class SecondClass(modulename.FirstClass):		# Указать полное имя 
	def display(self): ...

Имена классов, как и всё остальное, всегда нах-ся в модулях, и поэтому при их употреблении необходимо следовать правилам, которые мы рассматривали в пятой части книги. Напр. в одном модуле могут нах-ся определения сразу нескольких классов - подобно другим инструкциям в модулях, инструкции class выполняются в ходе операции импорта и определяют имена, которые в свою очередь становятся атрибутами модуля.

Вообще любой модуль может содержать самые произвольные сочетания из любого числа переменных, ф-ций и классов, и все эти имена будут вести себя в модуле одинаково. Рассмотрим файл food.py:

# food.py

var = 1			# food.var

def func():		# food.func
	...
class spam:		# food.spam
	...
class ham:		# food.ham
	...
class eggs:		# food.eggs
	...

Это правило остается справедливым даже если модуль и класс имеют одинаковые имена. Например имеется файл person.py:

class person:
	...
	
Чтобы получить доступ к классу нам нужно обратиться к модулю как обычно:

import person				# Импортируем модуль
x = person.person()			# Класс внутри модуля

Имя person.person ссылается на класс person внутри модуля person, если мы просто будем использ-ть имя person, то обратимся к модулю, а не классу, но только если мы не использовали from:

from person import person
x = person()

Как и любые др. переменные, мы не увидим класс в файле модуля, пока не импортируем его или как-то не извлечем класс из вмещающего файла. Если для вас это сложно, то не используйте одинаковые имена для модулей и классов.

Согласно соглашениям, имена классов в Питон должны начинаться с заглавной буквы, для визуального отличия:

import person
x = person.Person()

И еще, несмотря на то, что классы и модули явл-ся пространствами имен для подключения атрибутов, они представляют собой совершенно разные структуры: модуль это отражение целого файла, а класс - лишь инструкция внутри файла.


Классы могут переопределять операторы языка Питон. стр. 717

Перегрузка операторов позволяет объектам, созданным из классов, перехватывать и участвовать в операциях, которые применяются к встроенным типам: сложение, получение среза, вывод, квалификация имен и т.д. 

Можно полностью реализовать класс в виде методов, однако перегрузка операторов позволяет объектам теснее интегрироваться в объектную модель Питона. Кроме того перегрузка позволяет нашим объектам действовать так же, как действуют встр. объекты, потому что она позволяет создавать менее противоречивые и более простые в изучении интерфейсы объектов и обеспечивает возможность обрабатывать объекты, созданные из классов, программным кодом, который предполагает взаимодействие со встр. типами.

Опишем основные идеи, лежащие в основе мехханизма перегрузки операторов:

- Имена методов, начинающиеся и заканчивающиеся двумя символами подчеркивания (__Х__), имеют специальное назначение. Перегрузка реализуется за счет создания методов со спец. именами для перехватывания операций. Питон определяет фиксированные и неизменяемые имена методов для каждой из операций.

- Такие методы вызываются автоматически, когда экземпляр участвует во встроенных операциях. Напр. если объект экземпляра наследует метод __add__, этот метод будет вызываться всякий раз, когда объект будет появл-ся в операции сложения (+). Возвращаемое значение метода становится результатом соотв. операции.

- Классы могут переопределять большинство встроенных операторов. Есть много спец. имен методов для реализации перегрузки почти всех операторов встр. типов. Это операторы выражений, базовые операции, такие как вывод и создание объекта.

- В методах перегрузки операторов не существует аргументов со значениями по умолчанию, и ни один из таких методов не явл-ся обязательным для реализации. Если класс не определяе ти не наследует методы перегрузки операторов, то это значит, что экземпляры класса не поддерживают эти операции. Напр. если нет метода __add__, попытка выполнить операцию + приведет к ошибке.

- Операторы позволяют интегрировать классы в объектную модель Питона. Благодаря перегрузке операторов, объекты, реализованные на базе классов, действуют подобно встр. типам и тем самым обеспечивают непротиворечивые и совместимые интерфейсы.

Вообще перегрузка не явл-ся обязательной функциональной особенностью, если она не нужна в вашем классе, то и хорошо, используйте стандартные методы. Напр. приложению работающему с БД не нужны такие операторы как * и + (нам нечего умножать и складывать в БД, со всеми задачами справятся стандартные методы работы с БД).

Мы не будем изучать перегрузку каждого оператора, доступного в Питон. Но есть один метод перегрузки оператора, который можно встретить практически в любом классе: метод __init__, который известен как конструктор и использ-ся для инициализации состояния объектов. Наряду с self он явл-ся одним из ключей понимания ООП в Питон.


Третий пример.

Определим подкласс, производный от SecondClass и реализующий три спец. метода, которые будут вызываться интерпретатором автоматически. 

И не путайте имя метода __init__ с файлом __init__.py в пакетах модулей!!!

- Метод __init__ вызывается, когда создается новый объект экземпляра (аргумент self представляет новый объект ThirdClass).

- Метод __add__ вызывается, когда экземпляр ThirdClass участвует в операции +.

- Метод __str__ вызывается при выводе объекта (точнее когда он преобразуется в строку для вывода вызовом встр. ф-ции str или её эквивалентом внутри интерпретатора).

Новый подкласс также определяет метод mul, котоырй изменяет сам объект в памяти. Приступим к испытаниям:

class ThirdClass(SecondClass):					# Наследует SecondClass
	def __init__(self, value):					# Вызывается из ThirdClass(value)
		self.data = value
	def __add__(self, other):					# Для выражения "self + other"
		return ThirdClass(self.data + other)
	def __str__(self):							# Вызывается из print(self), str()
		return '[ThirdClass: %s]' % self.data
	def mul(self, other):						# Изменяет сам объект: обычный метод
		self.data *= other  

>>> a = ThirdClass("abc")					# Вызывается новый метод __init__
>>> a.display()								# Унаследованный метод
Current value = "abc"
>>> print(a)								# __str__ : возвращает строку
[ThirdClass: abc] 

>>> b = a + 'xyz'							# Новый __add__ : создается новый экземпляр
>>> b.display()
Current value = "abcxyz"
>>> print(b)								# __str__ : возвращает строку
[ThirdClass: abcxyz]

>>> a.mul(3)								# mul: изменяет сам экземпляр
>>> print(a)
[ThirdClass: abcabcabc]

Класс ThirdClass "наследует" класс SecondClass, поэтмоу ег оэкземпляры наследуют метод display от SecondClass. Но теперь, при создании экземпляра ThirdClass ему передается доп. аргумент (напр. "abc"). Это значение передается конструктору __init__ в аргументе value, где присв-ся атрибуту self.data. В итоге при создании экземпляра класса ThirdClass значение атрибута data устанавливается автоматически, благодаря чему отпадает необходимость вызывать метод setdata после создания экземпляра.

Далее, объекты ThirdClass могут участвовать в операциях + и в вызовах ф-ции print. При операции сложения (+) объект экземпляра слева от оператора передается методу __add__ в виде аргумента self, а значение справа - в виде аргумента other. 

Т.е. механизм перегрузки операторов отображает операторы выражений и другие встр. операции, выполняемые над экземплярами классов, на спец. имена методов в классе. Здесь у нас использ-е оператора "+" приводит к вызову метода __add__.

Как видим в метод __add__ передается два аргумента и поэтому, из выражения вида a + "xyz", объект экземпляра (self) а и аргумент (other) "xyz" складываются. И получается строка. Т.о. независимо от того что вернет метод __add__, это значение будет интерпретироваться как результат операции сложения.

Когда объект будет участвовать в вызове print(), интерпретатор вызывает метод __str__ объекта и передает ему сам объект - любая строка, которую вернет метод, будет расцениваться, как строковое представление объекта для вывода. Переопределив метод __str__, мы получим возможность использ. ф-цию print для отображения объектиов этого класса, вместо того, чтобы вызывать метод display.

Методы со псец. именами наследуются подклассами и экземплярами, как любые др. имена, которые присв-ся в инструкции class. Если методы отсутствуют в классе идет их поиск в суперклассах. Имена методов пепегрузки не явл-ся встроенными именами или зарезервированными словами - это обычные атрибуты, которые отыскиваются интерпретатором в случае появления объектов в различ. контекстах. Обычно интерпретатор вызывает их автоматич., но они могут вызываться и программным кодом - метод __init__, часто взывается вручную, чтобы запустить конструктор суперкласса.

Внимание! Посмотрите, что метод __add__ создает и возвращает НОВЫЙ объект экземпляра этого класса (вызывая ThirdClass, которому передается значение результата), а метод mul ИЗМЕНЯЕТ текущий объект экземпляра (выполняя присваивание атрибуту аргумента self). Т.к. перегрузка - это всего лишь механизм отображения выражений на методы, мы можем интерпретировать операторы в своих объектах классов, как нам угодно.


Когда следует использовать перегрузку операторов?

Конечно использовать или нет перегрузку мы определяем сами. Выбор зависит от того, насколько близко наш класс должен имитировать поведение встр. типов. Как мы знаем, если метод перегрузки оператора отсутствует в определении класса и не наследуется из суперкласса, соотв. операция не будет поддерживаться экземплярами этого класса - при попытке вып-ть такую операцию мы получим исключение (или действие по умолч.).

Вообще перегрузка операторов чаще использ. при реализации объектов с матем. природой - класс вектора или матрицы (напр. перегрузка сложения). Для упрощения классов можно не использ. перегрузку, а использ. явные методы.

С др. стороны мы можем использовать перегрузку операторов, чтобы иметь возможность передавать объекты, определяемые пользователем, в ф-цию, которая вып-ет операции, поддерживаемые встр. типами (списки или словари напр.). Наличие того же набора операторов в нашем классе обеспечит поддержку нашими объектами тех же самых интерфейсов и т.о. совместимость с используемой ф-цией. В гл. 29 мы ознакомимся с длоп. приемами перегрузки операторов в примерах.

Метод-конструктор __init__ присутствует почти во всех реалистичных классах. Он позволяет классам немедленно заполнять атрибуты вновь созданных экземпляров, поэтому конструктор полезно использ. практически во всех разновидностях наших классов. Фактически, даже при том, что в Питон атрибуты не оьновляются, мы сможем без труда определить какие атрибуты принадлежат экземплярам, просмотрев программ. код метода __init__.


Самый простой в мире класс на языке Python.

Приступим к детальному изучению синтаксиса инструкции class, и еще раз вспомним, что модель наследования, на которой основаны классы, очень проста - суть её заключается в организации поиска атрибутов в деревьях взаимосвязанных объектов. Фактически можно создавать вообще пустые классы. Создадим класс без атрибутов (объект пустого пространства имен):

>>> class rec: pass

- вот нам и пригодилась пустая операция pass.

Теперь можем начинать присоединять атрибуты выполняя присваивание за пределами класса:

>>> rec.name = 'Bob'
>>> rec.age = 40

Когда атрибуты созданы можно обращаться к ним с пом. обычного синтаксиса. Классы - это полноценные объекты, даже если нет ни одного экземпляра. Фактич. они лишь самостоятельные пространства имен, поэтмоу пока есть ссылка на класс, мы можем в любое время добавлять или изменять его атрибуты по своему усмотрению. Посмотрим, что будет если создать два экземпляра класса:

>>> y = rec()		# Экземпляры наследуют имена из класса
>>> x = rec()  

Они начинают свое существование как объекты абсолютно пустых пространств имен. Однако они наследуют из класса атрибуты:

>>> x.name, y.name
('Bob', 'Bob')

- Эти экземпляры получили атрибут name из класса, своих атрибутов у них пока нет.

Но если сейчас атрибуту экземпляра присвоить др. значение, то будет создан (изменен) атрибут именно этого объекта. Т.е. операция присваивания значеняи атрибуту действует только на тот объект, к которому она прмиеняется. Экземпляр х получает собственный атрибут name, а экземпляр y по-прежнему наследует name от класса:

>>> x.name = 'Sue'
>>> rec.name, x.name, y.name
('Bob', 'Sue', 'Bob')

Фактич. атрибуты объекта пространства имен обычно реализованы в виде словарей, и деревья наследования классов тоже всего лишь словари со ссылками на др. словари.

Напр. в большинстве объектов, созданных на базе классов, есть атрибут __dict__, который явл-ся словарем пространства имен. Пример - порядок следования имен и перечень внутренних имен вида __X__ может изменяться от версии к версии интерпретатора, но имена, которые использовали, присутствует везде:

>>> list(rec.__dict__.keys())
['age', '__dict__', 'name', '__weakref__', '__module__', '__doc__']

>>> list(x.__dict__.keys())
['name']

>>> list(y.__dict__.keys())
[]

Видим, что в классе есть атрибуты age и name, объект х имеет только свой атрибут name, а объект y по-прежнему пуст.

Каждый экземпляр имеет ссылку на свой наследумый класс, она наз-ся __class__ :

>>> x.__class__
<class '__main__.rec'>

Классы также имеют атрибут __bases__ , который представляет собой кортеж его суперклассов:

>>> rec.__bases__
(<class 'object'>,)

>>> ThirdClass.__bases__
(<class '__main__.SecondClass'>,)       

Главное, что нужно понимать - модель классов в Питон очень динамична. Классы и экземпляры - это всего лишь объекты пространств имен с атрибутами, создаваемыми на лету присваиванием.

Даже методы, которые созда-ся def, влож. в инструкцию class, могут создаваться независимо от объекта класса. Пример поределения простой ф-ции вне класса:

>>> def upperName(self):
	return self.name.upper()		# Аргумент self по-прежнему необходим

Это простая ф-ция и она может вызываться как обычная ф-ция, при услови, что объект, получаемый ею, имеет атрибут name (в данном случае имя аргумента self не имеет никакого особого смысла).

>>> upperName(x)		# Вызов как обычной ф-ции
'SUE' 

Однако, если эту ф-цию присвоить атрибуту нашего класса, она станет методом, вызываемым из любого экземпляра (и через имя самого класса, при условии, что ф-ции будет вручную передан экземпляр):

>>> rec.method = upperName

>>> x.method()					# Вызват ьметод для обработки х
'SUE'

>>> y.method()					# То же самое, но в self передается y 	
'BOB'

>>> rec.method(x)				# Можно вызвать через имя экземпляра или класса
'SUE'        

Обычно заполнение классов произв-ся внутри инструкции class, а атрибуты экземпляров создаются присваиванием значений атрибутам аргумента self в методах. Но это не явл-ся обязательным.


Классы и словари. стр. 723 

Мы познакомились с основными особенностями модели классов. В гл. 8 мы увидели как можно использ. словари для хранения записей свойств сущностей в программах. Оказывается классы тоже могут играть эту роль - хранить информацию, как словари, но при этом могут включать логику обработки этой информации в методах.

Пример со словарем:

>>> rec = {}
>>> rec['name'] = 'mel'
>>> rec['age'] = 40
>>> rec['job'] = 'trainer/writer'
>>> 
>>> print(rec['name'])
mel

А теперь пример записи на основе класса, с заменой ключей атрибутами:

>>> class rec: pass

>>> rec.name = 'mel'
>>> rec.age = 40
>>> rec.job = 'trainer/writer'
>>> 
>>> print(rec.age)
40

Создав пустой класс мы заполняем его, присваивая значения его атрибутам.

Этот прием работает, но для каждой отдельной записи придется писать новую инструкцию class. Все-таки более удобно будет создавать экземпляры класса для новых записей:

>>> class rec: pass

>>> pers1 = rec()
>>> pers1.name = 'mel'
>>> pers1.age = 40
>>> pers1.job = 'trainer'
>>> 
>>> pers2 = rec()
>>> pers2.name = 'dave'
>>> pers2.job = 'developer'
>>> 
>>> pers1.name, pers2.name
('mel', 'dave')

Два отдельных объекта экземпляра и, соответственно, два разных атрибута name. И даже кол-во атрибутов у экземпляров может быть разным (напр. age). Т.о. каждый экземпляр имеет своё пространство имен, т.е. свой словарь атрибутов.

Мы могли бы создать более полноценный класс:

>>> class Person:
	def __init__(self, name, job):
		self.name = name
		self.job = job
	def info(self):
		return (self.name, self.job)

>>> rec1 = Person('mel', 'trainer')
>>> rec2 = Person('vls', 'developer')
>>> 
>>> rec1.job, rec2.info()
('trainer', ('vls', 'developer'))

В этот класс мы добавили логику (методы) инициализации экземпляров на этапе создания и сбора атрибутов в кортеж. Конструктор налагает некоторые ограничения целостности, требуя значения для двух атрибутов - name и job. Методы класса и атрибуты экземпляра вместе образуют пакет, объединяющий данные и логику.

Классы - это гибкость и универсальность, недоступные встр. типам и функциям.











Глава 27. Более реалистичный пример.  стр. 728

   
 
         


