
Часть. 4. Функции. стр. 459


Глава 16. Основы функций. стр. 461

Функция - это средство, позволяющее группировать наборы инструкций так, что в программе они могут запускаться неоднократно.
Они могут вычислять результат и иметь входные параметры. Оформление операций в виде функций - очень удобный инструмент, который мы можем использовать в самых разных ситуациях.

Т.о. функции устраняют необходимость вставлять в программу избыточные копии блоков одного и того же программного кода, он заменяется одной единственной функцией. Кстати, при изменении программы достаточно изменить только функцию, а не все повторяющиеся блоки.

Функции - самые основные программные структуры в ЯП Питон, обеспечивающие многократное использование программного кода и уменьшающие его избыточность. Также это средство проеткирования, разбивающее сложжную систему на простые и легкие части.

Таблица 16.1 Инструкции и выражения, имеющие отношения к функциям. стр. 461


Зачем нужны функции?

Это универсальное средство структурирования программы, в других ЯП функции могут называться - подпрограммами или процедурами.

Две основные роли:

- Максимизировать многократное использование программного кода и минимизировать его избыточность. Функции в Питон являют простейший способ упаковки логики выполнения, которая может использоваться в разных местах программы и более чем один раз. Ф-ции позволяют обощать и группировать код, который потом можно использ. много раз. Т.к. ф-ции позволяют поместить реализацию в одно место и использовать её в разных местах, они явл-ся основным инструментом структуризации - дают возможность уменьшить избыточность кода.

- Процедурная декомпозиция. Ф-ция помогает разбить сложную систему на части. Ведь гораздо проще создать решение малых задач по отдельности, чем реализовать большую и сложную задачу целиком и разом. Вообще ф-ции описывают "как делать", а не "зачем делать".


Создание функций. стр. 463

Ранее мы уже пользовались функциями, напр. создавали объект с помощью ф-ции open, использовали len и мн. др.

В этой главе мы узнаем как создавать новые функции. Написанные нами функции ведут себя так же ка ки встроенные - они могут вызываться в выражениях, получать значения и возвращать результаты.
Кстати, ф-ции в Питон ведут себя не так как в С.

Краткое описание основных концепций и понятий функций:

- def - это испольняемый программный код. Ф-ции в Питон создаются с помощью инструкции def. В отличие от компилирующихся ЯП, типа С, def относится к классу исполняемых инструкций - ф-ция не существует, пока интерпретатор не доберется до инструкции def и не выполнит ее. Допустимо (иногда и полезно) вкладывать def внутрь инструкций if, циклов while и даже других инструкций def. В самом типичном случае def вставляется внутрь модулей и генерируют функции во время первой операции импортирования модуля.

- def создает объект и присваивает ему имя. Интерпретатор встречает и выполняет def, при это создавая новый объект-функцию и связывая его с именем ф-ции. Т.е. имя становится ссылкой на объект-функцию. Объект-функция может быть свзязано с неск-ми именами, может сохраняться в списке и т.д. Функциям можно прикреплять атрибуты, с данными.

- Выражение lambda создает объект и возвращает его в виде результата. Ф-ции могут создаваться с пом. выражения lambda. Это дает нам создавать встроенные определения ф-ций там, где синтаксис не позволяет использ. инструкцию def.

- return передает объект результата вызывающей программе. Когда ф-ция вызывается, вызывающая программа приостанавливает работу, пока ф-ция не завершится и не вернет управление. Ф-ции вычисляющие значения возвпращают ег ос помощью return - возвращаемое значение становится рез-том вызова ф-ции.

- yield передает объект результата вызывающей программе и запоминает, где был произвдеен возврат. Ф-ции, называемые генераторами, могут использовать yield и сохранять состояние так, чтобы работа ф-ции могла быть возобновлена позднее.

- Аргументы передаются посредством присваивания (в виде ссылок на объекты). В Питон аргуменыт передаются ф-циям посредством операции присваивания (т.е. в виде ссылок на объекты). В Питон и вызывающая программа и и ф-ция совместно использ. ссылку на объект, но здесь нет никакого совмещения имен. Изменение имени аргумента не меняет имени в вызывающ. программе, но модификация изменямых объектоввнутри ф-ции может приводить к изменению объектов в вызывающей программе.

- global - объявляет переменные, глобальные для модуля, без присваивания им значений. По умолч. все имена, прсиваивание которым произв-ся внутри ф-ции, явл-ся локальными для этих ф-ций и существуют только во время выполнения этих ф-ций. Чтобы прсивоить значение имени в объемлющем модуле, ф-ция должна объявить его с помощью инструкции global. Поиск имен всегда производится в некоторой области видимости - там, где хранятся переменные, - а операция присваивания связывает имена с областями видимости.

- nonlocal - объявляет переменные, находящиеся в в области видимости объемлющей функции, без присваивания им значений. Это позволяет использ. объемлющие ф-ции, как место хранения информации о состоянии - информация восстанавливается в момент вызова ф-ции, при этом отпадает необходимость использ-ть глобальные переменные.

- Аргументы получают свои значения (ссылки на объекты) в результате выполнения операции присваивания. При передаче аргументво ф-ции выполняется операция прсиваивания значений (т.е. ссылок на объекты). Передача объектов в функции производится по ссылкам, но это не означает, что созд-ся псевдонимы имен. Изменение аргуменат фнутри ф-ции не влечет за собйо изменение соответствующего имени в вызывающей программе, но изменения в изменемых объектах отразятся в вызывающей программе.

- Аргументы, возвращаемые значения и переменные не объявляются. Как и во всем Питоне, на ф-ции не накладываются ограничения по типу. Фактически, никакие элементы ф-ций не требуют предварительного объявления, мы можем передавать аргументы любых типов, возвращать из ф-ции объекты любого типа и т.д. Т.о. одна и та же ф-ция может применяться к объектам различных типов. Допустимыми явл-ся любые объекты, поддерживающие совместимые интерфейсы (методы и выражения), независимо от конкретного типа.


Инструкция def.

def создает объект ф-ции и связывает его с именем. Общий вид таков:

def <name>(arg1, arg2, ... argN):
	<statements>

Мы видим, что def явл-ся типичной составной инструкцией, с заголовком и блоком инструкций, т.н. - телом ф-ции, т.е. программным кодом, который выполняется интерпретатором всякий раз, когда ф-ция вызывается.

В заголовке определяется имя ф-ции и список из нуля и более аргументов (др. навазние - параметры). Имена аргументов в заголовке будут связаны с обьъектами, передаваемыми в ф-цию, в точке вызова.

Тело ф-ции часто содержит инструкцию return:

def <name>(arg1, arg2, ... argN):
	...
	return <value>

- return может располагаться в любом месте в теле ф-ции - она завершает работу ф-ции и передает результат вызывающей программе.

Инструкция return явл-ся необязательной, если ее нет ф-ция завершается когда достигается конец тела ф-ции. С технич. точки зрения ф-ция без return автоматически возвращает объект None, однако это значение обычно просто игнорируется.


Инструкции def исполняются во время выполнения.

def - исполняемая инструкция, когда она выполняется, она создает новый объект ф-ции и присваивает этот объект имени. 

Не забываем! - Все, что есть в Питон относится к времени выполнения, здесь нет понятия времени компиляции.

Т.к. def инструкция, то можеть быть везде где могут быть инструкции - даже внутри других инструкций:

if test:
	def func():		# Определяет функцию таким способом
		...
else:
	def func():		# Или таким способом
		...
...
func() 		 		# Вызов выбранной версии


Чтобы понять этот фрагмент обратим внимание, что def напоминает инструкцию присваивания =  т.к. она просто выполняет присваивание во время выполнения.

В отличие от С ф-ции в Питон не должны быть полностью поределены к моменту запуска программы. Т.е. инструкции def не интерпретируются, пока не будут достигнуты и выполнены потоком выполнения, а код внутри def не выполняется, пока ф-ция не будет вызвана позднее.

Важно не имя функции, а объект, на который ссылается имя:

othername = func		# Связывание объекта функции с именем
othername()				# Вызов функции

- мы связали нашу функцию с другим именем и вызвали с использованием нового имени.

Ф-ция - это обычные объекты, они явно записываются в память во время выполнения программы.

Ф-ции позволяют присвоединять любые атрибуты, с информацией, напр. для сохранения инф-ии:

def func(): ...			# Создает объект функции
func()				# Вызывает объект
func.attr = value		# Присоединяет атрибут к объекту



Первый пример: определения и вызовы. стр. 466

Напишем первый пример функции. Как видим ф-ция имеет две стороны: определение (инструкция def, которая создает ф-цию) и вызов (выражение, которое предписывает интерпретатору выполнить тело функции).


Определение.

Ф-ция times, которая возвращает рез-т обработки двух аргументов:

>>> def times(x, y):
	return x * y
...
>>> 

- когда интерпретатор достигает инструкции def и выполняет ее, он создает объект функции, в который упакует программнфый код ф-ции и свяжет объект с именем times. Как правило такие ф-ции размещаются в файлах модулей и выполняются по время импортирования, но наша небольшая и можно создать ее прямо в интерактивной оболочке.


Вызов.

После выполнения def появл-ся возможность вызвать ф-цию, добавив круглые скобки после ее имени. В скобках указ-ся аргументы:

>>> times(2, 4)			# В круглых скобках аргументы: 2 и 4
8

- имени x присваивается значение 2, а имени y - значение 4, после чего запускается тело ф-ции. В нашем случае значение возвращается инструкцией return (собственно она и есть тело нашей ф-ции).

Теперь мы можем указать, что тело функции выполняется в момент ВЫЗОВА функции.

Результат ф-ции можно присвоить переменной:  

>>> x = times(3.14, 4)
>>> x
12.56

А теперь передадим ф-ции объекты разных типов:

>>> times('Ni', 4)		# Получилась операция повторения
'NiNiNiNi'

- т.о. мы видим, что смысл ф-ции times и тип возвращаемого значения определяется аргументами, которые ей передаются.


Полиморфизм в языке Питон.

Как мы уже подчеркнули, смысл выражения x*y полностью зависит от типа объектов x и y - т.е. это может быть как умножение, так и повторение.

В Питон именно объекты определяют синтаксический смысл операции.

Такого рода зависимость от типов известна как полиморфизм - термин, означающий, что смысл операции зависит от типов обрабатываемых объектов. Фактически все операции в Питон явл-ся полиморфическими.

Т.о. одна функция может автоматически применяться к целой категории типов объектов. Если объект поддерживает ожидаемые методы и операторы выражений, он будет совместим с логикой функции.

Напр. наша ф-ция times, - любые два объекта, поддерживающие оператор *, смогут обрабатываться ф-цией times и не важно что это за объекты и когда были созданы.

Если же будут переданы объекты, НЕ поддерживающие ожидаемый интерфейс, интерпретатор автоматически возбудит исключение.

Вообще интерфейс - это набор методов и операций, которые используются функцией.

Т.о. мы видим отличие Питона от статической типизации - программный код на Питоне не делает предположений о конкретных типах данных. Вообще, при программировании на Питон во внимание принимаются интерфейсы объектов, а не типы данных.

Конечно такая модель полиморфизма предполагает необходимость тестирования кода на наличие ошибок, напр. на соответствие типов и интерфейсов и т.п. Но тестирование оно много где применяется в больших масштабах, так что это не совсем даже и недостаток.


 
Второй пример: пересечение последовательностей. стр. 469

Вспомним цикл for, который выбирал элементы, общие для двух строк. Мы его усовершенствуем, сделав функцию.


Определение.

Плюсы оформления нашего цикла в виде функции:

- Сделав код в виде ф-ции, появится возможность использовать его столько раз сколько нужно;

- Т.к. вызывающая программа может передавать ф-ции произвольные аргументы, ф-ция может использ-ся с любыми двумя последовательностями (или итерируемыми объектами) для полученяи их пересечения;

- Когда логика работы в виде ф-ции достаточно изменить код всего в одном месте, чтобы изменить способ полученяи пересечения;

- Поместив ф-цию в файл модуля, её можно импортировать и использовать в любой программе на нашем ПК.


Итак, наш код, обернутый в функцию, превращается в утилиту нахождения пересечения:

def intersect(seq1, seq2):
	res = []
	for x in seq1:
		if x in seq2:
			res.append(x)
	return res

- все понятно: имя, аргументы, тело ф-ции, return. Двигаемся дальше.


Вызов.

Мы поместили нашу ф-цию в файл и для её создания импортируем наш модуль. Как только def будет выполнена, можно будет вызывать ф-цию и передавать ей два объекта последовательностей в круглых скобках:

>>> def inter(seq1, seq2):
	res = []
	for x in seq1:
		if x in seq2:
			res.append(x)
	return res

>>> inter(s1, s2)
['S', 'A', 'M']

- Как видим я набрал функцию прямо в IDLE, хотя в книге написано, что можно создать её в модуле и импортировать его, но тут начинается самое интересное...

- Я создал файл tnt.py и импортировал его, вызвав dir(tnt) я увидел, что атрибут inter присутствует у модуля tnt, НО - при попытке вызвать ф-цию inter:

>>>inter(s1, s2)
...
NameError: name 'inter' is not defined

- я получал сообщение об ошибке "NameError: name 'inter' is not defined", не представляю с чем это связано, возможно с тем, что tnt.py расположен в моей домашней директории.

- Самое печальное то, что я не знаю как с этим бороться.

Разобрался!!!!!


Мы импортируем модуль, а потом указывая имя модуля и его аргументы мы их используем. А в нашем случае ф-ция inter() как раз явл-ся аргументом модуля tnt (как мы уже писали выше о проверке dir()) и в конечном итоге всё работает:

>>> import tnt
>>> s1 = 'spam'
>>> s2 = 'scam'
>>> tnt.inter(s1, s2)
['s', 'a', 'm']

- это рекомендованный способ использования модулей.

Или, чтобы не писать каждый раз имя модуля, используем конструкцию from import:

>>> s1 = 'spam'
>>> s2 = 'scam'

>>> from tnt import inter
>>> inter(s1, s2)
['s', 'a', 'm']

- Вот такие вот подводные камни. Но всё-таки рекомендуется использовать просто import.

Все-таки нужно повторить первую часть моих записок, а то вот уже забыл правила использования атрибутов модулей. А если бы всё это помнил, не пришлось бы целый час сидеть в инете и искать ответ на "загадочную" ошибку с импортированным модулем.

Кстати наша функция, если честно, работает слишком медленно и в принципе не особо нужна, её можно заменить единственным выражением генератора списков:

>>> [x for x in s1 if x in s2]
['S', 'A', 'M']

- но всё же это простой пример применения функций к различному диапазону типов (различных типов последовательностей).


Еще о полиморфизме. стр. 470

Как и другие ф-ции, наша inter тоже полиморфна, пример:

>>> import tnt
>>> x = tnt.inter([1, 2, 3], (1, 4))		# Смешивание типов
>>> x										# Объект с результатом
[1]

- мы передали ф-ции список и кортеж, два разных типа - и она все равно сработала!

Т.е. inter будет выполнять итерацию по объектам послетовательностей любых типов, если они поддерживают ожидаемый интерфейс.

В нашем случае для inter, это означает, что первый объект должен поддерживать циклы for, а второй - поддерживать оператор in, выполняющий проверку на вхождение.

Так наша ф-ция поддерживает любые итераторы с ожидаемымми интерфейсами, даже файлы, словари и объекты на основе классов с перегрузкой операторов.

Опять же - если объекты не поддерживают ожидаемые интерфейсы, то будет возбуждено исключение.


Локальные переменные.

Рассмотрим переменные в нашем примере, и соотв. функции.

Переменная res внутри ф-ции inter - это то, что в Питон называется - локальной переменной, - имя, которое доступно только программному коду внутри инструкции def и существует только во время выполнения ф-ции.

Фактически, любые имена, которым были присвоены какие-либо значения внутри ф-ции, по умолчанию классифицируются как локальные переменные.

Почти все имена в ф-ции inter явл-ся локальными переменными:

- Переменная res явно участвует в операции присваивания, - поэтому она локальная;

- Аргументы передаются через присваивание, - поэтому seq1 и seq2 тоже локальные переменные;

- Цикл for присваивает элементы переменной, поэтому имя х также явл-ся локальным.


Все эти локальные переменные появл-ся в момент вызова ф-ции и исчезают, когда ф-ция возвращает управление - return возвращает объект результата, а имя res исчезает.     







Глава 17. Области видимости. стр. 474
   

Области видимости в языке Питон.

Что же такое имена в Питон. Каждый раз когда в программе используется некоторое имя, интерпретатор создает, изменяет или отыскивает это имя в пространстве имен - в области, где находятся имена.

Поиск имени применительно к программному коду, под термином область видимости подразумевается пространство имен, - т.е. место в коде, где имени было присвоено значение, определяет област ьвидимости этого имени для программного кода.

Почти все, что относится к именам (в т.ч. классификацию области видимости), в Питон связано с операциями присваивания. Т.е. мы видим, что имена появляются в тот момент когда им впервые присваивается некоторое значение, и прежде чем использовать имена им нужно присвоить значение.

Т.к. имена не объявл-ся заранее, интерпретатор, по месту операции присваивания, связывает имя с конкретным пространством имен. Т.е. место, где выполняется присваивание, определяет пространство имен, в котором будет наход-ся имя, а следовательно, и область его видимости.

Также, все имена, значения которым присв-ся внутри ф-ции, ассоциируются с пространством имен этой ф-ции. Это означает что:

- Имена, определяемые внутри инструкции def, видны только коду внутри def. К этим именам нельзя обратиться за пределами ф-ции;

- Имена, определяемые внутри def, не вступают в конфликт за пределами def, даже если и там и там одинаковые имена. Например имя Х за пределами def (в др. конструкции def или на верхнем уровне модуля), полностью отлично от имени Х, которому присвоено значение внутри инструкции def.

В любом случае, область видимости переменной (где она может использ-ся) всегда определяется местом, где ей было присвоено значение, и никакого отношения не имеет к месту, откуда была вызвана функция.

Как мы узнаем далее значения переменным могут быть присвоены в трех разных местах:

- Если присваивание переменной вып-ся внутри инструкции def, переменная явл-ся локальной для этой функции;

- Если присваивание производится в пределах объемлющей инструкции def, переменная явл-ся нелокальной для этой функции;

- Если присваивание произв-ся за пределами всех инструкций def, она явл-ся глобальной для всего файла (модуля, класса и т.п.).

Это называется лексической областью видимости, т.к. видимость опред-ся местоположением переменных в текстах программы, а не местом откуда вызывается ф-ция.


Пример, где инструкция Х = 99 создает глобальную переменную Х (видима в любом месте файла), а инструкция Х = 88 создает локальную (видима тольк овнутир def):

X = 99

def func():
	X = 88
	
- и хоть имена одинаковы, конфликта не будет, т.к. область видимости делает их различными.


Правила видимости имен.

Ф-ции образуют вложенные пространства имен (области видимости), которые ограничивают доступ к используемым в них именам, т.о. имена внутри ф-ций не конфликтуют с именами за их пределами (внутри модуля или внутри др. ф-ций).

Еще раз повторим, - ф-ции образуют локальную область видимости, а модули - глобальную. Они связаны м/у стобой:

- Объемлющий модуль - это глобальная область видимости. Глобальные переменные, для внешнего мира становятся атрибутами объекта модуля, но внутри модуля исп-ся как простые переменные.

- Глобальная область видимости охватывает единственный файл. Не заблуждайтесь насчет слвоа "глобальный" - имена на верхнем уровне файла явл-ся глобальными только для программного кода в этом файле. В Питон нет понятия глобальной области видимости для всех файлов. Имена всегда относятся к какому-нибудь модулю и всегда нужно явно импортировать модуль. Если слышите "глобальный", подразумевайте "модуль".

- Каждый вызов функции создает новую локальную область видимости. Каждую инструкцию def (и lambda) можно представить как определение новой локальной области видимости. Т.к. Питон позволяет ф-циям вызывать самих себя в цикле (наз-ся - рекурсия), локальная область видимости, с технич. точки зрения соответствует вызову ф-ции - т.е. каждый вызов создает новое локальное пространство имен. Рекурсия может исп-ся для обработки данных, структура которых заранее не известна.

- Операция присваивания создает локальные имена, если они не были объявлены глобальными или нелокальными. По умолч. все имена, с присваиванием внутри ф-ции, помещаются в локальную область видимости. Если нужно присвоить значение имени верхнего уровня в модуле, который вмещает ф-цию, это имя нужно объявить внутри ф-ции глобальным с помощью инструкции global. Если нужно присвоить значение имени, наход-ся в объемлющей инструкции def, это имя нужно объявит ьвнутри ф-ции с помощью инструкции nonlocal.

- Все остальные имена явл-ся локальными в области видимости объемлющей функции, глоабльными или встроенными. Преполагается, что имена, которым не присвоены значения внутри определения ф-ции, находятся в объемлющей локальной области (внутри объемлющей инструкции def), глобальной (в пространстве имен модуля) или встроенно (предопределнные имена в модуле builtins).


Код вводимый в интерактив. оболочке подчиняется всем этим правилам, этот код находится на уровне модуля __main__ - этот модуль действует также как любой другой модуль. Т.о. имена создаваемые в оболочке также нах-ся внутри модуля.

Любые операции присваивания, выполняемые внутри ф-ции, классифицируют имена как локальные: инструкции =, import, def, передача аргументов и т.д.

Операции непосредственного изменения объектов не рассматривают имена как локальные - это свойственно только операциям присваивания. 
Например, если имени L присвоен список, определенный на верхнем уровне в модуле, то такая инструкция как L.append(Х), внутри ф-ции не будет классифицировать имя L как локальное, тогда как инструкция L = X  - будет. В первом случае происходит изменение объекта на которое указывает L, а не самого имени L - список будет найден в глобальной области видимости, как обычно, и будет изменен, без объявления имени global (или nonlocal).
Этот пример показывает различие м/у именами и объектами - т.е. видим, что операция, изменяющая объект, совсем не то, что операция присваивания объекта имени.


Разрешение имен: правило LEGB.

Три правила для def:

- Поиск имен ведется, самое большое, в четырех областях видимости: локальной, затем в объемлющей ф-ции (если она есть), затем в глобальной и, наконец, во встроенной.

- По умолч. операция присваивания создает локальные имена.

- Объявления global и nonlocal отображают имена на область видимости вмещающего модуля и ф-ции соответственно.


Все имена, присваемые значениями внутри def (или lambda), по умолч. явл-ся локальными; функции могут использ. имена в лексически объемлющих ф-циях и глобальной области, но чтобы изменять их, они должны быть объявлены нелокальными и глобальными.

Схема разрешения имен в Питон иногда наз-ся LEGB (по первым буквам областей видимости):

- Когда фнутри ф-ции идет обращение к имени, интерпретатор сначала ищет имя в локальной области (local, L), затем в локальной области объемлющей инструкции def (enclosing, E) или выражении lambda, затем в глобальной (global, G), и, наконец, во встроенной (built-in, B). Если имя так и не найдется, то появится сообщение об ошибке.  
    
- Когда внутри ф-ции выполняется операция присваивания (а не обращение к имени внутри выражения), интерпретатор всегда создает или изменяет имя в локальной области, если в этой ф-ции оно не было объявлено глобальным или нелокальным.

- Когда выполняется присваивание имени за пределеами ф-ции (на уровне модуля или в интерактив. оболочке), локальная область совпадает с глобальной - с пространством имен модуля.

Рисунок 17.1  Правило LEGB поиска имен в областях видимости. 
   
 
Отметим, что эти правила применимы только к простым переменным, типа spam. Далее в книге мы увидим, что полные имена атрибутов (как напр. object.spam) принадлежат определенным объектам и к ним применяются другие правила поиска. Поиск производится в одном или более объектах, а не областях видимости, что связано с механизмом под названием "наследование".


Пример области видимости.

>>> x = 99				# Глобальная область видимости
>>> 					# Х и func() определены в модуле: глобальная область

>>> def func(y):		# Y и Z определены в функции: локальная область 
	# Локальная область видимости
	z = x + y			# Х - глобальная переменная 
	return z

>>> func(1)				# func в модуле: вернет число 100
100	
    
- Глобальные имена: Х и func. Х - глобальное, т.к. объявлено на верхнем уровне модуля, к нему можно обращаться внутри ф-ции без дополнительных объявлений. func - глобальное по тем же причинам. Инструкция def связывает объект ф-ции с именем func на верхнем уровне модуля.

- Локальные имена: Y и Z. Имена Y и Z явл-ся локальными (и сущ-ют только во время выполнения ф-ции), потому что присваивание им осущ-ся внутри определения ф-ции.


Суть разделения в том, что локальные переменные играют роль временных имен, на время вызова ф-ции.

Разделение имен на глобал. и локал. облегчает понимание ф-ций, т.к. большинство имен, используемых в ф-ции, появл-ся непосредственно в самой ф-ции, а не в произвольном месте модуля. Также мы будем уверены, что локал. имена не изменятся где-то в другом месте программы.


Встроенная область видимости.

Встроенная облатсь видимости - это всего лишь встроенный модуль с именем builtins, но чтобы использовать это имя необходимо импортировать этот модуль, потому что само имя builtins не явл-ся встроенным.

Такой вот парадокс, встроенная область реализована как модул ьстандартной библиотеки с именем builtins, но само имя не находится во встроенной области, поэтому чтобы исследовать его нужно импортировать.

>>> import builtins
>>> dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 
... множество других имен пропущено, их очень много...
, 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
>>>     

Имена в этом списке стоставляют встроенную област ьвидимости языка Питон. Примерно первая половина - это встроенные исключения, а вторая - встроенные функции.

Согласно правилу LEGB интерпретатор выполняет поиск в этом модуле в последнюю очередь. Все имена из этого списка мы получаем в свое распоряжение по умолч., чтобы их использ. не требуется импортировать какие-то модули. 
Поэтому ест ьдва способа вызова встроенной функции:

>>> zip					# Обычный способ
<class 'zip'>

>>> import builtins		# Более сложный способ
>>> builtins.zip
<class 'zip'>

- второй способ иногда удобен при выполнении сложных действий.

Согласно правилу LEGB, как только будет найдено подходящее имя поиск прекращается, отсюда следует, что имена в локальной области могут переопределять переменные с такими же именами как в глобальной, так и во встроенной области, а глоабльные имена могут переопределять имена во встроенной области.

Напр. внутри ф-ции можно создать переменую open:

def hider():
		open = 'spam'			# Локальная переменная, переопределяет встроенное имя
		...
		open('data.txt')		# В этой области видимости файл не будет открыт

Однако, в результате этого встроенная ф-ция с именем open, которая располагается во встроенной (внешней) области видимости, окажется скрытой.
Обычно это считается ошибкой, но неприятность в том, что Питон не сообщит об ошибке, ведь технически переопределение возможно.


Таким же способом ф-ции могут переопределять имена глобальных переменных:

X = 88				# Глобальная переменная Х

def func():
	X = 99			# Локальная переменная Х: переопределяет глобальную
	
func()
print(X)			# Выведет 88: значение не изменилось

- без объявления global (или nonlocal) в инструкции def, нельзя изменить переменную, расположенную за пределами ф-ции.		


Примечание.

Касательно различий м/у 2.6 и 3.0. В 2.6 builtins наз-ся __builtin__. В большинстве глобальных областей присутствует имя __builtins__ ссылающееся на имя builtins.

В 3.0 выражение __builtins__ is builtins вернет True, а в 2.6 значение True вернет выражение  __builtins__ is __builtin__. Т.е. мы можем исследовать встроенную область с помощью вызова dir(__builtins__) в обеих версиях, не импортируя модуль.

Однако в программах 3.0 рекомендуется использ. модуль builtins.


Как испортить себе жизнь в Питон 2.6

В 2.6 имена True и False всего лишь переменные во встроенной области. Их можно переопределить инструкцией True = False. Эта инструкция всего лишь переопределит True в единственной области видимости, остальные области будут использовать оригинал из встроенной (норм. вида).

А можно написать __builtins__.True = False и истина станет ложью для всей программы! В 3.0 такие фокусы ликвидировали, там эти слова зарезервированы.


Инструкция global.

global и nonlocal - единственные инструкции в Питон, напоминающие инструкции объявления. Они не объявляют тип или размер - они объявляют пространства имен.

global сообщает интерпретатору, что ф-ция будет изменять одно или более глобал. имен.

- Глобальные имена - имена, котороые определены на верхнем уровне вмещающего модуля.

- Глобальные имена должны объявляться, только если им будут присваиваться значения внутри ф-ции.

- Обращаться к глобальным именам внутри ф-ции можно и без объявления их глобальными.


global изменяет переменные, нах-ся на верхнем уровен модуля, за пределами def. nonlocal применяется к именам в локальных областях объемлющих инструкций def.

Записывается ключевое слово global и за ним одно или более имен, через запятую, которые будут отображены на област ьвидимости вмещающего модуля при обращении к ним или при присваивании внутри ф-ции:

X = 88				# Глобальная переменная Х

def func():
	global X
	X = 99			# Глобальная переменная Х: за пределами инструкции def
	
func()
print(X)			# Выведет 99: значение не изменилось  

- после объявления global имя Х внутри инструкции def ссылается на переменную Х за её пределами. Т.е. теперь оба имени ссылаются на одну переменную.

Более слодный пример:

y, z = 1, 2				# Глобальные переменные в модуле

def all_global():
	global x			# Объявляется глобальной для присваивания
	x = y + z			# Объявлять y и z не нужно: применяется правило LEGB
	
- Здесь x, y, z используемые внутри all_global() явл-ся глобальными. y, z считаются глобальными потому, что внутри ф-ции им не присваивается значение. х глоабльная потому что перечислена в инструкции global. Без инструкции global переменная х была бы локальной.

Внимание! y и z не были объявлены как глобальные, но следуя правилу LEGB, интерпретатор автоматически отыщет их в области видимости модуля.
Кроме того переменная х может не существовать в модуле в момент вызова ф-ции, присваивание создаст эту переменную.


Минимизируйте количество глобальных переменных.

Использование локальных переменных - это наиболее правильное решение. Изменение  же глобальных переменных может привести к известным проблемам: когда значения переменных зависят от порядка, в котором вызываются функции, что осложняет отладку программы (или поиск причины ошибки).

Пример:

X = 99

def func1():
	global X
	X = 88
		
def func2():
	global X
	X = 77
	
- При применении этих двух функций значение Х будет зависеть от выбранного момента времени, т.к. будет зависеть от того какая ф-ция вызывалась последней.

Т.е. 88 или 77 - придется смотреть ВЕСЬ ход выполнения программы и при изменении модуля также придется держать в голове ВСЮ программу.

Это значительная проблема глобальных переменных.

С другой стороны, кроме случаев ООП и классов, глобал. переменные это один из самых удобных способов хранить информацию о состоянии (информация, которую нужно хранить между вызовами ф-ций), т.к. локал. переменные исчезают, а глобальные нет.
Можно использ. другие приемы для этого, но глобал. переменные для этого гораздо проще.

Также глобальные переменные можно хранить в одном глобальном модуле и использовать в многопоточных режимах, в роли памяти.

А пока лучше избегать глобальных переменных, старайтесь организовывать обмен данными через параметры и возвращаемые значения.


Минимизируйте количество изменений в соседних файлах. стр. 484

Несмотря на то, что можно непосредственно изменять переменные в другом файле, этого следует избегать. 
  
Рассмотрим два модуля:

# first.py
X = 99				# Этот программный код ничег оне знает о существовании second.py

# second.py
import first
print(first.X)		# Ничего плохого нет, чтобы обратиться к имени в др. файле

first.X = 88		# Но изменение может привести к сложностям
	
- первый модуль определяет Х=99, второй импортирует первый модуль, чтобы использовать его переменную и затем присвоить ей новое значение. 

Импортирование модуля для использ-я его переменных - это обязательное условие, т.к. каждый модуль обладает своим персональным пространством имен.

Т.о. глобальная облась модуля, после импорта, превращается в пространство имен атрибутов объекта модуля - импортирующий модуль при этом получает доступ к глобал. импортируемого модуля.

В целом нет ничего плохого такого обращения к переменным, тем более технич. возможно оно. Но такая тесная зависимость модулей, в лучшем случае приводит к снижению гибкости программы, а в худшем - к ошибкам.

Достаточно трудно держать такие свзяи в голове, а если модули кодируют разные программисты то вообще будет путаница.

В таких случаях свзяь м/у модулями лучше делать через вызовы функций, передавая им аргументы и получая возвращаемые значения:

# first.py
X = 99				# Этот программный код ничег оне знает о существовании second.py

def setX(new):
	global X
	X = new

# second.py
import first
first.setX(88)


Даже тот кто будет в первый раз читать код, поймет, что ф-ция setX - это часть интерфейса модуля, и поймет, что переменная Х может изменяться.
Эта ф-ция устраняет элемент неожиданности, который был в первом примере.

Мы не можем совсем отказаться от изменений в соседних файлах, но нужно свести их к минимуму и тщательно следить за этим.


Другие способы доступа к глобальным переменным.

Перевод глобал. переменных в атрибуты объекта модуля позволяет имитировать инструкцию global, импортируя вмещающий модуль и выполняя присваивание его атрибутам.

Пример: код нашего файла в одном случае импортирует вмещающий модуль по имени, в другом использ. таблицу загруженных модулей sys.modules:

#tnt.py

var = 99					# Глобальная переменная == атрибут модуля

def local():
	var = 0				# Здесь изменяется локальная переменная

def glob1():
	global var			# Глобальное объявление (обычное объявление)
	var += 1			# Изменяем глоабльную переменную var, теперь var = 100

def glob2():
	var = 0				# Здесь изменяется локальная переменная
	import tnt			# Модуль tnt импортирует сам себя 
	tnt.var += 1		# Благодаря импорту мы можем изменить глоабльную переменную, var = 101
	
def glob3():
	var = 0				# Здесь изменяется локальная переменная
	import sys						# Импорт системной таблицы
	glob = sys.modules['tnt']		# Получить объект модуля (или использ. __name__)

	glob.var += 1				# Изменяется глобальная переменная, теперь var=102	
	
def test():
	print(var)
	local(); glob1(); glob2(); glob3()
	print(var) 

Рассмотрим работу наших ф-ций и затем сделаем важные замечания:

>>> import tnt
>>> tnt.test()
99
102
>>> tnt.var
102

- все данные правильные, как в книге. 	
	
  
Замечание!!! Опишу выявленные мной особенности этого примера.

В книге, в ф-ции glob2 последняя стркоа была другая:

def glob2():
	var = 0
	import tnt
	glob.var += 1
   
- при этом я получал вывод 99 и сразу сообщение об ошибке:

>>> import tnt
>>> tnt.test()
99
Traceback (most recent call last):
  File "<pyshell#4>", line 1, in <module>
    tnt.test()
  File "C:\Python34\tnt.py", line 26, in test
    local(); glob1(); glob2(); glob3()
  File "C:\Python34\tnt.py", line 15, in glob2
    glob.var += 1
NameError: name 'glob' is not defined

Почитав код я заменил glob на tnt и всё заработало! Удивительно, но факт. И либо в программе ошибка, либо у меня всё работает, но как-то по-другому чем у автора книги. 
Но думаю, что я всё правильно исправил,	т.к. вывод работы программы верный.

В этом примере мы написали много кода, такие способы дают больше кода чем могло быть при сипольз. global.

Т.о. знаем, что global дает возможность изменения переменных в модуле из ф-ций. nonlocal обеспечивает изменение переменных в объемлющих ф-циях и для её изучения мы приступим к вложенным ф-циям.



Области видимости и вложенные функции. стр. 487

С вложенными областями сталкиваются достаточно редко, но мы изучим их.

Иногда объемлющие области видимости называют статически вложенными областями видимости. На самом деле вложение явл-ся лексическими - вложенные области соотв-т физически вложенным блокам программного кода в исходных текстах программы.  


Вложенные области видимости.

Внутри функции:

- Поиск имени Х сначала идет в локальной области (внутри самой ф-ции); затем в локальных областях всех объемлющих ф-ций (изнутри наружу); затем в текущей глоабльной области (в модуле), и, наконец, во встроенной области (модуль builtins). Поиск имен, объявленных в global, начинается сразу в глоабльной области видимости.

- Присваивание (X = value) по умолч. создает или изменяет имя Х в текущей локал. области. Если Х объявлено глоабльным внутир ф-ции, присв-ие создает или изменяет Х в области видимости объемлющего модуля. Если Х объявлено нелокальным внутри ф-ции, присв-ие создает или изменяет имя Х в ближ. области видимости объемлющей ф-ции.

global отображает имена в область видимости объемлющего модуля. Если есть влож. ф-ции можно получить значения переменных в объемл. ф-циях, но чтобы их изменить, переменные должны быть указаны в объявлении nonlocal.


Прмиеры вложенных областей видимости.

X = 99				# Имя в глоабл. области видимости: не используется

def f1():
	X = 88			# Локальное имя в объемлющей ф-ции
	def f2():
		print(X)	# Обращение к переменной во вложенной ф-ции
	f2()

f1()				# Выведет 88: локальная переменная в объемлющей ф-ции 


- В этом примере вложенная инструкция def исполняется в момент вызова ф-ции f1 - она создает ф-цию и связывает её с именем f2, которое явл-ся локалбным и  размещается в локал. области видимости ф-ции f1.

Неким образом f2 - это временная ф-ция, которая существует только во время работы (и видима только для программного кода) объемлющей ф-ции f1.

Внутри f2 - когда происходит вывод Х, она ссылается на переменную Х в локал. области объемлющей ф-ции f1. Ф-ции могут обращаться к именам, котореы физически располагаются в любых объемлющих инструкциях def, и имя Х в f2 автоматом отображается на имя Х в f1, по правилам LEGB.

Это правило работает даже если объемлющая ф-ция уже вернула управление:

def f1():
	X = 88
	def f2():
		print(X)		# Сохраняет значение Х в объемлющей области
	return f2			# Возвращает f2, но не вызывает её 

action = f1()			# Создает и возвращает ф-цию
action()				# Вызов этой ф-ции: выведет 88

- при вызове action запускается ф-ция, созданная во время выполнения ф-ции f1. Ф-ция f2 помнит переменную Х в области объемлющей ф-ции f1, которая уже неактивна.


Фабричные функции.

Замыкание или фабричная функция - под этим подразумевается объект ф-ции, который сохраняет значения в объемлющих областях видимости, даже когда эти области прекращают сущ-ие.

Классы лучше подходят для сохранения состояния, а эти функции просто альтернатива.

Пример, фабрич. ф-ции использ-ся когда нужно создавать обработчики событий прямо в процессе выполнения в соответствии с условиями (например нужно запретить пользователю вводить данные).

Пример:

>>> def maker(N):
		def action(X):			# Создать и вернуть функцию
			return X ** N		# Ф-ция action запоминает значение n в объемлющей 
		return action			# области видимости
		
- здесь определяется внешняя ф-ция, которая создает и возвращает вложенную, не вызывая её.

>>> f = maker(2)
>>> f
<function maker.<locals>.action at 0x0227A618>

- если вызвать maker она просто вернет ссылку на вложенную ф-цию.

А теперь вызовем то, что было получено от maker:

>>> f(3)			# Запишет 3 в X, в N по-прежнему хранится 2 
9
>>> f(4)
16 

- при этом была вызвана вложенная внутри maker ф-ция action.

Интересно то, что вложенная ф-ция хранит число 2, значение N в maker, даже при том, что ф-ция maker уже завершила свою работу.

На самом деле имя N из объемлющей локальной области сохр-ся как инф. о состоянии, присоединенная к action, и мы получаем обратно значение аргумента, возведенное в степень N (в нашем случае - в квадрат).

Если снова вызвать maker (внеш. ф-цию), получим новую фложенную ф-цию уже с др. инф. о состоянии, присоединенной к ней - и будет вычислятьтся куб, а ранее сохраненная ф-ция по-прежнему будет возвращать квадрат аргумента:

>>> g = maker(3)		# ф-ция g хранит число 3, а f - число 2
>>> g(3)		# куб аргумента
27
>>> f(3)		# квадрат аргумента
9
>>>

Этот прием распространен среди программистов работающих с функциональными ЯП.

Объемлющие области мы встретим позднее, в выражениях lambda. Также прием вложения ф-ций обычно использ. при разработке декораторов.

Вообще, классы  лучше подходят на роль "памяти". Также есть еще глобальные переменные, объемлющие области (текущая часть главы), и аргументы по умолчанию.


Сохранение состояния объемлющей области видимости с помощью аргументов по умолчанию. 

def f1():
	x = 88
	def f2(x = x):		# Сохраняет значение переменной х в объемлющей области
		print(x)		# в виде аргумента
	f2()
		
f1()			# Выведет 88


Конструкция arg = val в заголовке инструкции def означает, что аргумент arg по умолч. будет иметь значение val, если ф-ции не передается какого-либо другого значения.

Т.о. в нашем примере х по умолч. будет равен х в объемлющей области видимости.  

всё это сложно и зависит от вычисления значения по умолч. Поэтому сейчас в Питон автоматическое сохранение любых значений в объемлющей области, для использ. во вложенных def.

Наилучшая рекомендация, это, конечно, стараться избегать вложенных инструкций def, если это возможно.

Рассмотрим пример:

>>> def f1():
	x = 88
	f2(x)
	
>>> def f2(x):
	print(x)
	
>>> f1()
88

- Допустимо вызывать ф-цию (f2), определение которой в тексте программы нах-ся ниже ф-ции откуда производится вызов (f1), при условии, что вторая инструкция def (f2) будет исполнена до того, как первая ф-ция попытается вызвать её.


Вложенные области видимости и lambda-выражения.

lambda-выражение генерирует новую ф-цию, которая будет вызываться позднее, и оно похоже на инструкцию def.

Т.к. lambda это выражение оно может использоваться там где нельзя использ. def, например в литералах списков и словарей.

lambda также порождает локальную область видимости (как и def). lambda могут обращаться ко всем переменным, которые присутствуют в ф-циях, где находятся эти выражения.

def func():
	x = 4
	action = (lambda n: x ** n)		# запоминается х из объемлющей инструкции def
	return action

x = func()
print(x(2))			# Выведет 16 (4 ** 2)


Аналог этого примера:

def func():
	x = 4
	action = (lambda n, x=x: x ** n)		# Передача х вручную
	return action

Т.к. lambda это выражение, то они обычно вкладываются в инструкции def.


Области видимости и значения по умолчанию применительно к переменным цикла. 

Исключение: если lambda-выражение или def вложены в цикл внутри др. ф-ции и влож. ф-ция ссылается на переменную из объемлющей области видимости, которая изм-ся в цикле, все ф-ции, созданные в этом цикле, будут иметь одно и то же значение - значение, которое имела переменная на последней итерации.

Пример, пытемся создать список ф-ций, каждая из которых запоминает текущее значение переменной i и объемлющей области:

>>> def makeActions():
	acts = []
	for i in range(5):					# Сохранить каждое значение i
		acts.append(lambda x: i ** x)	# Все запомнят последнее значение i
	return acts

>>> acts = makeActions()
>>> acts[0]
<function makeActions.<locals>.<lambda> at 0x01707AE0>
	
- Но желаемый результат мы не получим, потому что поиск переменной в объемлющей области производится позднее, при вызове влож. ф-ций, в рез-те все они получат одно и то же значение (значение, которое переменная имела на последней итерации). Т.е. каждая ф-ция в списке будет возвращать 4 во второй степени, потому что во всех них переменная i имеет одно значение:

>>> acts[0](2)		# Все возвращают 4 ** 2, последнее значение i
16
>>> acts[2](2)		# хотя должно быть 2 ** 2
16
>>> acts[3](2)		# или 3 ** 2
16

В таком случае нужно явно сохранять значение из объемлющей области в виде аргумента со значением по умолч. Т.е. нужно передать текущее значение из объемлющей области в виде значения по умолчанию, которое вычисл-ся в момент создания вложенной ф-ции (а не когда она вызывается):

>>> def makeActions():
	acts = []
	for i in range(5):							# использовать значения по умолчанию
		acts.append(lambda x, i=i: i ** x)		# Сохранить текущее значение i
	return acts

>>> acts = makeActions()
>>> acts[0](2)
0
>>> acts[2](2)
4
>>> acts[3](2)
9

С подобным случаем можно столкнуться на практике, напр. в коде который генерирует функции-обработчики событий для элементов управления в графич. интерфейсе (нажатие кнопок напр.).


Произвольное вложение областей видимости.

Области видимости могут вкладываться произвольно, но поиск будет идти только в объемлющих ф-циях:

>>> def f1():
		x = 99
		def f2():
			def f3():
				print(x)		# Будет найдена в области видимости f1 !
			f3()
		f2()
	
>>> f1()
99

Интерпретатор будет искать переменную в локальных областях всех объемлющих инструкций def, от внутр. к внеш., выше локал. и ниже глобал. области модуля.

Но на практике считается, что плоское лучше вложенного - лучше будет если вы сведете к минимуму количество вложенных определений ф-ций.



Инструкция nonlocal. стр. 494

nonlocal позволяет влож. ф-циям не только читать, но и изменять значения переменных в областях видимости объемлющих ф-ций.

nonlocal объявляет имена, которые будут изменяться в теле ф-ции и которые находятся в объемлющей области видимости. Отличие в том, что nonlocal применяется только к областям объемлющих ф-ций и не трогает глобал. область модуля.

Имена, перечисленные в nonlocal, должны фактическ исуществовать в области видимости, вмещающей ф-цию, где встречается это объявление - они могут сущ-ть только в объемлющей области и не могут быть созданы первой инструкцией присваивания влож. ф-ции.

Т.е. nonlocal позволяет присваивать значения переменным в объемлющих областях и ограничивает поиск таких имен областями видимости объемлющих ф-ций.


Основы использования инструкции nonlocal.

def func():
	nonlocal name1, name2, ...

- nonlocal дает влож. ф-ции возможность присваивать именам (name1, name2) новые значения.

Т.о. для влож. ф-ций есть возможность поддерживать доступную для изменения информацию о состоянии, которая восстанавливается при последующих вызовах влож. ф-ции.

Также nonlocal вынуждает интерпретатор начинать поиск с областей видимости объемлющих ф-ций, пропуская локальную область видимости ф-ций. Т.е. nonlocal означает: - пропустить локальную область при поиске имен.

На практике, имена, которые в nonlocal, должны быть определены в объемлющих ф-циях к моменту, когда поток управления достигнет nonlocal, иначе буде тошибка.

nonlocal более строгая чем global, - она ограничивает область поиска тольк ообластями видимости объемлющих ф-ций.

Основное назначение nonlocal - не тольк ополучать, но и изменять значения переменных в объемлющих областях.
	
- global вынуждает интерпретатор начинать поиск с области объемлющего модуля и позволяет присваивать переменным новые значения. Поиск идет вплоть до встроенной области видимости.

- nonlocal ограничивает поиск областями видимости объемлющих ф-ций, и требует, чтобы имена, которые в nonlocal, уже существовали и может присваивать значения. В область поиска не входят глобал. и встроенная области видимости. 

В Питон 2.6 нельзя присвоить новые значения, для этого использ-ся классы.


Инструкция nonlocal в действии.

Ф-ция tester создает и возвращает влож. ф-цию nested. Обращение к переменной state из влож. ф-ции отображается на локал. област ьвидимости ф-ции tester, с применением обычных правил поиска:

>>> def tester(start):
		state = start				# Обращение к нелокальным переменным
		def nested(label):			# действует как обычно 
			print(label, state)		# Извлекает значение state из области
		return nested				# видимости объемлющей ф-ции

>>> F = tester(0)
>>> F('spam')
spam 0
>>> F('ham')
ham 0


По умолч. изменение перемененной в объемлющей области видимости не допускается:

>>> def tester(start):
	state = start
	def nested(label):
		print(label, state)
		state += 1				# По умолчанию не изменяется
	return nested

>>> F = tester(0)
>>> F('spam')
...
UnboundLocalError: local variable 'state' referenced before assignment


Использование nonlocal для изменения переменных. 

Если теперь state, локальную для tester, объявить в nested с помощью nonlocal, мы сможем изменять её внутри nested.

>>> def tester(start):
		state = start				# В каждом вызове сохраняется своё значение state
		def nested(label):
			nonlocal state			# Объект state находится в объемлющей области
			print(label, state)
			state += 1				# Изменит значение переменной, объявленной как nonlocal
		return nested

>>> F = tester(0)		# start = state = 0

>>> F('spam')			# label = 'spam' и будет увеличивать state при каждом вызове
spam 0
>>> F('spam')
spam 1
>>> F('spam')
spam 2 

При каждом отдельном вызове tester будет создаваться отдельная копия переменной state.

Т.о. объект state, фактич. прикрепляется к возвращаемому объекту ф-ции nested - каждый вызов tester создает новый, независимый объект state, т.е. изменение state в одной ф-ции не будет вляить на другие. Пример ниже:

>>> G = tester(42)			# новая функция с новой переменной state
>>> G('spam')
spam 42
>>> G('eggs')
eggs 43
>>> F('bacon')			# ну в ф-ции F state прежнее
bacon 3


Граничные случаи.

Первый момент - в отличии от имен в global, имена в nonlocal к моменту объявления уже должны существовать в области видимости объемлющей ф-ции, иначе - ошибка:

>>> def tester(start):
		def nested(label):
			nonlocal state			# Нелокальные переменные должны существовать
			print(label, state)
			state += 1
		return nested
...
SyntaxError: no binding for nonlocal 'state' found
>>>

>>> def tester(start):
	def nested(label):
		global state			# Глобальные переменные могут отсутствовать
		state = 0				# Создаст переменную в области видимости модуля
		print(label, state)
	return nested
...
>>> 
>>> F = tester(0)
>>> F('abc')
abc 0
>>> state
0

Второй момент - nonlocal огранивает область поиска имен только областями видимости объемлющих ф-ций - поиск нелокальных переменных не производится за пределами инструкции def ни в глобал. области модуля, ни во встроенной области, даже если переменные с такими именами там есть:

>>> spam = 99
>>> def tester():
		def nested():
			nonlocal spam				# Переменная должна быть внутри def, а не в модуле!
			print('Current=', spam)
			spam += 1
		return nested
...
SyntaxError: no binding for nonlocal 'spam' found


Именно из-за подобных случаев, во избежание путаницы, интерпретатор вынужден определять местоположение нелокальных имен в момент создания ф-ции, а не в момент её вызова.


Как следует использовать инструкцию nonlocal?

Основное - это решение проблем с сохранением информации с переменными в областях видимости объемлющих функций, напр. между вызовами ф-ций и методов.

Помним пример, где вызов ф-ции tester создает самостоятельный пакет информации, доступной для изменения, и где нет конфликта имен:

>>> def tester(start):
	state = start
	def nested(label):
		nonlocal state
		print(label, state)
		state += 1
	return nested

>>> F = tester(0)
>>> F('spam')
spam 0 

Этот код будет работать только в Питон 3.0, для 2.6 нужны другие способы.


Сохранение информации в глобальных переменных.

В 2.6 и ранее, для предыдущего эффекта достаточно переместить переменную state в глобал. область видимости (область видимости модуля):

>>> def tester(start):
	global state				# Переместить в область видимости модуля
	state = start
	def nested(label):
		global state
		print(label, state)
		state += 1
	return nested

>>> F = tester(0)
>>> F('spam')
spam 0
>>> F('eggs')
eggs 1 

Но здесь возникают некоторые ограничения. Глобальные переменные могут привести к конфликтам имен (это одна из ошибок при использ-ии глобал. переменных), также этот способ создает только одну копию информации о состоянии - если вызовем tester еще раз, то прежнее значение state будет сброшено в исходное состояние, т.е. предыдущие изменения будут затерты:

>>> G = tester(42)		# Сбрасывает значение единств. копии state в глобал. области
>>> G('toast')
toast 42
>>> G('bacon')
bacon 43
>>> F('ham')			# Значение state = 0 для F было затерто!
ham 44


Сохранение информации с помощью классов (предварительное знакомство).

Взглянем на комбинацию ф-ций tester/nested как на класс - информация о состоянии может быть записана в объекты явно, после их создания.

Нужно знать, что инструкция def внутри инструкции class действует точно так же, как и за её пределами. За исключением того, что ф-ция, определяемая внутри класса, автоматически получает аргумент self, ссылающийся на объект, относительно которого был сделан вызов (экземпляр класса, или объект, создается обращением к имени самого класса как к ф-ции):

>>> class tester:
	def __init__(self, start):			# Конструктор объекта,
		self.state = start				# сохранение информации в новом объекте
	def nested(self, label):
		print(label, self.state)		# Явное обращение к информации
		self.state += 1					# Изменения всегда допустимы

>>> F = tester(0)			# Создаст экземпляр класса, вызовет __init__
>>> F.nested('spam')		# Ссылка на F будет передана в аргументе self 
spam 0
>>> F.nested('ham')
ham 1
>>> G = tester(42)			# Каждый экземпляр получает свою копию информации
>>> G.nested('toast')		# Изменения в одном объекте не сказываются на других
toast 42
>>> G.nested('bacon')
bacon 43
>>> F.nested('eggs')		# В объекте F сохранилась прежняя информация
eggs 2
>>> F.state				# Информация может быть получена за пределами класса
3

Можно перегрузить операторы. Если к экземпляру класса обратиться как к функции, то будет вызван метод __call__. Т.о. мы уберем необходимость вызова именованного метода:

>>> class tester:
	def __init__(self, start):
		self.state = start
	def __call__(self, label):			# Вызывается при вызове экземпляра
		print(label, self.state)		# поэтому нет необходимости в методе .nested()
		self.state += 1
		
>>> H = tester(99)
>>> H('juice')
juice 99
>>> H('capkuke')
capkuke 100

Несмотря на то, что классы отличный способ хранения информации, они могут оказаться слишком тяжеловесными для простых случаев. А вложенные инструкции def, в некоторых случаях, могут быть даже быстрее классов.


Сохранение информации в атрибутах функций. стр. 501











