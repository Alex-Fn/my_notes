
Часть. 4. Функции. стр. 459


Глава 16. Основы функций. стр. 461

Функция - это средство, позволяющее группировать наборы инструкций так, что в программе они могут запускаться неоднократно.
Они могут вычислять результат и иметь входные параметры. Оформление операций в виде функций - очень удобный инструмент, который мы можем использовать в самых разных ситуациях.

Т.о. функции устраняют необходимость вставлять в программу избыточные копии блоков одного и того же программного кода, он заменяется одной единственной функцией. Кстати, при изменении программы достаточно изменить только функцию, а не все повторяющиеся блоки.

Функции - самые основные программные структуры в ЯП Питон, обеспечивающие многократное использование программного кода и уменьшающие его избыточность. Также это средство проеткирования, разбивающее сложжную систему на простые и легкие части.

Таблица 16.1 Инструкции и выражения, имеющие отношения к функциям. стр. 461


Зачем нужны функции?

Это универсальное средство структурирования программы, в других ЯП функции могут называться - подпрограммами или процедурами.

Две основные роли:

- Максимизировать многократное использование программного кода и минимизировать его избыточность. Функции в Питон являют простейший способ упаковки логики выполнения, которая может использоваться в разных местах программы и более чем один раз. Ф-ции позволяют обощать и группировать код, который потом можно использ. много раз. Т.к. ф-ции позволяют поместить реализацию в одно место и использовать её в разных местах, они явл-ся основным инструментом структуризации - дают возможность уменьшить избыточность кода.

- Процедурная декомпозиция. Ф-ция помогает разбить сложную систему на части. Ведь гораздо проще создать решение малых задач по отдельности, чем реализовать большую и сложную задачу целиком и разом. Вообще ф-ции описывают "как делать", а не "зачем делать".


Создание функций. стр. 463

Ранее мы уже пользовались функциями, напр. создавали объект с помощью ф-ции open, использовали len и мн. др.

В этой главе мы узнаем как создавать новые функции. Написанные нами функции ведут себя так же ка ки встроенные - они могут вызываться в выражениях, получать значения и возвращать результаты.
Кстати, ф-ции в Питон ведут себя не так как в С.

Краткое описание основных концепций и понятий функций:

- def - это испольняемый программный код. Ф-ции в Питон создаются с помощью инструкции def. В отличие от компилирующихся ЯП, типа С, def относится к классу исполняемых инструкций - ф-ция не существует, пока интерпретатор не доберется до инструкции def и не выполнит ее. Допустимо (иногда и полезно) вкладывать def внутрь инструкций if, циклов while и даже других инструкций def. В самом типичном случае def вставляется внутрь модулей и генерируют функции во время первой операции импортирования модуля.

- def создает объект и присваивает ему имя. Интерпретатор встречает и выполняет def, при это создавая новый объект-функцию и связывая его с именем ф-ции. Т.е. имя становится ссылкой на объект-функцию. Объект-функция может быть свзязано с неск-ми именами, может сохраняться в списке и т.д. Функциям можно прикреплять атрибуты, с данными.

- Выражение lambda создает объект и возвращает его в виде результата. Ф-ции могут создаваться с пом. выражения lambda. Это дает нам создавать встроенные определения ф-ций там, где синтаксис не позволяет использ. инструкцию def.

- return передает объект результата вызывающей программе. Когда ф-ция вызывается, вызывающая программа приостанавливает работу, пока ф-ция не завершится и не вернет управление. Ф-ции вычисляющие значения возвпращают ег ос помощью return - возвращаемое значение становится рез-том вызова ф-ции.

- yield передает объект результата вызывающей программе и запоминает, где был произвдеен возврат. Ф-ции, называемые генераторами, могут использовать yield и сохранять состояние так, чтобы работа ф-ции могла быть возобновлена позднее.

- Аргументы передаются посредством присваивания (в виде ссылок на объекты). В Питон аргуменыт передаются ф-циям посредством операции присваивания (т.е. в виде ссылок на объекты). В Питон и вызывающая программа и и ф-ция совместно использ. ссылку на объект, но здесь нет никакого совмещения имен. Изменение имени аргумента не меняет имени в вызывающ. программе, но модификация изменямых объектоввнутри ф-ции может приводить к изменению объектов в вызывающей программе.

- global - объявляет переменные, глобальные для модуля, без присваивания им значений. По умолч. все имена, прсиваивание которым произв-ся внутри ф-ции, явл-ся локальными для этих ф-ций и существуют только во время выполнения этих ф-ций. Чтобы прсивоить значение имени в объемлющем модуле, ф-ция должна объявить его с помощью инструкции global. Поиск имен всегда производится в некоторой области видимости - там, где хранятся переменные, - а операция присваивания связывает имена с областями видимости.

- nonlocal - объявляет переменные, находящиеся в в области видимости объемлющей функции, без присваивания им значений. Это позволяет использ. объемлющие ф-ции, как место хранения информации о состоянии - информация восстанавливается в момент вызова ф-ции, при этом отпадает необходимость использ-ть глобальные переменные.

- Аргументы получают свои значения (ссылки на объекты) в результате выполнения операции присваивания. При передаче аргументво ф-ции выполняется операция прсиваивания значений (т.е. ссылок на объекты). Передача объектов в функции производится по ссылкам, но это не означает, что созд-ся псевдонимы имен. Изменение аргуменат фнутри ф-ции не влечет за собйо изменение соответствующего имени в вызывающей программе, но изменения в изменемых объектах отразятся в вызывающей программе.

- Аргументы, возвращаемые значения и переменные не объявляются. Как и во всем Питоне, на ф-ции не накладываются ограничения по типу. Фактически, никакие элементы ф-ций не требуют предварительного объявления, мы можем передавать аргументы любых типов, возвращать из ф-ции объекты любого типа и т.д. Т.о. одна и та же ф-ция может применяться к объектам различных типов. Допустимыми явл-ся любые объекты, поддерживающие совместимые интерфейсы (методы и выражения), независимо от конкретного типа.


Инструкция def.

def создает объект ф-ции и связывает его с именем. Общий вид таков:

def <name>(arg1, arg2, ... argN):
	<statements>

Мы видим, что def явл-ся типичной составной инструкцией, с заголовком и блоком инструкций, т.н. - телом ф-ции, т.е. программным кодом, который выполняется интерпретатором всякий раз, когда ф-ция вызывается.

В заголовке определяется имя ф-ции и список из нуля и более аргументов (др. навазние - параметры). Имена аргументов в заголовке будут связаны с обьъектами, передаваемыми в ф-цию, в точке вызова.

Тело ф-ции часто содержит инструкцию return:

def <name>(arg1, arg2, ... argN):
	...
	return <value>

- return может располагаться в любом месте в теле ф-ции - она завершает работу ф-ции и передает результат вызывающей программе.

Инструкция return явл-ся необязательной, если ее нет ф-ция завершается когда достигается конец тела ф-ции. С технич. точки зрения ф-ция без return автоматически возвращает объект None, однако это значение обычно просто игнорируется.


Инструкции def исполняются во время выполнения.

def - исполняемая инструкция, когда она выполняется, она создает новый объект ф-ции и присваивает этот объект имени. 

Не забываем! - Все, что есть в Питон относится к времени выполнения, здесь нет понятия времени компиляции.

Т.к. def инструкция, то можеть быть везде где могут быть инструкции - даже внутри других инструкций:

if test:
	def func():		# Определяет функцию таким способом
		...
else:
	def func():		# Или таким способом
		...
...
func() 		 		# Вызов выбранной версии


Чтобы понять этот фрагмент обратим внимание, что def напоминает инструкцию присваивания =  т.к. она просто выполняет присваивание во время выполнения.

В отличие от С ф-ции в Питон не должны быть полностью поределены к моменту запуска программы. Т.е. инструкции def не интерпретируются, пока не будут достигнуты и выполнены потоком выполнения, а код внутри def не выполняется, пока ф-ция не будет вызвана позднее.

Важно не имя функции, а объект, на который ссылается имя:

othername = func		# Связывание объекта функции с именем
othername()				# Вызов функции

- мы связали нашу функцию с другим именем и вызвали с использованием нового имени.

Ф-ция - это обычные объекты, они явно записываются в память во время выполнения программы.

Ф-ции позволяют присвоединять любые атрибуты, с информацией, напр. для сохранения инф-ии:

def func(): ...			# Создает объект функции
func()				# Вызывает объект
func.attr = value		# Присоединяет атрибут к объекту



Первый пример: определения и вызовы. стр. 466

Напишем первый пример функции. Как видим ф-ция имеет две стороны: определение (инструкция def, которая создает ф-цию) и вызов (выражение, которое предписывает интерпретатору выполнить тело функции).


Определение.

Ф-ция times, которая возвращает рез-т обработки двух аргументов:

>>> def times(x, y):
	return x * y
...
>>> 

- когда интерпретатор достигает инструкции def и выполняет ее, он создает объект функции, в который упакует программнфый код ф-ции и свяжет объект с именем times. Как правило такие ф-ции размещаются в файлах модулей и выполняются по время импортирования, но наша небольшая и можно создать ее прямо в интерактивной оболочке.


Вызов.

После выполнения def появл-ся возможность вызвать ф-цию, добавив круглые скобки после ее имени. В скобках указ-ся аргументы:

>>> times(2, 4)			# В круглых скобках аргументы: 2 и 4
8

- имени x присваивается значение 2, а имени y - значение 4, после чего запускается тело ф-ции. В нашем случае значение возвращается инструкцией return (собственно она и есть тело нашей ф-ции).

Теперь мы можем указать, что тело функции выполняется в момент ВЫЗОВА функции.

Результат ф-ции можно присвоить переменной:  

>>> x = times(3.14, 4)
>>> x
12.56

А теперь передадим ф-ции объекты разных типов:

>>> times('Ni', 4)		# Получилась операция повторения
'NiNiNiNi'

- т.о. мы видим, что смысл ф-ции times и тип возвращаемого значения определяется аргументами, которые ей передаются.


Полиморфизм в языке Питон.

Как мы уже подчеркнули, смысл выражения x*y полностью зависит от типа объектов x и y - т.е. это может быть как умножение, так и повторение.

В Питон именно объекты определяют синтаксический смысл операции.

Такого рода зависимость от типов известна как полиморфизм - термин, означающий, что смысл операции зависит от типов обрабатываемых объектов. Фактически все операции в Питон явл-ся полиморфическими.

Т.о. одна функция может автоматически применяться к целой категории типов объектов. Если объект поддерживает ожидаемые методы и операторы выражений, он будет совместим с логикой функции.

Напр. наша ф-ция times, - любые два объекта, поддерживающие оператор *, смогут обрабатываться ф-цией times и не важно что это за объекты и когда были созданы.

Если же будут переданы объекты, НЕ поддерживающие ожидаемый интерфейс, интерпретатор автоматически возбудит исключение.

Вообще интерфейс - это набор методов и операций, которые используются функцией.

Т.о. мы видим отличие Питона от статической типизации - программный код на Питоне не делает предположений о конкретных типах данных. Вообще, при программировании на Питон во внимание принимаются интерфейсы объектов, а не типы данных.

Конечно такая модель полиморфизма предполагает необходимость тестирования кода на наличие ошибок, напр. на соответствие типов и интерфейсов и т.п. Но тестирование оно много где применяется в больших масштабах, так что это не совсем даже и недостаток.


 
Второй пример: пересечение последовательностей. стр. 469

Вспомним цикл for, который выбирал элементы, общие для двух строк. Мы его усовершенствуем, сделав функцию.


Определение.

Плюсы оформления нашего цикла в виде функции:

- Сделав код в виде ф-ции, появится возможность использовать его столько раз сколько нужно;

- Т.к. вызывающая программа может передавать ф-ции произвольные аргументы, ф-ция может использ-ся с любыми двумя последовательностями (или итерируемыми объектами) для полученяи их пересечения;

- Когда логика работы в виде ф-ции достаточно изменить код всего в одном месте, чтобы изменить способ полученяи пересечения;

- Поместив ф-цию в файл модуля, её можно импортировать и использовать в любой программе на нашем ПК.


Итак, наш код, обернутый в функцию, превращается в утилиту нахождения пересечения:

def intersect(seq1, seq2):
	res = []
	for x in seq1:
		if x in seq2:
			res.append(x)
	return res

- все понятно: имя, аргументы, тело ф-ции, return. Двигаемся дальше.


Вызов.

Мы поместили нашу ф-цию в файл и для её создания импортируем наш модуль. Как только def будет выполнена, можно будет вызывать ф-цию и передавать ей два объекта последовательностей в круглых скобках:

>>> def inter(seq1, seq2):
	res = []
	for x in seq1:
		if x in seq2:
			res.append(x)
	return res

>>> inter(s1, s2)
['S', 'A', 'M']

- Как видим я набрал функцию прямо в IDLE, хотя в книге написано, что можно создать её в модуле и импортировать его, но тут начинается самое интересное...

- Я создал файл tnt.py и импортировал его, вызвав dir(tnt) я увидел, что атрибут inter присутствует у модуля tnt, НО - при попытке вызвать ф-цию inter:

>>>inter(s1, s2)
...
NameError: name 'inter' is not defined

- я получал сообщение об ошибке "NameError: name 'inter' is not defined", не представляю с чем это связано, возможно с тем, что tnt.py расположен в моей домашней директории.

- Самое печальное то, что я не знаю как с этим бороться.

Разобрался!!!!!


Мы импортируем модуль, а потом указывая имя модуля и его аргументы мы их используем. А в нашем случае ф-ция inter() как раз явл-ся аргументом модуля tnt (как мы уже писали выше о проверке dir()) и в конечном итоге всё работает:

>>> import tnt
>>> s1 = 'spam'
>>> s2 = 'scam'
>>> tnt.inter(s1, s2)
['s', 'a', 'm']

- это рекомендованный способ использования модулей.

Или, чтобы не писать каждый раз имя модуля, используем конструкцию from import:

>>> s1 = 'spam'
>>> s2 = 'scam'

>>> from tnt import inter
>>> inter(s1, s2)
['s', 'a', 'm']

- Вот такие вот подводные камни. Но всё-таки рекомендуется использовать просто import.

Все-таки нужно повторить первую часть моих записок, а то вот уже забыл правила использования атрибутов модулей. А если бы всё это помнил, не пришлось бы целый час сидеть в инете и искать ответ на "загадочную" ошибку с импортированным модулем.

Кстати наша функция, если честно, работает слишком медленно и в принципе не особо нужна, её можно заменить единственным выражением генератора списков:

>>> [x for x in s1 if x in s2]
['S', 'A', 'M']

- но всё же это простой пример применения функций к различному диапазону типов (различных типов последовательностей).


Еще о полиморфизме. стр. 470

Как и другие ф-ции, наша inter тоже полиморфна, пример:

>>> import tnt
>>> x = tnt.inter([1, 2, 3], (1, 4))		# Смешивание типов
>>> x										# Объект с результатом
[1]

- мы передали ф-ции список и кортеж, два разных типа - и она все равно сработала!

Т.е. inter будет выполнять итерацию по объектам послетовательностей любых типов, если они поддерживают ожидаемый интерфейс.

В нашем случае для inter, это означает, что первый объект должен поддерживать циклы for, а второй - поддерживать оператор in, выполняющий проверку на вхождение.

Так наша ф-ция поддерживает любые итераторы с ожидаемымми интерфейсами, даже файлы, словари и объекты на основе классов с перегрузкой операторов.

Опять же - если объекты не поддерживают ожидаемые интерфейсы, то будет возбуждено исключение.


Локальные переменные.

Рассмотрим переменные в нашем примере, и соотв. функции.

Переменная res внутри ф-ции inter - это то, что в Питон называется - локальной переменной, - имя, которое доступно только программному коду внутри инструкции def и существует только во время выполнения ф-ции.

Фактически, любые имена, которым были присвоены какие-либо значения внутри ф-ции, по умолчанию классифицируются как локальные переменные.

Почти все имена в ф-ции inter явл-ся локальными переменными:

- Переменная res явно участвует в операции присваивания, - поэтому она локальная;

- Аргументы передаются через присваивание, - поэтому seq1 и seq2 тоже локальные переменные;

- Цикл for присваивает элементы переменной, поэтому имя х также явл-ся локальным.


Все эти локальные переменные появл-ся в момент вызова ф-ции и исчезают, когда ф-ция возвращает управление - return возвращает объект результата, а имя res исчезает.     







Глава 17. Области видимости. стр. 474
   

Области видимости в языке Питон.

Что же такое имена в Питон. Каждый раз когда в программе используется некоторое имя, интерпретатор создает, изменяет или отыскивает это имя в пространстве имен - в области, где находятся имена.

Поиск имени применительно к программному коду, под термином область видимости подразумевается пространство имен, - т.е. место в коде, где имени было присвоено значение, определяет област ьвидимости этого имени для программного кода.

Почти все, что относится к именам (в т.ч. классификацию области видимости), в Питон связано с операциями присваивания. Т.е. мы видим, что имена появляются в тот момент когда им впервые присваивается некоторое значение, и прежде чем использовать имена им нужно присвоить значение.

Т.к. имена не объявл-ся заранее, интерпретатор, по месту операции присваивания, связывает имя с конкретным пространством имен. Т.е. место, где выполняется присваивание, определяет пространство имен, в котором будет наход-ся имя, а следовательно, и область его видимости.

Также, все имена, значения которым присв-ся внутри ф-ции, ассоциируются с пространством имен этой ф-ции. Это означает что:

- Имена, определяемые внутри инструкции def, видны только коду внутри def. К этим именам нельзя обратиться за пределами ф-ции;

- Имена, определяемые внутри def, не вступают в конфликт за пределами def, даже если и там и там одинаковые имена. Например имя Х за пределами def (в др. конструкции def или на верхнем уровне модуля), полностью отлично от имени Х, которому присвоено значение внутри инструкции def.

В любом случае, область видимости переменной (где она может использ-ся) всегда определяется местом, где ей было присвоено значение, и никакого отношения не имеет к месту, откуда была вызвана функция.

Как мы узнаем далее значения переменным могут быть присвоены в трех разных местах:

- Если присваивание переменной вып-ся внутри инструкции def, переменная явл-ся локальной для этой функции;

- Если присваивание производится в пределах объемлющей инструкции def, переменная явл-ся нелокальной для этой функции;

- Если присваивание произв-ся за пределами всех инструкций def, она явл-ся глобальной для всего файла (модуля, класса и т.п.).

Это называется лексической областью видимости, т.к. видимость опред-ся местоположением переменных в текстах программы, а не местом откуда вызывается ф-ция.


Пример, где инструкция Х = 99 создает глобальную переменную Х (видима в любом месте файла), а инструкция Х = 88 создает локальную (видима тольк овнутир def):

X = 99

def func():
	X = 88
	
- и хоть имена одинаковы, конфликта не будет, т.к. область видимости делает их различными.


Правила видимости имен.

Ф-ции образуют вложенные пространства имен (области видимости), которые ограничивают доступ к используемым в них именам, т.о. имена внутри ф-ций не конфликтуют с именами за их пределами (внутри модуля или внутри др. ф-ций).

Еще раз повторим, - ф-ции образуют локальную область видимости, а модули - глобальную. Они связаны м/у стобой:

- Объемлющий модуль - это глобальная область видимости. Глобальные переменные, для внешнего мира становятся атрибутами объекта модуля, но внутри модуля исп-ся как простые переменные.

- Глобальная область видимости охватывает единственный файл. Не заблуждайтесь насчет слвоа "глобальный" - имена на верхнем уровне файла явл-ся глобальными только для программного кода в этом файле. В Питон нет понятия глобальной области видимости для всех файлов. Имена всегда относятся к какому-нибудь модулю и всегда нужно явно импортировать модуль. Если слышите "глобальный", подразумевайте "модуль".

- Каждый вызов функции создает новую локальную область видимости. Каждую инструкцию def (и lambda) можно представить как определение новой локальной области видимости. Т.к. Питон позволяет ф-циям вызывать самих себя в цикле (наз-ся - рекурсия), локальная область видимости, с технич. точки зрения соответствует вызову ф-ции - т.е. каждый вызов создает новое локальное пространство имен. Рекурсия может исп-ся для обработки данных, структура которых заранее не известна.

- Операция присваивания создает локальные имена, если они не были объявлены глобальными или нелокальными. По умолч. все имена, с присваиванием внутри ф-ции, помещаются в локальную область видимости. Если нужно присвоить значение имени верхнего уровня в модуле, который вмещает ф-цию, это имя нужно объявить внутри ф-ции глобальным с помощью инструкции global. Если нужно присвоить значение имени, наход-ся в объемлющей инструкции def, это имя нужно объявит ьвнутри ф-ции с помощью инструкции nonlocal.

- Все остальные имена явл-ся локальными в области видимости объемлющей функции, глоабльными или встроенными. Преполагается, что имена, которым не присвоены значения внутри определения ф-ции, находятся в объемлющей локальной области (внутри объемлющей инструкции def), глобальной (в пространстве имен модуля) или встроенно (предопределнные имена в модуле builtins).


Код вводимый в интерактив. оболочке подчиняется всем этим правилам, этот код находится на уровне модуля __main__ - этот модуль действует также как любой другой модуль. Т.о. имена создаваемые в оболочке также нах-ся внутри модуля.

Любые операции присваивания, выполняемые внутри ф-ции, классифицируют имена как локальные: инструкции =, import, def, передача аргументов и т.д.

Операции непосредственного изменения объектов не рассматривают имена как локальные - это свойственно только операциям присваивания. 
Например, если имени L присвоен список, определенный на верхнем уровне в модуле, то такая инструкция как L.append(Х), внутри ф-ции не будет классифицировать имя L как локальное, тогда как инструкция L = X  - будет. В первом случае происходит изменение объекта на которое указывает L, а не самого имени L - список будет найден в глобальной области видимости, как обычно, и будет изменен, без объявления имени global (или nonlocal).
Этот пример показывает различие м/у именами и объектами - т.е. видим, что операция, изменяющая объект, совсем не то, что операция присваивания объекта имени.


Разрешение имен: правило LEGB.

Три правила для def:

- Поиск имен ведется, самое большое, в четырех областях видимости: локальной, затем в объемлющей ф-ции (если она есть), затем в глобальной и, наконец, во встроенной.

- По умолч. операция присваивания создает локальные имена.

- Объявления global и nonlocal отображают имена на область видимости вмещающего модуля и ф-ции соответственно.


Все имена, присваемые значениями внутри def (или lambda), по умолч. явл-ся локальными; функции могут использ. имена в лексически объемлющих ф-циях и глобальной области, но чтобы изменять их, они должны быть объявлены нелокальными и глобальными.

Схема разрешения имен в Питон иногда наз-ся LEGB (по первым буквам областей видимости):

- Когда фнутри ф-ции идет обращение к имени, интерпретатор сначала ищет имя в локальной области (local, L), затем в локальной области объемлющей инструкции def (enclosing, E) или выражении lambda, затем в глобальной (global, G), и, наконец, во встроенной (built-in, B). Если имя так и не найдется, то появится сообщение об ошибке.  
    
- Когда внутри ф-ции выполняется операция присваивания (а не обращение к имени внутри выражения), интерпретатор всегда создает или изменяет имя в локальной области, если в этой ф-ции оно не было объявлено глобальным или нелокальным.

- Когда выполняется присваивание имени за пределеами ф-ции (на уровне модуля или в интерактив. оболочке), локальная область совпадает с глобальной - с пространством имен модуля.

Рисунок 17.1  Правило LEGB поиска имен в областях видимости. 
   
 
Отметим, что эти правила применимы только к простым переменным, типа spam. Далее в книге мы увидим, что полные имена атрибутов (как напр. object.spam) принадлежат определенным объектам и к ним применяются другие правила поиска. Поиск производится в одном или более объектах, а не областях видимости, что связано с механизмом под названием "наследование".


Пример области видимости.

>>> x = 99				# Глобальная область видимости
>>> 					# Х и func() определены в модуле: глобальная область

>>> def func(y):		# Y и Z определены в функции: локальная область 
	# Локальная область видимости
	z = x + y			# Х - глобальная переменная 
	return z

>>> func(1)				# func в модуле: вернет число 100
100	
    
- Глобальные имена: Х и func. Х - глобальное, т.к. объявлено на верхнем уровне модуля, к нему можно обращаться внутри ф-ции без дополнительных объявлений. func - глобальное по тем же причинам. Инструкция def связывает объект ф-ции с именем func на верхнем уровне модуля.

- Локальные имена: Y и Z. Имена Y и Z явл-ся локальными (и сущ-ют только во время выполнения ф-ции), потому что присваивание им осущ-ся внутри определения ф-ции.


Суть разделения в том, что локальные переменные играют роль временных имен, на время вызова ф-ции.

Разделение имен на глобал. и локал. облегчает понимание ф-ций, т.к. большинство имен, используемых в ф-ции, появл-ся непосредственно в самой ф-ции, а не в произвольном месте модуля. Также мы будем уверены, что локал. имена не изменятся где-то в другом месте программы.


Встроенная область видимости.

Встроенная облатсь видимости - это всего лишь встроенный модуль с именем builtins, но чтобы использовать это имя необходимо импортировать этот модуль, потому что само имя builtins не явл-ся встроенным.

Такой вот парадокс, встроенная область реализована как модул ьстандартной библиотеки с именем builtins, но само имя не находится во встроенной области, поэтому чтобы исследовать его нужно импортировать.

>>> import builtins
>>> dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 
... множество других имен пропущено, их очень много...
, 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
>>>     

Имена в этом списке стоставляют встроенную област ьвидимости языка Питон. Примерно первая половина - это встроенные исключения, а вторая - встроенные функции.

Согласно правилу LEGB интерпретатор выполняет поиск в этом модуле в последнюю очередь. Все имена из этого списка мы получаем в свое распоряжение по умолч., чтобы их использ. не требуется импортировать какие-то модули. 
Поэтому ест ьдва способа вызова встроенной функции:

>>> zip					# Обычный способ
<class 'zip'>

>>> import builtins		# Более сложный способ
>>> builtins.zip
<class 'zip'>

- второй способ иногда удобен при выполнении сложных действий.

Согласно правилу LEGB, как только будет найдено подходящее имя поиск прекращается, отсюда следует, что имена в локальной области могут переопределять переменные с такими же именами как в глобальной, так и во встроенной области, а глоабльные имена могут переопределять имена во встроенной области.

Напр. внутри ф-ции можно создать переменую open:

def hider():
		open = 'spam'			# Локальная переменная, переопределяет встроенное имя
		...
		open('data.txt')		# В этой области видимости файл не будет открыт

Однако, в результате этого встроенная ф-ция с именем open, которая располагается во встроенной (внешней) области видимости, окажется скрытой.
Обычно это считается ошибкой, но неприятность в том, что Питон не сообщит об ошибке, ведь технически переопределение возможно.


Таким же способом ф-ции могут переопределять имена глобальных переменных:

X = 88				# Глобальная переменная Х

def func():
	X = 99			# Локальная переменная Х: переопределяет глобальную
	
func()
print(X)			# Выведет 88: значение не изменилось

- без объявления global (или nonlocal) в инструкции def, нельзя изменить переменную, расположенную за пределами ф-ции.		


Примечание.

Касательно различий м/у 2.6 и 3.0. В 2.6 builtins наз-ся __builtin__. В большинстве глобальных областей присутствует имя __builtins__ ссылающееся на имя builtins.

В 3.0 выражение __builtins__ is builtins вернет True, а в 2.6 значение True вернет выражение  __builtins__ is __builtin__. Т.е. мы можем исследовать встроенную область с помощью вызова dir(__builtins__) в обеих версиях, не импортируя модуль.

Однако в программах 3.0 рекомендуется использ. модуль builtins.


Как испортить себе жизнь в Питон 2.6

В 2.6 имена True и False всего лишь переменные во встроенной области. Их можно переопределить инструкцией True = False. Эта инструкция всего лишь переопределит True в единственной области видимости, остальные области будут использовать оригинал из встроенной (норм. вида).

А можно написать __builtins__.True = False и истина станет ложью для всей программы! В 3.0 такие фокусы ликвидировали, там эти слова зарезервированы.


Инструкция global.

global и nonlocal - единственные инструкции в Питон, напоминающие инструкции объявления. Они не объявляют тип или размер - они объявляют пространства имен.

global сообщает интерпретатору, что ф-ция будет изменять одно или более глобал. имен.

- Глобальные имена - имена, котороые определены на верхнем уровне вмещающего модуля.

- Глобальные имена должны объявляться, только если им будут присваиваться значения внутри ф-ции.

- Обращаться к глобальным именам внутри ф-ции можно и без объявления их глобальными.


global изменяет переменные, нах-ся на верхнем уровен модуля, за пределами def. nonlocal применяется к именам в локальных областях объемлющих инструкций def.

Записывается ключевое слово global и за ним одно или более имен, через запятую, которые будут отображены на област ьвидимости вмещающего модуля при обращении к ним или при присваивании внутри ф-ции:

X = 88				# Глобальная переменная Х

def func():
	global X
	X = 99			# Глобальная переменная Х: за пределами инструкции def
	
func()
print(X)			# Выведет 99: значение не изменилось  

- после объявления global имя Х внутри инструкции def ссылается на переменную Х за её пределами. Т.е. теперь оба имени ссылаются на одну переменную.

Более слодный пример:

y, z = 1, 2				# Глобальные переменные в модуле

def all_global():
	global x			# Объявляется глобальной для присваивания
	x = y + z			# Объявлять y и z не нужно: применяется правило LEGB
	
- Здесь x, y, z используемые внутри all_global() явл-ся глобальными. y, z считаются глобальными потому, что внутри ф-ции им не присваивается значение. х глоабльная потому что перечислена в инструкции global. Без инструкции global переменная х была бы локальной.

Внимание! y и z не были объявлены как глобальные, но следуя правилу LEGB, интерпретатор автоматически отыщет их в области видимости модуля.
Кроме того переменная х может не существовать в модуле в момент вызова ф-ции, присваивание создаст эту переменную.


Минимизируйте количество глобальных переменных.

Использование локальных переменных - это наиболее правильное решение. Изменение  же глобальных переменных может привести к известным проблемам: когда значения переменных зависят от порядка, в котором вызываются функции, что осложняет отладку программы (или поиск причины ошибки).

Пример:

X = 99

def func1():
	global X
	X = 88
		
def func2():
	global X
	X = 77
	
- При применении этих двух функций значение Х будет зависеть от выбранного момента времени, т.к. будет зависеть от того какая ф-ция вызывалась последней.

Т.е. 88 или 77 - придется смотреть ВЕСЬ ход выполнения программы и при изменении модуля также придется держать в голове ВСЮ программу.

Это значительная проблема глобальных переменных.

С другой стороны, кроме случаев ООП и классов, глобал. переменные это один из самых удобных способов хранить информацию о состоянии (информация, которую нужно хранить между вызовами ф-ций), т.к. локал. переменные исчезают, а глобальные нет.
Можно использ. другие приемы для этого, но глобал. переменные для этого гораздо проще.

Также глобальные переменные можно хранить в одном глобальном модуле и использовать в многопоточных режимах, в роли памяти.

А пока лучше избегать глобальных переменных, старайтесь организовывать обмен данными через параметры и возвращаемые значения.


Минимизируйте количество изменений в соседних файлах. стр. 484

Несмотря на то, что можно непосредственно изменять переменные в другом файле, этого следует избегать. 
  
Рассмотрим два модуля:

# first.py
X = 99				# Этот программный код ничег оне знает о существовании second.py

# second.py
import first
print(first.X)		# Ничего плохого нет, чтобы обратиться к имени в др. файле

first.X = 88		# Но изменение может привести к сложностям
	
- первый модуль определяет Х=99, второй импортирует первый модуль, чтобы использовать его переменную и затем присвоить ей новое значение. 

Импортирование модуля для использ-я его переменных - это обязательное условие, т.к. каждый модуль обладает своим персональным пространством имен.

Т.о. глобальная облась модуля, после импорта, превращается в пространство имен атрибутов объекта модуля - импортирующий модуль при этом получает доступ к глобал. импортируемого модуля.

В целом нет ничего плохого такого обращения к переменным, тем более технич. возможно оно. Но такая тесная зависимость модулей, в лучшем случае приводит к снижению гибкости программы, а в худшем - к ошибкам.

Достаточно трудно держать такие свзяи в голове, а если модули кодируют разные программисты то вообще будет путаница.

В таких случаях свзяь м/у модулями лучше делать через вызовы функций, передавая им аргументы и получая возвращаемые значения:

# first.py
X = 99				# Этот программный код ничег оне знает о существовании second.py

def setX(new):
	global X
	X = new

# second.py
import first
first.setX(88)


Даже тот кто будет в первый раз читать код, поймет, что ф-ция setX - это часть интерфейса модуля, и поймет, что переменная Х может изменяться.
Эта ф-ция устраняет элемент неожиданности, который был в первом примере.

Мы не можем совсем отказаться от изменений в соседних файлах, но нужно свести их к минимуму и тщательно следить за этим.


Другие способы доступа к глобальным переменным.

Перевод глобал. переменных в атрибуты объекта модуля позволяет имитировать инструкцию global, импортируя вмещающий модуль и выполняя присваивание его атрибутам.

Пример: код нашего файла в одном случае импортирует вмещающий модуль по имени, в другом использ. таблицу загруженных модулей sys.modules:

#tnt.py

var = 99					# Глобальная переменная == атрибут модуля

def local():
	var = 0				# Здесь изменяется локальная переменная

def glob1():
	global var			# Глобальное объявление (обычное объявление)
	var += 1			# Изменяем глоабльную переменную var, теперь var = 100

def glob2():
	var = 0				# Здесь изменяется локальная переменная
	import tnt			# Модуль tnt импортирует сам себя 
	tnt.var += 1		# Благодаря импорту мы можем изменить глоабльную переменную, var = 101
	
def glob3():
	var = 0				# Здесь изменяется локальная переменная
	import sys						# Импорт системной таблицы
	glob = sys.modules['tnt']		# Получить объект модуля (или использ. __name__)

	glob.var += 1				# Изменяется глобальная переменная, теперь var=102	
	
def test():
	print(var)
	local(); glob1(); glob2(); glob3()
	print(var) 

Рассмотрим работу наших ф-ций и затем сделаем важные замечания:

>>> import tnt
>>> tnt.test()
99
102
>>> tnt.var
102

- все данные правильные, как в книге. 	
	
  
Замечание!!! Опишу выявленные мной особенности этого примера.

В книге, в ф-ции glob2 последняя стркоа была другая:

def glob2():
	var = 0
	import tnt
	glob.var += 1
   
- при этом я получал вывод 99 и сразу сообщение об ошибке:

>>> import tnt
>>> tnt.test()
99
Traceback (most recent call last):
  File "<pyshell#4>", line 1, in <module>
    tnt.test()
  File "C:\Python34\tnt.py", line 26, in test
    local(); glob1(); glob2(); glob3()
  File "C:\Python34\tnt.py", line 15, in glob2
    glob.var += 1
NameError: name 'glob' is not defined

Почитав код я заменил glob на tnt и всё заработало! Удивительно, но факт. И либо в программе ошибка, либо у меня всё работает, но как-то по-другому чем у автора книги. 
Но думаю, что я всё правильно исправил,	т.к. вывод работы программы верный.

В этом примере мы написали много кода, такие способы дают больше кода чем могло быть при сипольз. global.

Т.о. знаем, что global дает возможность изменения переменных в модуле из ф-ций. nonlocal обеспечивает изменение переменных в объемлющих ф-циях и для её изучения мы приступим к вложенным ф-циям.



Области видимости и вложенные функции. стр. 487

С вложенными областями сталкиваются достаточно редко, но мы изучим их.

Иногда объемлющие области видимости называют статически вложенными областями видимости. На самом деле вложение явл-ся лексическими - вложенные области соотв-т физически вложенным блокам программного кода в исходных текстах программы.  


Вложенные области видимости.

Внутри функции:

- Поиск имени Х сначала идет в локальной области (внутри самой ф-ции); затем в локальных областях всех объемлющих ф-ций (изнутри наружу); затем в текущей глоабльной области (в модуле), и, наконец, во встроенной области (модуль builtins). Поиск имен, объявленных в global, начинается сразу в глоабльной области видимости.

- Присваивание (X = value) по умолч. создает или изменяет имя Х в текущей локал. области. Если Х объявлено глоабльным внутир ф-ции, присв-ие создает или изменяет Х в области видимости объемлющего модуля. Если Х объявлено нелокальным внутри ф-ции, присв-ие создает или изменяет имя Х в ближ. области видимости объемлющей ф-ции.

global отображает имена в область видимости объемлющего модуля. Если есть влож. ф-ции можно получить значения переменных в объемл. ф-циях, но чтобы их изменить, переменные должны быть указаны в объявлении nonlocal.


Прмиеры вложенных областей видимости.

X = 99				# Имя в глоабл. области видимости: не используется

def f1():
	X = 88			# Локальное имя в объемлющей ф-ции
	def f2():
		print(X)	# Обращение к переменной во вложенной ф-ции
	f2()

f1()				# Выведет 88: локальная переменная в объемлющей ф-ции 


- В этом примере вложенная инструкция def исполняется в момент вызова ф-ции f1 - она создает ф-цию и связывает её с именем f2, которое явл-ся локалбным и  размещается в локал. области видимости ф-ции f1.

Неким образом f2 - это временная ф-ция, которая существует только во время работы (и видима только для программного кода) объемлющей ф-ции f1.

Внутри f2 - когда происходит вывод Х, она ссылается на переменную Х в локал. области объемлющей ф-ции f1. Ф-ции могут обращаться к именам, котореы физически располагаются в любых объемлющих инструкциях def, и имя Х в f2 автоматом отображается на имя Х в f1, по правилам LEGB.

Это правило работает даже если объемлющая ф-ция уже вернула управление:

def f1():
	X = 88
	def f2():
		print(X)		# Сохраняет значение Х в объемлющей области
	return f2			# Возвращает f2, но не вызывает её 

action = f1()			# Создает и возвращает ф-цию
action()				# Вызов этой ф-ции: выведет 88

- при вызове action запускается ф-ция, созданная во время выполнения ф-ции f1. Ф-ция f2 помнит переменную Х в области объемлющей ф-ции f1, которая уже неактивна.


Фабричные функции.

Замыкание или фабричная функция - под этим подразумевается объект ф-ции, который сохраняет значения в объемлющих областях видимости, даже когда эти области прекращают сущ-ие.

Классы лучше подходят для сохранения состояния, а эти функции просто альтернатива.

Пример, фабрич. ф-ции использ-ся когда нужно создавать обработчики событий прямо в процессе выполнения в соответствии с условиями (например нужно запретить пользователю вводить данные).

Пример:

>>> def maker(N):
		def action(X):			# Создать и вернуть функцию
			return X ** N		# Ф-ция action запоминает значение n в объемлющей 
		return action			# области видимости
		
- здесь определяется внешняя ф-ция, которая создает и возвращает вложенную, не вызывая её.

>>> f = maker(2)
>>> f
<function maker.<locals>.action at 0x0227A618>

- если вызвать maker она просто вернет ссылку на вложенную ф-цию.

А теперь вызовем то, что было получено от maker:

>>> f(3)			# Запишет 3 в X, в N по-прежнему хранится 2 
9
>>> f(4)
16 

- при этом была вызвана вложенная внутри maker ф-ция action.

Интересно то, что вложенная ф-ция хранит число 2, значение N в maker, даже при том, что ф-ция maker уже завершила свою работу.

На самом деле имя N из объемлющей локальной области сохр-ся как инф. о состоянии, присоединенная к action, и мы получаем обратно значение аргумента, возведенное в степень N (в нашем случае - в квадрат).

Если снова вызвать maker (внеш. ф-цию), получим новую фложенную ф-цию уже с др. инф. о состоянии, присоединенной к ней - и будет вычислятьтся куб, а ранее сохраненная ф-ция по-прежнему будет возвращать квадрат аргумента:

>>> g = maker(3)		# ф-ция g хранит число 3, а f - число 2
>>> g(3)		# куб аргумента
27
>>> f(3)		# квадрат аргумента
9
>>>

Этот прием распространен среди программистов работающих с функциональными ЯП.

Объемлющие области мы встретим позднее, в выражениях lambda. Также прием вложения ф-ций обычно использ. при разработке декораторов.

Вообще, классы  лучше подходят на роль "памяти". Также есть еще глобальные переменные, объемлющие области (текущая часть главы), и аргументы по умолчанию.


Сохранение состояния объемлющей области видимости с помощью аргументов по умолчанию. 

def f1():
	x = 88
	def f2(x = x):		# Сохраняет значение переменной х в объемлющей области
		print(x)		# в виде аргумента
	f2()
		
f1()			# Выведет 88


Конструкция arg = val в заголовке инструкции def означает, что аргумент arg по умолч. будет иметь значение val, если ф-ции не передается какого-либо другого значения.

Т.о. в нашем примере х по умолч. будет равен х в объемлющей области видимости.  

всё это сложно и зависит от вычисления значения по умолч. Поэтому сейчас в Питон автоматическое сохранение любых значений в объемлющей области, для использ. во вложенных def.

Наилучшая рекомендация, это, конечно, стараться избегать вложенных инструкций def, если это возможно.

Рассмотрим пример:

>>> def f1():
	x = 88
	f2(x)
	
>>> def f2(x):
	print(x)
	
>>> f1()
88

- Допустимо вызывать ф-цию (f2), определение которой в тексте программы нах-ся ниже ф-ции откуда производится вызов (f1), при условии, что вторая инструкция def (f2) будет исполнена до того, как первая ф-ция попытается вызвать её.


Вложенные области видимости и lambda-выражения.

lambda-выражение генерирует новую ф-цию, которая будет вызываться позднее, и оно похоже на инструкцию def.

Т.к. lambda это выражение оно может использоваться там где нельзя использ. def, например в литералах списков и словарей.

lambda также порождает локальную область видимости (как и def). lambda могут обращаться ко всем переменным, которые присутствуют в ф-циях, где находятся эти выражения.

def func():
	x = 4
	action = (lambda n: x ** n)		# запоминается х из объемлющей инструкции def
	return action

x = func()
print(x(2))			# Выведет 16 (4 ** 2)


Аналог этого примера:

def func():
	x = 4
	action = (lambda n, x=x: x ** n)		# Передача х вручную
	return action

Т.к. lambda это выражение, то они обычно вкладываются в инструкции def.


Области видимости и значения по умолчанию применительно к переменным цикла. 

Исключение: если lambda-выражение или def вложены в цикл внутри др. ф-ции и влож. ф-ция ссылается на переменную из объемлющей области видимости, которая изм-ся в цикле, все ф-ции, созданные в этом цикле, будут иметь одно и то же значение - значение, которое имела переменная на последней итерации.

Пример, пытемся создать список ф-ций, каждая из которых запоминает текущее значение переменной i и объемлющей области:

>>> def makeActions():
	acts = []
	for i in range(5):					# Сохранить каждое значение i
		acts.append(lambda x: i ** x)	# Все запомнят последнее значение i
	return acts

>>> acts = makeActions()
>>> acts[0]
<function makeActions.<locals>.<lambda> at 0x01707AE0>
	
- Но желаемый результат мы не получим, потому что поиск переменной в объемлющей области производится позднее, при вызове влож. ф-ций, в рез-те все они получат одно и то же значение (значение, которое переменная имела на последней итерации). Т.е. каждая ф-ция в списке будет возвращать 4 во второй степени, потому что во всех них переменная i имеет одно значение:

>>> acts[0](2)		# Все возвращают 4 ** 2, последнее значение i
16
>>> acts[2](2)		# хотя должно быть 2 ** 2
16
>>> acts[3](2)		# или 3 ** 2
16

В таком случае нужно явно сохранять значение из объемлющей области в виде аргумента со значением по умолч. Т.е. нужно передать текущее значение из объемлющей области в виде значения по умолчанию, которое вычисл-ся в момент создания вложенной ф-ции (а не когда она вызывается):

>>> def makeActions():
	acts = []
	for i in range(5):							# использовать значения по умолчанию
		acts.append(lambda x, i=i: i ** x)		# Сохранить текущее значение i
	return acts

>>> acts = makeActions()
>>> acts[0](2)
0
>>> acts[2](2)
4
>>> acts[3](2)
9

С подобным случаем можно столкнуться на практике, напр. в коде который генерирует функции-обработчики событий для элементов управления в графич. интерфейсе (нажатие кнопок напр.).


Произвольное вложение областей видимости.

Области видимости могут вкладываться произвольно, но поиск будет идти только в объемлющих ф-циях:

>>> def f1():
		x = 99
		def f2():
			def f3():
				print(x)		# Будет найдена в области видимости f1 !
			f3()
		f2()
	
>>> f1()
99

Интерпретатор будет искать переменную в локальных областях всех объемлющих инструкций def, от внутр. к внеш., выше локал. и ниже глобал. области модуля.

Но на практике считается, что плоское лучше вложенного - лучше будет если вы сведете к минимуму количество вложенных определений ф-ций.



Инструкция nonlocal. стр. 494

nonlocal позволяет влож. ф-циям не только читать, но и изменять значения переменных в областях видимости объемлющих ф-ций.

nonlocal объявляет имена, которые будут изменяться в теле ф-ции и которые находятся в объемлющей области видимости. Отличие в том, что nonlocal применяется только к областям объемлющих ф-ций и не трогает глобал. область модуля.

Имена, перечисленные в nonlocal, должны фактическ исуществовать в области видимости, вмещающей ф-цию, где встречается это объявление - они могут сущ-ть только в объемлющей области и не могут быть созданы первой инструкцией присваивания влож. ф-ции.

Т.е. nonlocal позволяет присваивать значения переменным в объемлющих областях и ограничивает поиск таких имен областями видимости объемлющих ф-ций.


Основы использования инструкции nonlocal.

def func():
	nonlocal name1, name2, ...

- nonlocal дает влож. ф-ции возможность присваивать именам (name1, name2) новые значения.

Т.о. для влож. ф-ций есть возможность поддерживать доступную для изменения информацию о состоянии, которая восстанавливается при последующих вызовах влож. ф-ции.

Также nonlocal вынуждает интерпретатор начинать поиск с областей видимости объемлющих ф-ций, пропуская локальную область видимости ф-ций. Т.е. nonlocal означает: - пропустить локальную область при поиске имен.

На практике, имена, которые в nonlocal, должны быть определены в объемлющих ф-циях к моменту, когда поток управления достигнет nonlocal, иначе буде тошибка.

nonlocal более строгая чем global, - она ограничивает область поиска тольк ообластями видимости объемлющих ф-ций.

Основное назначение nonlocal - не тольк ополучать, но и изменять значения переменных в объемлющих областях.
	
- global вынуждает интерпретатор начинать поиск с области объемлющего модуля и позволяет присваивать переменным новые значения. Поиск идет вплоть до встроенной области видимости.

- nonlocal ограничивает поиск областями видимости объемлющих ф-ций, и требует, чтобы имена, которые в nonlocal, уже существовали и может присваивать значения. В область поиска не входят глобал. и встроенная области видимости. 

В Питон 2.6 нельзя присвоить новые значения, для этого использ-ся классы.


Инструкция nonlocal в действии.

Ф-ция tester создает и возвращает влож. ф-цию nested. Обращение к переменной state из влож. ф-ции отображается на локал. област ьвидимости ф-ции tester, с применением обычных правил поиска:

>>> def tester(start):
		state = start				# Обращение к нелокальным переменным
		def nested(label):			# действует как обычно 
			print(label, state)		# Извлекает значение state из области
		return nested				# видимости объемлющей ф-ции

>>> F = tester(0)
>>> F('spam')
spam 0
>>> F('ham')
ham 0


По умолч. изменение перемененной в объемлющей области видимости не допускается:

>>> def tester(start):
	state = start
	def nested(label):
		print(label, state)
		state += 1				# По умолчанию не изменяется
	return nested

>>> F = tester(0)
>>> F('spam')
...
UnboundLocalError: local variable 'state' referenced before assignment


Использование nonlocal для изменения переменных. 

Если теперь state, локальную для tester, объявить в nested с помощью nonlocal, мы сможем изменять её внутри nested.

>>> def tester(start):
		state = start				# В каждом вызове сохраняется своё значение state
		def nested(label):
			nonlocal state			# Объект state находится в объемлющей области
			print(label, state)
			state += 1				# Изменит значение переменной, объявленной как nonlocal
		return nested

>>> F = tester(0)		# start = state = 0

>>> F('spam')			# label = 'spam' и будет увеличивать state при каждом вызове
spam 0
>>> F('spam')
spam 1
>>> F('spam')
spam 2 

При каждом отдельном вызове tester будет создаваться отдельная копия переменной state.

Т.о. объект state, фактич. прикрепляется к возвращаемому объекту ф-ции nested - каждый вызов tester создает новый, независимый объект state, т.е. изменение state в одной ф-ции не будет вляить на другие. Пример ниже:

>>> G = tester(42)			# новая функция с новой переменной state
>>> G('spam')
spam 42
>>> G('eggs')
eggs 43
>>> F('bacon')			# ну в ф-ции F state прежнее
bacon 3


Граничные случаи.

Первый момент - в отличии от имен в global, имена в nonlocal к моменту объявления уже должны существовать в области видимости объемлющей ф-ции, иначе - ошибка:

>>> def tester(start):
		def nested(label):
			nonlocal state			# Нелокальные переменные должны существовать
			print(label, state)
			state += 1
		return nested
...
SyntaxError: no binding for nonlocal 'state' found
>>>

>>> def tester(start):
	def nested(label):
		global state			# Глобальные переменные могут отсутствовать
		state = 0				# Создаст переменную в области видимости модуля
		print(label, state)
	return nested
...
>>> 
>>> F = tester(0)
>>> F('abc')
abc 0
>>> state
0

Второй момент - nonlocal огранивает область поиска имен только областями видимости объемлющих ф-ций - поиск нелокальных переменных не производится за пределами инструкции def ни в глобал. области модуля, ни во встроенной области, даже если переменные с такими именами там есть:

>>> spam = 99
>>> def tester():
		def nested():
			nonlocal spam				# Переменная должна быть внутри def, а не в модуле!
			print('Current=', spam)
			spam += 1
		return nested
...
SyntaxError: no binding for nonlocal 'spam' found


Именно из-за подобных случаев, во избежание путаницы, интерпретатор вынужден определять местоположение нелокальных имен в момент создания ф-ции, а не в момент её вызова.


Как следует использовать инструкцию nonlocal?

Основное - это решение проблем с сохранением информации с переменными в областях видимости объемлющих функций, напр. между вызовами ф-ций и методов.

Помним пример, где вызов ф-ции tester создает самостоятельный пакет информации, доступной для изменения, и где нет конфликта имен:

>>> def tester(start):
	state = start
	def nested(label):
		nonlocal state
		print(label, state)
		state += 1
	return nested

>>> F = tester(0)
>>> F('spam')
spam 0 

Этот код будет работать только в Питон 3.0, для 2.6 нужны другие способы.


Сохранение информации в глобальных переменных.

В 2.6 и ранее, для предыдущего эффекта достаточно переместить переменную state в глобал. область видимости (область видимости модуля):

>>> def tester(start):
	global state				# Переместить в область видимости модуля
	state = start
	def nested(label):
		global state
		print(label, state)
		state += 1
	return nested

>>> F = tester(0)
>>> F('spam')
spam 0
>>> F('eggs')
eggs 1 

Но здесь возникают некоторые ограничения. Глобальные переменные могут привести к конфликтам имен (это одна из ошибок при использ-ии глобал. переменных), также этот способ создает только одну копию информации о состоянии - если вызовем tester еще раз, то прежнее значение state будет сброшено в исходное состояние, т.е. предыдущие изменения будут затерты:

>>> G = tester(42)		# Сбрасывает значение единств. копии state в глобал. области
>>> G('toast')
toast 42
>>> G('bacon')
bacon 43
>>> F('ham')			# Значение state = 0 для F было затерто!
ham 44


Сохранение информации с помощью классов (предварительное знакомство).

Взглянем на комбинацию ф-ций tester/nested как на класс - информация о состоянии может быть записана в объекты явно, после их создания.

Нужно знать, что инструкция def внутри инструкции class действует точно так же, как и за её пределами. За исключением того, что ф-ция, определяемая внутри класса, автоматически получает аргумент self, ссылающийся на объект, относительно которого был сделан вызов (экземпляр класса, или объект, создается обращением к имени самого класса как к ф-ции):

>>> class tester:
	def __init__(self, start):			# Конструктор объекта,
		self.state = start				# сохранение информации в новом объекте
	def nested(self, label):
		print(label, self.state)		# Явное обращение к информации
		self.state += 1					# Изменения всегда допустимы

>>> F = tester(0)			# Создаст экземпляр класса, вызовет __init__
>>> F.nested('spam')		# Ссылка на F будет передана в аргументе self 
spam 0
>>> F.nested('ham')
ham 1
>>> G = tester(42)			# Каждый экземпляр получает свою копию информации
>>> G.nested('toast')		# Изменения в одном объекте не сказываются на других
toast 42
>>> G.nested('bacon')
bacon 43
>>> F.nested('eggs')		# В объекте F сохранилась прежняя информация
eggs 2
>>> F.state				# Информация может быть получена за пределами класса
3

Можно перегрузить операторы. Если к экземпляру класса обратиться как к функции, то будет вызван метод __call__. Т.о. мы уберем необходимость вызова именованного метода:

>>> class tester:
	def __init__(self, start):
		self.state = start
	def __call__(self, label):			# Вызывается при вызове экземпляра
		print(label, self.state)		# поэтому нет необходимости в методе .nested()
		self.state += 1
		
>>> H = tester(99)
>>> H('juice')
juice 99
>>> H('capkuke')
capkuke 100

Несмотря на то, что классы отличный способ хранения информации, они могут оказаться слишком тяжеловесными для простых случаев. А вложенные инструкции def, в некоторых случаях, могут быть даже быстрее классов.


Сохранение информации в атрибутах функций. 

Добьемся эффекта nonlocal с помощью атрибутов функции - эти атрибуты, определяемые пользователем, присоединяются непосредственно к функции.

>>> def tester(start):
		def nested(label):
			print(label, nested.state)		# nested - объемлющая область видимости
			nested.state += 1			# Изменит атрибут, а не значение имени nested
		nested.state = start		# Инициализация после создания ф-ции
		return nested

>>> F = tester(0)
>>> F('spam')					# F - это функция 'nested'
spam 0							# с присоединенным атрибутом state
>>> F('ham')
ham 1
>>> F.state					# Атрибут state доступен за пределами ф-ции
2
>>> 
>>> G = tester(42)			# G имеет собственный атрибут state,
>>> G('eggs')				# отличный от одноименного атрибута ф-ции F
eggs 42
>>> F('ham')
ham 2

Этот пример опирается на тот факт, что имя nested явл-ся локал. переменной в области видимости ф-ции tester, включающей имя nested, - на это имя можно ссылаться и внутри ф-ции nested.

Также здесь использ-ся факт, что изменение самого объекта не явл-ся операцией присваивания.


Задания по главе. стр. 502








Глава 18. Аргументы. стр. 505

Здесь мы рассмотрим концепции Питон, связанные с передачей аргументов - способом передачи объект в функции. 

Передача аргументов. 

Передача аргументов производится посредством операции присваивания. Приведем нескольк оважных замечаний:

- Аргументы передаются через автоматическое присваивание объектов локальным переменным. Аргументы ф-ции - ссылки на объекты, которые (возможно) использ-ся совместно с вызывающей программой, - это разновидность присваивания. Объекты, которые перед-ся в виде аргументов, никогда не копируются автоматически. 

- Операция присваивания именам аргументов внутри функции не оказывает влияния на вызывающую программу. При вызове ф-ции, имена аргументов становятся локал. именами в области видимости ф-ции. 

- Изменение внутри ф-ции аргумента, который явл-ся изменяемым объектов, может оказывать влияние на вызывающую программу. Т.е. ф-ции могут воздействовать на полученные, в качестве аргументов,  изменяемые объекты.

Т.о. всё, что касается ссылок относится и к аргументам.

Схема передачи аргументов в Питон (похожа на С):

- Неизменяемые объекты передаются "по значению". Напр. строки, числа, передаются в виде ссылок на объекты, а не в виде копий объектов. Но это очень напоминает копирование.

- Изменяемые объекты передаются "по указателю". Напр. списки, словари также передаются в виде ссылок на объекты. Изменяемые объекты могу тподвергаться изменению внутри ф-ций.


Аргументы и разделяемые ссылки. 

>>> def f(a):		# Имени а присваивается переданный объект
	a = 99			# Изменяется только локальная переменная
...
	
>>> b = 88
>>> f(b)		# Первоначально, имена a и b ссылаются на одно и то же число 88
>>> print(b)	# Переменная b не изменилась 	
88

- в момент вызова f(b) перем. а присваивается объект 88, но а сущ-ет только внутри вызванной ф-ции и, изменение а внутри ф-ции, не оказывает влияние на коружение откуда вызвана ф-ция.

Этот пример и есть - "не является совмещением имен", а = 99 внутри ф-ции, не изменяет переменные, находящиеся в области видимости программного кода, вызывающего ф-цию.

Рассмотрим случай, когда аргументам передаются изменяемые объекты, с ними всё сложнее, здесь может быть изменение в вызывающей программе:

>>> def changer(a, b):
	a = 2					# Изменяется только значение локального имени
	b[0] = 'spam'			# Изменяется непосредственно разделяемый объект
...
	
>>> X = 1
>>> L = [1, 2]			# Вызывающая программа
>>> changer(X, L)		# Передаются изменяемый и неизменяемый объект
>>> X, L
(1, ['spam', 2])		# Как видим Х не изменился, L - изменился
>>>    

- первая операция присваивания изменяет только локальную переменную а, записывая в неё ссылку на совершенно другой объект, и не изменяет Х в вызывающей программе;
- b тоже локальная переменая, но в ней передается изменяемый объект, и поскольку, в этом случае, операция присваивания воздействует непосредственно на сам объект, то изменяется объект в вызывающей программе.

На самом деле изменяется не сам объект b, а часть объекта, на который ссылается аргумент b. И этот объхект изменяется потмоу что он продолжает существовать даже после завершения ф-ции.

Рисунок 8.1 Иллюстрирует связи имя/объект, которые имеют место непосредственно сразу после вызова ф-ции, но перед тем как будет запущено её тело.

Вообще аргументы и ссылки, изученные нами ранее, тесно связаны.
>>> x = 1
>>> a = x			# Разделяют один и тот же объект
>>> a = 2			# Изменяется только 'а', 'x' остается равным 1
>>> print(x)
1

>>> L = [1, 2]
>>> b = L				# Разделяют один и тот же объект
>>> b[0] = 'spam'		# Изменяется и сам L
>>> print(L)
['spam', 2]




Как избежать воздействий на изменяемые аргументы.

В Питон аргументы передаются в ф-ции по ссылкам, это и нужно, чаще всего. Т.е. так мы можем не создавать многие копии объектов.

А для избегания воздействий на вызывающую программу, как в предыдущих примерах, мы можем просто явно копировать объекты (см. гл. 6):

L = [1, 2]
changer(X, L[:])		# Передается копия, поэтому L не изменится

Моно сделать передачу копии пряом в ф-ции:

def changer(a, b):
	b = b[:]			# Входной список копируется, что исключает воздействие
						# на вызывающую программу 
	a = 2
	b[0] = 'spam'		# Изменится только копия списка

Чтобы действительно предотвратить изменения можно преобразовать изменяемые объекты в неизменяемые:

L = [1, 2]
changer(X, tuple(L))	# Передается кортеж (преобразуется объект последоватльности в кортеж), 
						# попытка изменения кортежа возбудит исключение

- однако такое решение накладывает на ф-цию ограничения (вдруг мы хотим не изменить список ,а применить другие методы, которые неприменимы к кортежам).

И вообще, такая особенность ф-ций не всегда плохо или ошибка, возможно мы специально хотим изменять изменяемые объекты и такой способ удобен.

Просто помните о том, что ф-ции могут изменять изменяемые объекты в вызывающей программе и следите за своим кодом внимательно.


Имитация выходных параметров.

Инструкция return может возвращать сразу неск-ко значений, упаковав их в кортеж или др. коллекцию. В Питон мы можем имитировать такое понятие из др. ЯП как - "передача аргументов по ссылке":

>>> def multiplex(x, y):
		x = 2				# Изменяется только локальное имя
		y = [3, 4]
		return x, y			# Новые значения возвр-ся в виде кортежа

>>> X = 1
>>> L = [1, 2]
>>> X, L = multiplex(X, L)		# Результаты присваиваются именам
>>> X, L						# в вызывающей программе
(2, [3, 4])
						
Выглядит как-будто ф-ция возвращает два значения, а на самом деле это один кортеж из двух элементов.


Распаковывание аргументов в Питон 2.Х

Ф-ции, объявленной как:

def f((a, (b, c))) :

- можно передать кортежи, соответствующие ожидаемой структуре. Т.е. вызвать f((1, (2, 3))) и a, b, c присваиваются значения 1, 2, 3.

В Питон 3.0 такая форма не поддерживается. Нужно делать так:

def f(T): (a, (b, c)) = T



Специальные режимы сопоставления аргументов. стр. 511

Аргументы всегда передаются через присваивание. Однако есть доп. возможности для создания дополнительных способов, которыми объекты аргументов сопоставляются с именами аргументов в заголовке ф-ции.

По умолч. сопоставление происходит в соотв-ии с позициями аргументов, слева направо, и аргументов должно быть столько сколько имен указано в заголовке ф-ции.

И сейчас мы познакомимся с другими способами.


Основы.

Эти спец. режимы не явл-ся обязательными и имеют отношение только к сопоставлению объектов и имен, основной механизм передачи аргументов по-прежнему это присваивание.

Фактически некоторые режимы нужны для разработчиков библиотек, а не приложений, но мы должны с ними ознакомиться:

- Спосоставление по позиции: значения и имена ставятся в соответствие по порядку, слева направо. Вообще это режим по умолчанию, с ним мы знакомы.

- Споставление по именам: соответствие определяется по указанным именам аргументов. Вызывающая программа указывает соотвествие м/у аргументами и их значениями в момент вызова ф-ции, синтаксис: name = value.

- Значения по умолчанию: указываются значения аргументов, которые могут не передаваться. Это использ. если вдруг передается неполное кол-во аргументов, синтаксис также: name = value. 

- Переменное число аргументов: прием произвольного числа аргументов, позиционных или именованных. Можно использ. спец. аргумент, перед именем которго стоит один или два символа *, для объединения произвол. кол-ва аргуметов в коллекцию (часто наз-ся varargs).

- Переменное число аргументов: передача произвольного числа аргументов, позиционных и именованных. Вызывающая программа также может использ. * для распаковки коллекции в отдельнеы аргументы.

- Только именованные аргументы: аргументы, которые должны передаваться только по имени. В 3.0 (но не в 2.6) могут определяться аргументы, передаваемые по имени, а не по позиции.


Синтаксис сопоставления.

Таблица 18.1 Виды сопоставления аргументов функций. стр. 512


Эти режимы делятся на случаи вызова функции и определения функции:

- В инструкции вызова ф-ции при использ. простых значений соотв-ие именам аргументов опред-ся по позиции, а с формой name = value соотв-ие опред-ся по именам аргументов - наз-ся передачей именованных аргументов. Формы *sequence и **dict в вызоывх ф-ций дают передавать произвольное число объектов по позиции или по именам в виде последовательностей или словарей.

- В заголовке ф-ции с простыми значениями соответствие идет по позиции и по имени, а с формой name = value определяются значения по умолчанию. С формой *name все доп. позиционные аргументы объединяются в кортеж, а с формой **name все доп. именованные аргументы объединяются в словарь. В 3.0 и выше обычные аргументы и аргументы со знач. по умолчанию, следующие за формой *name изи за символом *, явл-ся именованными аргументами, которые, при вызове ф-ции, передаются по имени.

Наиболее часто используется форма передачи именованных аргументов и аргументов со значениями по умолчанию. Мы встречались с ними ранее:

- Именованные аргументы использ-сь для передачи необязательных параметров ф-ции print, именованные аргументы позволяют указывать значения аргументов вместе с их именами, что дает больше смысла вызову ф-ции;

- Значения по умолчанию встречались когда мы изучали передачу значений из объемлющей области видимости, это позволяет определять необязательные аргументы и указывать значения по умолчанию в определении ф-ции.


Тонкости сопоставления.

Несколько правил:

- В вызове ф-ции порядок аргументов таков: любые позиционные аргументы (значения), за которыми могут следовать любые именованные аргументы (name = value) и аргументы в форме *sequence, за которым могут следовать аргументы в форме **dict.

- В заголовке ф-ции порядок аргументов таков: любые обычные аргументы (name), за которыми могут следовать аргументы со значениями по умолчанию (name = value), за которым следуют аргументы в форме *name (или * в 3.0), если имеются, за которыми могут следовать любые имена или пары name = value аргументов, которые передаются только по имени, за которыми могут следовать аргументы в форме **name.

В обоих случаях форма **arg должна следовать последней.

Также отметим, что порядок аргументов важен и если его нарушить будет вызвана ошибка.

Ход действий интерпретатора:

1. Сопоставление неименованных аргументов по позициям.

2. Сопоставление именованных аргументов по именам.

3. Сопоставление дополнительных неименованных аргументов с кортежем *name.

4. Сопоставление дополнительных именованных аргументов со словарем **name.

5. Сопоставление значений по умолчанию с отсутствующими именованными аргументами.

- Далее интепретатор убеждается, что каждому аргументу соотв-ет только одно значение (иначе возбуждается исключение!) и связывает имена аргументво с полученными объектами.

В Питон 3.0 имена аргументов в загловке ф-ции могут также снабжаться аннотациями в форме name:value (или name:value=default, если имеется значение по умолчанию).



Примеры использования именованных аргументов и значений по умолчанию. стр. 515

По умолчанию сопоставление идет слева направо, по позиции:

>>> def f(a, b, c): print(a, b, c)

>>> f(1, 2, 3)
1 2 3

- в этом примере все просто: а соотв-ет 1, b - 2, и т.д.


Именованные аргументы.

Определяют соответствие по именам, а не по позициям:

>>> f(c=3, b=1, a=2)
2 1 3

- b=3 здесь означает, что значение 2 передается ф-ции в аргументе с именем b, т.е. интерпретатор сопоставляет имя b в вызове ф-ции с именем аргумента b в заголовке определения ф-ции и затем передает значение 2 в этот аргумент.

Обратив внимание, что порядок следования именованных аргументов не имеет значения.

Можно объединить передачу по позициям и по именам аргументов:

>>> f(1, c=3, b=2)
1 2 3

Самые используемые роли именованных аргументов такие: делают вызовы ф-ций более описательными (если имена будут более звучные чем a, b, c:  - напр. name='Bob', age=40 и т.п.) и вторая роль - они используются вместе со значениями по умолчания, о которых мы поговорим далее.


Значения по умолчанию.

Приведем краткий наглядный пример:

>>> def f(a, b=22, c=33): print(a, b, c)
...
>>> f(11)
11 22 33

>>> f(a=12)
12 22 33

При таком вызове мы обязаны передать значение аргумента а (по позиции или по имени), а значения b и c можно опустить.
 
Можно передать и два аргумента, или все три:

>>> f(10, 14)
10 14 33

>>> f(3, 4, 5)
3 4 5

- в последнем случае оба значения по умолч. просто не будут использованы. 
   
Еще пример, с комбинированием режимов передачи значений и т.н. "перепрыгиванием" через аргументы:

>>> f(7, c=55)
7 22 55

- здесь у нас 7 - аргумент по позиции, 55 - по имени, а 22 - по умолчанию.

Главное не путайте конструкции name=value в заголовке ф-ции и в вызове. Это разные синатксические конструкции.


Комбинирование именованных аргументов и значений по умолчанию.

Пример, вызывающая программа всегда должна передавать ф-ции как минимум два аргумента (spam и eggs), два др. аргумента необязательны, в случае отсутствия они принимаются по умолчанию:

>>> def func(spam, eggs, toast=0, ham=0):
	print(spam, eggs, toast, ham)
...
	
>>> func(1, 2)
1 2 0 0
>>> func(1, ham=1, eggs=0)
1 0 0 1
>>> func(spam=1, eggs=0)
1 0 0 0
>>> func(toast=1, eggs=2, spam=3)
3 2 1 0
>>> func(1, 2, 3, 4)
1 2 3 4 

- Еще раз обратите внимание, что порядок следования именованных аргументов не важен. Важно, чтобы были значения для spam и eggs, а сопоставление может быть и по именам и по позициям. Форма name=value имеет разный смысл в вызове ф-ции и в инструкции def (именованный аргумент - в вызове и значение по умолчанию - в заголовке).



Примеры произвольного числа аргументов. стр. 518

* и ** пердназначены для передачи произвольного числа аргументов ф-циям. Оба варианта могут появл-ся как в определениях ф-ций так и в вызовах, в обоих случаях у них сходные назначения.


Сбор аргументов в коллекцию.

Пример, выполняется сборка лишних позиционных аргументов в кортеж:

>>> def f(*args): print(args)
...

При вызове ф-ции интерпретатор соберет все позиционные аргументы в новый кортеж и присвоит его переменной args, с этим кортежем можно работать как с обычным объектом кортежа:

>>> f()
()
>>> f(1)
(1,)
>>> f(1, 2, 3, 4)
(1, 2, 3, 4)

Комбинация ** применяется при передаче именованных аргументов - в этом случае аргументы будут собраны в новый словарь, с ним также можно работать как с обычным словарем.

Форма ** позволяет преобразовать аргументы, передаваемые по именам, в словари, которые можно обойти с помощью метода keys и т.п. итераторами:

>>> def f(**args): print(args)
...
>>> f()
{}
>>> f(a=1, b=2)
{'b': 2, 'a': 1}

Пример, в заголовках ф-ций можно комбинировать * и **, здесь у нас число 1 передается как позиционный аргумент, 2 и 3 объединяются в кортеж pargs с позициями, а x и y помещаются в словарь kargs с именами:

>>> def f(a, *pargs, **kargs): print(a, pargs, kargs)

>>> f(1, 2, 3, x=1, y=2)
1 (2, 3) {'y': 2, 'x': 1}

Все эти формы можно комбинировать в еще более сложные формы, а сейчас обратимся к формам * и ** в вызовах ф-ций.


Извлечение аргументов из коллекции.

Форма * в вызовах ф-ций распаковывает, а не создает коллекцию аргументов. Напр. передаем четыре аргумента в виде кортежа и интерпретатор их распаковывает:

>>> def func(a, b, c, d): print(a, b, c, d)
...
>>> args = (1, 2)
>>> args += (3, 4)
>>> func(*args)
1 2 3 4

Форма ** в вызовах распаковывает словари пар ключ/значение в отдельные аргументы, которы епередаются по ключу:

>>> args = {'a':1, 'b':2, 'c':3}
>>> args['d'] = 4
>>> func(**args)
1 2 3 4

Можно комбинировать позиционные и именованные аргументы:

>>> func(*(1, 2), **{'d':4, 'c':4})
1 2 4 4

>>> func(1, *(2, 3), **{'d':4})
1 2 3 4

>>> func(1, c=3, *(2,), **{'d':4})
1 2 3 4

>>> func(1, *(2, 3), d=4)
1 2 3 4

>>> func(1, *(2,), c=3, **{'d':4})
1 2 3 4

Такие способы использ. когда мы заранее не знаем сколько аргументов может быть передано ф-ции.

И также не путайте конструкции */** в заголовках ф-ции и в их вызовах (сборка лишних аргументов в коллекцию и распаковка коллекции соответственно).

В вызовах ф-ций в форме *pargs можно передавать любые итерирумеые объекты, даже файл - func(*open('fname')).


Обобщенные способы вызова ф-ций.

Разные способы получения аргументов помогают тем, что нам заранее не нужно знать кол-во обязательных аргументов в ф-ции. 
Например, нам в программе можно использовать if для выбора из множества ф-ций и списков аргументов и вызывать любую из них единообразным способом:

if <test>:
	action, args = func1, (1,)			# Вызвать func1 с 1 аргументом
else:
	action, args = func2, (1, 2, 3)		# Вызвать func2 с 3 аргументами
...
action(*args)					# Фактический вызов универсальным способом 

Вообще передачу произвольного числа аргументов удобно использовать всегда, когда заранее не известен перечень аргументов.

Напр. пользователь выбирает ф-цию с помощью польз-го интерфейса, может быть невозможно нам записать явный вызов ф-ции в програм. коде. Для решения сделать список операциями над списками и вызвать ф-цию, с пом. синтаксиса произвольного числа аргументов:

>>> args = (2, 3)
>>> args += (4,)
>>> args
(2, 3, 4)
>>> func(*args)
...
TypeError: func() missing 1 required positional argument: 'd'
>>> args += (5,)
>>> func(*args)
2 3 4 5

Список аргументов программа может создать во время выполнения. Пример, реализация вызова произвольных ф-ций с любым кол-вом аргументов, передавая их все:

def tracer(func, *pargs, **kargs):			# Принимает произвольные аргументы
	print('calling:', func.__name__)
	return func(*pargs, **kargs)			# Передает все полученные аргументы
	
def func(a, b, c, d):
	return a + b + c + d
	
print(tracer(func, 1, 2, c=3, d=4))


При вызове tracer все аргументы будут собарны в коллекцию и переданы требуемой ф-ции:

calling: func
10


Исчезнувшая встроенная функция apply (Питон 2.6).

В 2.6 роль форм * и ** выполняла ф-ция apply (в 3.0 не работает), т.е. след. два примера эквивалентны:

func(*pargs, **kargs)			# Новый синтаксис вызова

apply(func, pargs, kargs)		# Устаревшая функция

Пример:

>>> def echo(*args, **kargs): print(args, kargs)
...
>>> echo(1, 2, a=3, b=4)
(1, 2) {'b': 4, 'a': 3}

В 2.6 этот пример выглядел бы так:

>>> pargs = (1, 2)
>>> kargs = {'a':3, 'b':4}

>>> apply(echo, pargs, kargs)
(1, 2) {'b': 4, 'a': 3}

>>> echo(*pargs, **kargs)
(1, 2) {'b': 4, 'a': 3}

>>> echo(0, c=5, *pargs, **kargs)		# Новый синтаксис 3.0 более универсален к тому же
(0, 1, 2) {'b': 4, 'a': 3, 'c':5} 
 


Питон 3.0: аргументы, которые могут передаваться только по именам. стр. 522

В 3.0 мы можем определять аргументы, которые могут передаваться только в форме именованных аргументов и никогда позиционных.

Такие особенные аргументы оформляются в виде обычных именованных, следующих за формой *args в списке аргументов.

Пример, а - может быть как именованным так и позиционным, b - собираются все дополнительные аргументы, а с - только как именованный:

>>> def kvon(a, *b, c):
	print(a, b, c)
...	
>>> kvon(1, 2, c=3)
1 (2,) 3
>>> kvon(a=1, c=3)
1 () 3
>>> kvon(1, 2, 3)
...
TypeError: kvon() missing 1 required keyword-only argument: 'c'   

Чтобы показать, что ф-ция не принимает списки аргументов, можно использ-ть одиночный символ *, при все аргументы после * будут передавать по именам:

>>> def kvon(a, *, b, c):
	print(a, b, c)
...	
>>> kvon(1, c=3, b=2)
1 2 3
>>> kvon(c=3, b=2, a=1)
1 2 3

>>> kvon(1, 2, 3)
...
TypeError: kvon() takes 1 positional argument but 3 were given

>>> kvon(1)
...
TypeError: kvon() missing 2 required keyword-only arguments: 'b' and 'c' 


Для именованных аргументов после * можно также указывать значения по умолчанию:

>>> def kvon(a, *, b='spam', c='ham'):
	print(a, b, c)
...	
>>> kvon(1)
1 spam ham
>>> kvon(1, c=3)
1 spam 3
>>> kvon(a=1)
1 spam ham
>>> kvon(c=3, b=2, a=1)
1 2 3
>>> kvon(1, 2)
...
TypeError: kvon() takes 1 positional argument but 2 were given  


А теперь посмотрим как именованные аргументы комбинируются, по умолч. также остаются необязательными:

>>> def kvon(a, *, b, c='ham'):
	print(a, b, c)
...	
>>> kvon(1, b='eggs')
1 eggs ham
>>> kvon(1, c='eggs')
...
TypeError: kvon() missing 1 required keyword-only argument: 'b'
>>> kvon(1, 2)
...
TypeError: kvon() takes 1 positional argument but 2 were given
 
>>> def kvon(a, *, b=1, c, d=2):
	print(a, b, c, d)
...	
>>> kvon(3, c=4)
3 1 4 2
>>> kvon(3, c=4, b=5)
3 5 4 2
>>> kvon(3)
...
TypeError: kvon() missing 1 required keyword-only argument: 'c'
>>> kvon(1, 2, 3)
...
TypeError: kvon() takes 1 positional argument but 3 were given


Правила, определяющие порядок следования.

Одно замечание, аргументы с обязательной передачей по именам должны идти после одной звездочки *, но не после двух **, и два символа ** не должны быть пусты:

>>> def kvon(a, **pargs, b, c)
SyntaxError: invalid syntax
>>> def kvon(a, **, b, c)
SyntaxError: invalid syntax

Т.о. аргументы только по имени должны идти после * но перед **

>>> def f(a, *b, **d, c=6): print(a, b, c, d)		# Ошибка, после * должн быть 
SyntaxError: invalid syntax							# хоть один аргумент, а не **

>>> def f(a, *b, c=6, **d): print(a, b, c, d)		# Кооллекции аргументов 
													# в заголовке	

>>> f(1, 2, 3, x=4, y=5)					# Используется значение по умолч.
1 (2, 3) 6 {'y': 5, 'x': 4}

>>> f(1, 2, 3, x=4, y=5, c=7)				# Переопределение знач. по умолч.
1 (2, 3) 7 {'y': 5, 'x': 4}

>>> f(1, 2, 3, c=7, x=4, y=5)			# Среди именованных аргументов
1 (2, 3) 7 {'y': 5, 'x': 4}

>>> def f(a, c=6, *b, **d): print(a, b, c, d)		# c - не явл-ся только именованным аргументом!
...
>>> f(1, 2, 3, x=4)
1 (3,) 2 {'x': 4}


В вызовах ф-ций похожие правила порядка аргументов. Только именованные аргументы должны располагаться перед **. При этом аргументы, которые могут передаваться только по именам, могут располагаться как перед * так и после неё, а также могут включаться в словарь **:

>>> def f(a, *b, c=6, **d): print(a, b, c, d)		# Только именованные аргументы
													# м/у * и **	
>>> f(1, *(2, 3), **dict(x=4, y=5))			# Распаковывание аргументов при вызове
1 (2, 3) 6 {'y': 5, 'x': 4}
 
>>> f(1, *(2, 3), **dict(x=4, y=5), c=7)	# Именованные аргументы после ** !
SyntaxError: invalid syntax

>>> f(1, *(2, 3), c=7, **dict(x=4, y=5))	# Переопределение знач. по умолч.
1 (2, 3) 7 {'y': 5, 'x': 4}
 
>>> f(1, c=7, *(2, 3), **dict(x=4, y=5))	# Перед * или после нее
1 (2, 3) 7 {'y': 5, 'x': 4}
 
>>> f(1, *(2, 3), **dict(x=4, y=5, c=7))	# Только именованные аргументы внутри **
1 (2, 3) 7 {'y': 5, 'x': 4}


Когда используются аргументы, которые могут передаваться только по именам? 

Они упрощают создание ф-ций, которые принимают произвольное кол-во позиционных аргументов и параметры настройки, передаваемые в виде именованных аргументов. Можно и без них, но тогда больше кода и работы.

Допустим есть ф-ция, которая принимает много аргументво и еще флаг трассировки:

process(X, Y, Z)				# Используется значение флага по умолчанию
process(X, Y, notify=True)		# значение флага определяется явно

Без аргумента, который передается только по имени, нам пришлось бы задействовать и форму *args и **args и вручную проверять аргументы.

Следующее поределение ф-ции гарантирует, что ни один позиционный аргумент не будет сопоставлен с notify и передает его по имени:

def process(*args, notify=False): ...



Функция поиска минимума. стр. 525

Теперь к практике. 

Допустим нам нужна ф-ция способная находить минимальное значение из множества (ноль и более) аргументов с разными типами данных.

Мы можем собрать аргументы в кортеж и выполнить их обход с помощью for. Все типы поддерживают операцию сравнения и нам даже не нужно учитывать тип аргументов (полиморфизм, однако) - т.е. мы можем просто сравнить объекты и дать интерпретатору самому выбрать корректную операцию сравнения.


Основное задание.

Три способа реализации:

- Первая реализация: извлекает первый аргумент (args - кортеж) и обходит остальную часть коллекции, отсекая первый элемент (т.к. нам не нужно сравнивать этот элемент сам с собой);

- Вторая реализация: интерпретатор сам выбирает первый аргумент и остаток, благодаря чему отпадает необходимость извлекать первый аргумент и получать срез;

- Третья реализация: преобразует кортеж в список с помощью встроенной ф-ции list и использует метод списка sort.

sort может обеспечивать высокую производительность, но линейный характер сканирования обеспечивает первым двум вариантам более высокую скорость.  


Запишем все три варианта в файл mins.py:

def min1(*args):
	res = args[0]
	for arg in args[1:]:
		if arg < res:
			res = arg
	return res

def min2(first, *rest):
	for arg in rest:
		if arg < first:
			first = arg
	return first

def min3(*args):
	tmp = list(args)
	tmp.sort()
	return tmp[0]
	
print(min1(3, 4, 1, 2))
print(min2('bb', 'aa'))
print(min3([2, 2], [1, 1], [3, 3]))


>>> import mins
1
aa
[1, 1]

Отметим, что ни один вариант не проверяет - вдруг ф-ции не передается ни одного аргумента; такую проверку можно сделать, но интерпретатор сам выдаст исключение если не будет ни одного аргумента.

В первом случае исключение будет при попытке получить нулевой элемент, во втором - когда обнаружится несоответствие списка аргументов, в третьем - когда ф-ция попытается вернуть нулевой элемент.


Дополнительные баллы.

А если нам теперь нужны максимальные значения?

В первых двух версиях достаточно изменить < на >, а третья версия должна возвращать не tmp[0], а tmp[-1]. Ну и плюсом будет изменить имя ф-ции на max (это немного юмора).

К тому же можно обощить ф-цию так, что она будет искать либо минимум либо максимум, определяя отношение элементов за счет интерпретации строки выражения с помощью таких средств, как ф-ция eval, или передавая произвольную ф-цию сравнения:

def minmax(test, *args):
	res = args[0]
	for arg in args[1:]:
		if test(arg, res):
			res = arg
	return res
	
def lessthan(x, y): return x < y

def getthan(x, y): return x > y

print(minmax(lessthan, 4, 2, 1, 5, 6, 3))
print(minmax(getthan, 4, 2, 1, 5, 6, 3))


>>> import minmax
1
6

Конечно  это мы делали просто упражнение, в Питно ф-ции min и max уже есть. Эти примеры могут быть распространены и на другие случаи.



Универсальные функции для работы с множествами. стр. 528

    

  

