
Т.к. в учебнике по Питону сразу написано о прикладном программировании, то сразу же поясним этот момент, что такое и с чем его едят.

# Прикладное программирование

Прикладная программа или приложение — программа, предназначенная для выполнения определённых задач и рассчитанная на непосредственное взаимодействие с пользователем. В большинстве операционных систем прикладные программы не могут обращаться к ресурсам компьютера напрямую, а взаимодействуют с оборудованием и другими программами посредством операционной системы. Также на простом языке — вспомогательные программы.

К прикладному программному обеспечению относятся компьютерные программы, написанные для пользователей или самими пользователями для задания компьютеру конкретной работы. Программы обработки заказов или создания списков рассылки — пример прикладного программного обеспечения. Программистов, которые пишут прикладное программное обеспечение, называют прикладными программистами.

Подразделения на группы прикладных программ:
 
    программные средства общего назначения
        Текстовые редакторы
        Текстовые процессоры
        Системы компьютерной вёрстки
        Графические редакторы
        СУБД
        Электронные таблицы
        Веб-браузеры
    программные средства развлекательного назначения
        Медиаплееры
        Компьютерные игры
    программные средства специального назначения
        Экспертные системы
        Трансляторы
        Мультимедиа-приложения (медиаплееры, программы для создания и редактирования видео, звука, text-to-speech и пр.)
        Гипертекстовые системы (электронные словари, энциклопедии, справочные системы)
        Системы управления содержимым
    профессиональные программные средства
        САПР
        АРМ
        АСУ
        АСУ ТП
        АСНИ
        Геоинформационные системы
        Биллинговые системы
        CRM
        CTRM/ETRM — системы управления складом
        SRM (Supplier Relationship Management) — системы управления взаимоотношениями с поставщиками
        BI (Business Intelligence) — аналитические системы
        DMS (Document Management System) — Система управления документами/Система автоматизации документооборота (системы электронного документооборота)
        CMS (Content Management System) — системы управления содержимым (контентом)
        WMS (Warehouse Management System) — системы управления складом (СУС)
        ERP-системы — системы планирования ресурсов предприятия
        EAM-системы — системы управления основными фондами предприятия
        MRM-системы — системы управления маркетинговыми ресурсами
        MES-системы — системы оперативного (цехового) управления производством и ремонтами
        Интеграционные шины данных (ESB)

По этому списку становится более ясно и понятно, что такое прикладное программирование и прикладные программы - приложения (не заметил в самом начале это понятного слова).

Стр. 45 
Автор упоминает о том, что одним из минусов Питона является скорость выполнения приложений, она не так высока как у С/С++, т.к. Питон это интерпретируемый ЯП.
Но вместе с тем Питон можно использовать для "быстрый" приложений, это достигается комбинированием компилированных и оптимизированных библиотек расширения. Т.е. для ускоренных вычислений мы должны выделить из приложения компоненты, требующие скорости, в виде компилированных расширений и связать их системой сценариев на Питоне.
Как это делается пока не известно, но нужно держать такие моменты в голове, нужно будет изучить далее.

стр. 47 
Список компаний и областей где активно используется Питон.

стр. 48
Области применения Питон:
- Системное программирование. Питон применяется для создания переносимых программ и утилит системного администрирования (так называемыми инструментами командной оболочки).
- Графический интерфейс. Тут всё понятно, пишется GUI для разных ПО.
- Веб-сценарии. Например пакет mod_python предназначен для запуска сценариев на языке Питон по управлением веб-сервера Апач (что очень нам подходит, т.к. у нас как раз Апач и стоит).
Также существуют пакеты веб-разработки, один из популярных это - Django и пр. (в т.ч. технология веб - MVC).
- Интеграция компонентов. Позволяет интегрировать код на Питоне в различные ЯП и приложения различных ОС.
- Приложения баз данных. В Питоне имеются интерфейся для работы со всеми основными реляционными БД.
- Быстрое создание прототипов. Информация об объединении нескольких модулей на разных ЯП, пока не понятно для меня, надеюсь дальше станет яснее.
- Программирование математических вычеслений. Расширение NumPy для математических вычислений, за счет интеграции с математическими библиотеками, написанными на компилирующих языках программирования - превращает Питон в сложный, но удобный инструмент программирования математических вычислений.   
- Игры, изображения, искусственный интеллект, XML, управление роботами и многое другое.

стр. 53
- Питон объектно-ориентированный язык. Но при этом ООП не является обязательным, Питон поддерживает и процедурный стиль программирования.
- Питон свободный ЯП.
- Питон переносим, т.е. на разных ОС один и тот же код, использующий стандартные библиотеки, будет выполняться интерпретатором без проблем (должен выполняться).
- Питон мощный ЯП. Динамическая типизация (привет Руби!); автоматическое управление памятью; модульное программирование (можно создавать модули, классы, исключения); встроенные типы объектов (строки, списки, словари); встроенные инструменты (конкатенация, сортировка, и т.д.); библиотеки утилит; утилиты сторонних разработчиков.
- Питон соединыемый. программы на Питоне могут с легкостью "склеиваться" с компонентами, написанными на других ЯП. Например пишем программу на Питоне, а потом по частям перенести на С (для скорости, например).
- Питон удобен.
- Питон прост в изучении. Хотя эта книга занимает почти 1300 страниц...
- Питон назван в честь комедийного сериала "Монти Пайтон". Может нужно произносить Пайтон, а не Питон, но буду писать здесь - Питон, потом переучимся, если что.


Интерпретатор - это такой модуль, который исполняет другие программы. Когда мы пишем код на Питоне, интерпретатор читает нашу программу и выполняет её инструкции. По сути, интерпретатор - это слой программной логики между нашим программным кодом и аппаратурой нашего ПК.

Схема выполнения программ на Питоне:

Исходный текст (m.py) -- Байт-код (m.pyc) -- Выполнение (PVM)

Интерпретатор транслирует текст программы (инструкции) в байт-код - низкоуровневое, платформонезависимое представление исходного текста программы.

Как только программа скомпилируется в байт-код он передается виртуальной машине Питон (PVM) - привет Java! Формально, PVM это последняя составляющая того, что называют интерпретатором Питон.

Интерпретатор Jython (первоначальное - JPython) - альтернативная реализация Питона с тесной интеграцией с Java. В ней код на Питоне компилируется в байт-код Java, а затем передается JVM (вирутальной машине Java).

IronPython - реализация Питона предназначена для обеспечения интеграции программ с приложениями, созданными для работы в среде Microsoft .NET Framework и Mono - открытом эквиваленте для ОС Linux.

Существует еще динамический компилятор Psyco, который во время компиляции переводит некоторые части байт-кода в двоичный код, для ускорения.

Shedsckin C++ транслирует код Питона в код на С++, который затем можно скомпилировать в машинный код. На момент создания книги он был в стадии тестирования и доработки, может уже в промышленных масштабах используетс, нужно проверить.

Также программы на Питоне можно переводить в настоящие исполняемые файлы (по типу .exe в Windows), которые объединяют в себя байт-код программы, PVM (интерпретатор) и файлы поддержки, необходимые программе.

В среде Питон файлы, в которых сохранен код, называют - модулями. Часто их называют программами на языке Питон. Файлы модулей, которые запускаются на выполнение непосредственно, иногда называют - сценариями, этим неофициальным термином обозначаются файлы программ верхнего уровня. Термин модуль зарезрвирован для обозначения файлов, которые могут импортироваться другими файлами.


В Unix системах возможно понадобится вводить путь к самому Питону, что-то типа /usr/bin/pythhon чтобы запускать программы (сценарии).



! - Ознакомимся с инструкциями import и from. И изучим запуск программ, модулей, сценариев.


# Первый сценарий на Питоне
import sys
print(sys.platform)
print(2*8)
x = 'Spam'
print(x*8) 

- импортирует модуль Python (библиотеку дополнительных инструментов), чтобы позднее получить название платформы
- sys.platform это просто строковая переменная, содержимое которой идентифицирует тип компьютера, на котором выполняется сценарий. 
- трижды вызывает функцию print и отображает результаты
- создает переменную x, которая создается в момент присваивания ей строкового объекта 

Заметим, что мы сохранили этот сценарий под именем script1.py хотя можно было и без расширения, но расширение *.py подразумевает, что сценарий можно будет в дальнейшем импортировать. Поэтому указываем его, т.к. этим действием мы обеспечим возможность дальнейшего использования кода.


Данные вывода можно передать в файл (например текстовый)командой:

script1.py > info.txt

- т.о. мы наблюдаем т.н. "Перенаправление потоков"


В Unix можно указывать специальный комментарий, который сможет запускать сценарий без указания пути к Питону.
Т.н. "hash bang":

#!/usr/bin/python
print("Hello men")


стр. 90 - о команде env, которая позволит запустить Питон если вы не знаете его расположение на компьютере.


Кстати напомним, что если в конце сценария добавить функцию input() то после вывода данных программы командная строка не закроется сама (как это может быть если мы запустим программу в Виндовс нажатием на ярлык файла).

В Питоне 3.0 функция input() заменила собой функцию raw_input() из Питона 2.6


! - О модулях.

Итак, каждый файл с исходным текстом на Питоне, имя которого оканчивается расширением .py является модулем.
Другие файлы могут обращаться к программным компонентам, объявляемым модулем, импортируя этот модуль.

По сути, инструкция import (здесь впервые мы делаем акцент на различиях инструкций и функций в Питоне, далее будем пытаться понять в чем они различаются и вообще понимать суть обоих терминов)

В итоге, после импорта, содержимое модуля становится доступным внешнему миру через его атрибуты.

Модульная система является центральной идеей Питона.

Крупные программы обычно организованы в виде множества файлов модулей, которые импортируют и испольщуют функциональные возможности из другших модулей. При этом один из модулей определяется как основной файл верхнего уровня, который запускате всю программу.

Отметим, что операция импорта, на заключительном этапе. приводит к выполнению программного кода загружаемого файла. Т.о. импорт файла является еще одним способом запустить его.

-- Поработаем с импортом модулей (файлов).

скопируем наш script1.py в папку с Питоном (C:\Python34) и попробуем его импортировать.

>>> import script1
win32
256
SpamSpamSpamSpamSpamSpamSpamSpam

- видим, что мы запустили выполнение инструкций в этом модуле/файле (см. выше о запуске).

>>> import script1
>>> import script1

- а новая попытка импорта ни к чему не привела, интерпретатор не выполняет никаких действий и не выводит ничего. Даже если мы изменим теперь script1.py все равно ничего не будет выводиться.

Однократный запуск модуля при импорте сделан специально - т.к. эта операция требует слишком больших затрат вычислительных ресурсов, чтобы выоплнять её несколько раз в ходе выполнения программы.

- маленькое отступление - В ходе выполнения импорта, производится поиск файлов, компиляция их в байт-код и выполнение этого байт-кода. Вот почему операция затратная.


Для многократного запуска файла в одном сеансе можно воспользоваться встроенной функцией reload, доступной в модуле imp из стандартной библиотеки. В Питоне 2.6 эта функция была обычной встроенной, но в Питоне 3.0 она была перенесена в модуль imp.

>>> from imp import reload
>>> reload(script1)
win32
256
SpamSpamSpamSpamSpamSpamSpamSpam
<module 'script1' from 'C:\\Python34\\script1.py'>

- Инструкция from в этом примере просто копирует имя функции из модуля. Функция reload загружает и запускает текущую версию программного кода в файле. 
Даже если файл был изменен в другом окне reload также выводит и изменения (изменили 2*8 на 2*10):  

>>> reload(script1)
win32
1024
SpamSpamSpamSpamSpamSpamSpamSpam
<module 'script1' from 'C:\\Python34\\script1.py'>
        
- только не забываем изменять модуль (script1) котоырй находится именно в папке с Питоном, а не где-то еще откуда оне был скопирован - наступил на эти грабли, изменял script1.py, который был в папке D:\Job\python и удивлялся - почему не видно изменений в интерпретаторе.  
 

Еще одно замечание - функция reload ожидает получить имя уже загруженного модуля, поэтому модуль нужно перед этим импортировать (что мы и сделали вначале).

Заметим, что reload - это функция, которая вызывается (поэтому нужны скобки вокруг имени модуля), import - это инструкция, и скобок не нужно когда что-то импортируем.

<module 'script1' from 'C:\\Python34\\script1.py'>  -  это дополнительная строка, представление результата, возвращаемого функцией reload после перезагрузки модуля. Более подробно обсудим её позднее.


Можно импортировать модуль imp (import imp) и затем использовать синтаксис - imp.reload(M) или так как мы обсудили выше. Этот новый синтаксис формата - module.attribute


Особенность - имена, загруженные с помощью инструкции from, не обновляются вызовом функции reload, а имена, загруженные инструкцией import - обновляются, как мы видели из примеров выше.

   

! - О модулях. Атрибуты. стр. 97

В широком понимании модули играют роль библиотек инструментов. Модуль - это, главным образом, всего лишь пакет имен переменных, известный как - пространство имен. Имена внутри этого пакета называются атрибутами, т.е. атрибут - это имя переменной, которая связана с определенным объектом (таким как модуль).

В типичном случае импортирующий программный код получает доступ ко всем именам верхнего уровня, определяемым в файле модуля.
Эти имена обычно связаны с функциональными возможнстями, экспортируемыми модулем - функциями, классами, переменными и т.д., которые предназначены для использования в других файлах и программах.

Снаружи доступ к именам в файле модуля можно получить с помощью двух инструкций, import и from, а также с помощью функции reload.

например, файл myfile.py содержит код:

title = "To beer or not to beer"

При импортировании этого модуля выполняется его программный код, котоый создает атрибут модуля. В нашем случае инструкция присваивания создает атрибут с именем title.

Доступ к этмоу атрибуту можно получить двумя способами. 
Первый - загрузить модуль инструкцией import и обратиться к атрибуту по его имени, уточнив его именем модуля:

>>> import myfile
>>> print(myfile.title)
To beer or not to beer


Синтаксис object.attribute позволяет получить доступ к любому атрибуту в любом объекте.

Второй способ - воспользоваться инструкцией from:

>>> from myfile import title
>>> print(title)
To beer or not to beer


Инструкция from во многом подобна инструкции import, которая выполняет присваивание имен в импортирующем компоненте.
Инструкция from копирует атрибуты модуля так, что они становятся простыми переменными в программном коде, выполняющем импорт, благодаря чем мы и обращаемся к атрибутам без указания модуля (в отличие от синтаксиса object.attribute).

Т.о. мы видим, что импортирующий компонент получает доступ к именам, определенным в файле на верхнем уровне. Это могут быт ьне только переменные, но и функции и классы и т.п., что очень важно для языка Питон.


Рассмотрим пример модуля с тремя переменными.

a = 'Billy'
b = 'Villy'
c = 'Dilly'
print(a, b, c) 

>>> import myfile
Billy Villy Dilly
>>> myfile.a, myfile.b
('Billy', 'Villy')

>>> from myfile import a, b, c
>>> a, b
('Billy', 'Villy')

Итак, видим, что инструкция import получает модуль со всеми его атрибутами, а from получает копии имен из этого модуля.


Модули в Питоне являются самой крупной структурной единицей в программах этого ЯП.

Вообще программы на Питоне состоят из множества модулей свзязанных инструкциями import. Т.о. модули позволяют уменьшить вероятность конфликтов имен в программном коде, даже если они одинаковые (модули то разные), можно и запутаться в модулях, конечно, но это уже личное дело разработчика.

! - Не забудьте, что инструкция from может затереть переменные в импортирующем файле, если в импортируемом модуле есть переменные с такими же именами. Будьте бдительны и осторожны, следите за именами в обеих файлах.


Еще одна любопытная функция exec. Позволяет выполнять файлы практически не импортируя модуль. Причем след. вызов exec будет выполнять текущую версию файла и даже при изменении его выводит ьвсё правильно.

>>> exec(open('script1.py').read())
win32
1024
SpamSpamSpamSpamSpamSpamSpamSpam
>>> exec(open('script1.py').read())
win32
16384
SpamSpamSpam
>>>          
 
Предупреждение! Использование функции exec затирает существущие переменные, пример:

>>> x = 99
>>> exec(open('script1.py').read())
win32
16384
SpamSpamSpam
>>> x
'Spam'


стр. 121.

Данные в Питон представлены в форме объектов - либо встроенных, либо созданных разработчиком.

Объекты - это области памяти со значениями и ассоциированными с ними наборами операций.

1. Программы делятся на модули.
2. Модули содержат инструкции.
3. Инсрукции состоят из выражений.
4. Выражения создают и обрабатывают объекты.


Как мы вскоре узнаем, значительная доля работы приходится на реализацию объектов, известных также как структуры данных, которые предназначены для представления составляющих предметной области.


Базовые типы данных. стр. 123.

Числа
Строки
Списки (типо массивы) []
Словари (типо хеш) {}
Кортежи (ни то ни се) ()
и т.д.


Строки, списки, кортежи - это, так называемые, последовательности в языке Питон, упорядоченные коллекции объектов. Естественно, строки попроще последовательности, другие посложнее, но в целом все они собой являют тип объектов - последовательности. 
Со строками сложнее, они нам видятся цельными объектами, но по сути являются последовательностями односимвольных строк (т.е. символов).
Такая вот особенность этих базовых типов в Питон.
 

Далее мы узнаем, что структурные элементы программ, такие как функции, модули и классы, также являются объектами в Питоне.


Когда выполняется код:

>>> 'spam'

- то, гвооря техническим языком, выполняется выражение-литерал, которое генерирует и возвращает новый строковый объект. Подобным образом создаются объекты других типов.

Отметим, что как только создается объект, он будет ассоциирован со своим собственным набором операций на протяжении всего времени существования. Т.е. мы можем выполнить над объектом только те операции, которые применимы к его типу.

 
стр. 129

Методы в Питоне, это - функции, присоединенные к объекту, которые запускаются выражением вызова.

Например относительно строк, метод find возвращает смещение переданной ему подстроки или -1 если поиск не увенчался успехом, а replace проводит глобальный поиск с заменой.

Но при этом объект, к которому мы применяли методы (наша строка-испытатель 'spam'), не изменяется, а создается новая строка.

 Т.е. отметим, что выражение вида "s = (s.replace('pa', 'XYZ'))" строку 'spam' изменяет, а "s.replace('pa', 'XYZ')" не изменяет, просто метод возвращает новую строку, а прежняя остается собой. Вот такие вот особенности.
 
split() - разбивает строку по разделителю и и создает список строк
line = 'aaa, sss, bbb, cccccc, dd'
line.split(',')
['aaa', ' sss', ' bbb', ' cccccc', ' dd']

upper() - преобразует символы в верхний регистр

isalpha() - проверка содержимого: isalpha, isdigit и т.д.
s = 'spam'
>>> s.isalpha()
True
>>> s.isdigit()
False

Существуют также методы подстановки:
>>> '%s, eggs, and %s' % ('spam','SPAM')
'spam, eggs, and SPAM'
>>> '{0}, eggs, and {1}'.format('spam','SPAM!')
'spam, eggs, and SPAM!'

Следует знать, что инструментальные стредства Питон делятся на несколько уровней:
- универсальные операции, которые могут применяться к нескольким типам, реализованы в виде встроенных функций и выражений (типа len(x), x[0] и др.);
- а операции, специфичные для определенного типа, реализованы в виде методов (см. выше методы для строк).

Помощь по методам мы можем получить применив команду - dir(s), а т.к. мы знаем, что s у нас по прежнему строка, то получим все методы относящиеся к строкам.
Точнее сказать, функция dir() возвращает нам список всех атрибутов, определенных внутри модуля.


Имена вида __len__ представляют собой реализацию строкового объекта и доступны для поддержки специализации. В общем случае двойное подчеркивание вначале и конце имени используются интерпретатором Питон для обозначения особенностей внутренней реализации.

А имена без подчеркиваний обозначают методы строковых объектов.

Так же мы можем получим специализированные имена и имена методов для любого другого вида объектов.  

Справку по конкретному методу получаем командой - help(s.upper)

Пробовал по функциям с подчеркиваниями смотерть справку, но там непонятно, вводил например - help(len(s)) - т.е. по типу как используется эта функция, и получил кучу вывода непонятного, с командой - help(iter(s)) вывод получился короче, т.е. справку я смотрю вроде правильно, но описание непонятное.
Надо учить английский.

Использование шаблонов. Как я понял шаблоны в Питоне это т.н. регулярные выражения.

>>> import re
>>> match = re.match('Hello[ \t]*(.*)world', 'Hello   Python world')
>>> match.group(1)
'   Python '

В этом примере выполняется поиск строки, начинающейся со слова 'Hello', вслед за которым следуют ноль или более символов табуляции или пробелов, за которыми могут следовать произвольные символы, которые будут сохранены, как группа совпадения, и завершающая словом "world".
Если такое совпадение будет найдено, части этой подстроки будут доступны в виде групп. Например следующий шаблон возвращает три группы, разделенные символами слеша:
>>> match = re.match('/(.*)/(.*)/(.*)', '/usr/home/userlib')
>>> match.groups()
('usr', 'home', 'userlib')


Списки.

Списки - это самое общее представление последовательностей, реализованных в языке Питон.

Списки - это упорядоченные по местоположению коллекции объектов произвольных типов, размер которых не ограничен.
В отличие от строк списки являются изменяемыми объектами.

>>> l = [123, 'spam', 1.23]
>>> len(l)
3
>>> l[0]
123
>>> l[:-1]
[123, 'spam']
>>> l + [4,5,6]
[123, 'spam', 1.23, 4, 5, 6]
>>> l
[123, 'spam', 1.23]
 
Как видим, со списками мы можем производить те же операции, что и со строками, только результатом операций являются списки, а не строки.

Списки в Питоне являются аналогами массивов в других ЯП, но обладают более широкими возможностями.

>>> l.append('NI')
>>> l
[123, 'spam', 1.23, 'NI']
>>> l.pop(2)              # аналог этой команды - del l[2]
1.23
>>> l
[123, 'spam', 'NI']

>>> m = ['bb', 'aa','cc']
>>> m.sort()
>>> m
['aa', 'bb', 'cc']
>>> m.reverse()
>>> m
['cc', 'bb', 'aa']
>>> 
 
Как видим, т.к. списки являются изменяемыми, большинство методов списков не создают новый список, а изменяют оригинал.

При обращении за выход границ массива или попытке присвоения значения элементу за границей массива (l[99]=1) происходит ошибка и программа выдает соответствующее сообщение.


Вложенные списки.

>>> m = [[1,2,3],[4,5,6],[7,8,9]]
>>> m
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

>>> m[1]    # получить вторую строку (второй список)                          
[4, 5, 6]

>>> m[1][2]  # из второй строки получить элемент с индексом 2
6
   
Вместе с тем этот вложенный список можно представтиь в виде матрицы.

И при обработке матрицы можно эффективно воспользоваться - выражениями генераторов списков.

>>> col = [row[1] for row in m]
>>> col
[2, 5, 8]
>>> m
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

- вот такой командой мы выбрали элементы второго столбца, при этом оригинальная матрица не изменилась. 
Команда переводится так - "Получить элементы row[1] из каждой строки матрицы m и создать из них новый список".

>>> [row[1] + 1 for row in m]
[3, 6, 9]
>>> m
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

- добавить 1 к каждому элементу в столбце 2

>>> [row[1] for row in m if row[1] % 2==0]
[2, 8]
>>> m
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

- отфильтровать в выводе результата нечетные значения

Генераторы списков возвращают новые списки, но могут использоваться и для любых других объектов, допускающих выполнение итераций.Смотрим пару примеров.

Например выберем элементы по диагонали матрицы:
>>> diag = [m[i][i] for i in[0,1,2]]
>>> diag
[1, 5, 9]

Или дублирование символов в строке:
>>> doubl = [c * 2 for c in 'spam']
>>> doubl
['ss', 'pp', 'aa', 'mm']

Можно использовать круглые скобки для создания генераторов, которые воспроизводят результаты по требованию.
>>> g = (sum(row) for row in m)
>>> g
>>> next(g)
6
>>> next(g)
15
>>> next(g)
24
>>> next(g) 

- если далее продолжить команду next(g) - получаем сообщение об ошибке.

Можно еще обернуть вызов функции в список и она вернет все значения сразу:

>>> list(map(sum, m))
[6, 15, 24]

С помощью генераторов можно создавать множества и словари:

>>> {sum(row) for row in m}     # создадим множество сумм строк
{24, 6, 15}

>>> {i:sum(m[i]) for i in range(3)}    # Таблица пар ключ\значение сумм строк
{0: 6, 1: 15, 2: 24}

>>> [ord(x) for x in 'spaam']         # список кодов символов
[115, 112, 97, 97, 109]

>>> {ord(x) for x in 'spaam'}         # множество ликвидирует дубликаты
{112, 97, 115, 109}

>>> {x: ord(x) for x in 'spaam'}        # ключи словарей являются уникальными
{'a': 97, 'm': 109, 's': 115, 'p': 112}


Словари.

Словари в Питоне - известны как отображения, как-бы не являются последовательностями.

Отображения - это коллекция объектов, но доступ к ним осуществляется не по определенным смещениям от начала коллекции, а по ключам.
Отображения не предусматривают какого-либо упорядочения элементов по их позиции, они просто отображают ключи на связанные с ними позиции.
Словари - единственный тип отображений в Питоне. Они также изменяемые, как списки.

Определим словарь как литерал, обрамляется он в фигурные скобки, как хеш в Руби:

>>> d = {'food': 'spam', 'quant':4, 'color':'red'}
>>> d
{'quant': 4, 'food': 'spam', 'color': 'red'} 
>>> d['food']
'spam'
>>> d['quant'] +=1                          # здесь мы прибавили 1 к значению ключа quant
>>> d
{'quant': 5, 'food': 'spam', 'color': 'red'}

Есть другие способы создания словарей:
>>> d={}
>>> d['name']='Bob'
>>> d['job']='dev'
>>> d['age']=40
>>> d
{'age': 40, 'name': 'Bob', 'job': 'dev'}

Любопытная особенность, маленькое различие в выводе отдельного элемента и при использовании меода print:
>>> print(d['name'])
Bob
>>> d['name']
'Bob'                 # видим, что в этом случае имя в кавычках



Вложенность словарей.

Допустим нам нужно описать человека более подробно, для этого мы несколько усложним структуру словаря, на примере будет всё понятно:
# создаем словарь с вложениями
>>> rec = {'name':{'first':'Bob', 'last':'Smith'}, 'job':['dev','mgr'], 'age':40.5}
# выборку можно осуществлять стандартно по ключу, смотрим вложенный словарь 
>>> rec['name']
{'last': 'Smith', 'first': 'Bob'}
# выборка по вложенным элементам
>>> rec['name']['last']
'Smith'
# смотрим вложенный список
>>> rec['job']
['dev', 'mgr']
>>> rec['job'][-1]
'mgr'
>>> rec['job'].append('janitor')
>>> rec
{'age': 40.5, 'name': {'last': 'Smith', 'first': 'Bob'}, 'job': ['dev', 'mgr', 'janitor']}


Здесь мы видим как сильно похожи и взаимосвязаны способы работы со списками и словарями.


К тому же эти примеры демонстрируют нам гибкость языка Питон, в сравнении с другими более строгими ЯП.

К тому же можно освободить память вручную, например просто присвоив значение rec = 0, хотя в Питоне память освобождается атвоматически (т.н. "сборка мусора"). При этом не забывайте проверить не находится ли объект в базе данных или это может быть файл.


Сортировка. Цикл for

Порядок вывода ключей словаря может не совпадать с порядком их определения, т.е. например:
>>> d = {'a':1, 'b':2, 'c':3}
>>> d
{'a': 1, 'c': 3, 'b': 2}
>>> d['d']=4
>>> d
{'a': 1, 'd': 4, 'b': 2, 'c': 3}  

Отсортируем по ключам, методами keys sort и циклом for

>>> ks = list(d.keys())
>>> ks
['a', 'd', 'b', 'c']
>>> ks.sort()
>>> ks
['a', 'b', 'c', 'd']
>>> for key in ks:
	print(key, '=>', d[key])
	
a => 1
b => 2
c => 3
d => 4


Или можно воспользоваться новой функцией - sorted и не нужно будет трех этапов, причем переменную key мы можем назвать хоть mmm - оказывается это не специальное обозначение ключа (как я вначале подумал), а просто переменная относящаяся к ключу.

Я забыл, что ks - это уже отсортированный список ключей, а не весь наш словарь. А во втором случае, когда используем sorted, всё равно всё работает даже если вместо key писать bbb, такая вот крута функция.
 
>>> d
{'a': 1, 'd': 4, 'b': 2, 'c': 3}
>>> for key in sorted(d):
	print(key, '=>', d[key])
	
a => 1
b => 2
c => 3
d => 4


Вот мы и познакомились с циклом for.

Переменная цикла, определяемая пользователем (в нашем случае это key), служит для ссылки на текущий элемент.
Еще один пример цикла for, в котором происходит обход всех символов и перевод в верхний регистр:
>>> for c in 'spam':
	print(c.upper())
S
P
A
M


Пример цикла while:
>>> x = 4
>>> while x>0:
	print('spam!'*x)
	x -=1
spam!spam!spam!spam!
spam!spam!spam!
spam!spam!
spam! 

 
Цикл for и выражения-генераторы фактически представляют собой универсальное средство выполнения итераций. Обе констркции способны работать с любыми объектами, которые поддерживают протокол итераций.

Любой инструмент Питона, сканирующий объект слева направо использует протокол итераций. Пример - функция sorted.

Любой генератор списков, например:
>>> squar = [x**2 for x in [1,2,3,4,5]]
>>> squar
[1, 4, 9, 16, 25]

можно представит ьв виде эквивалентного цикла for:
>>> squar = []
>>> for x in [1,2,3,4,5]:
	squar.append(x**2)
>>> squar
[1, 4, 9, 16, 25]

Следует отметить, что генераторы и родственные им функции map и filter обычно выполняются быстре ечем цикл for.
Но о скорости лучше не беспокоиться, потому что главное правило Питона - это удобный код и простота, а оптимизацию можно оставить на потом.


Проверка с помощью оператора if.

>>> d
{'a': 1, 'b': 2, 'c': 3}
>>> d['e']=99
>>> d
{'a': 1, 'b': 2, 'e': 99, 'c': 3}

Если мы захотим проверить значение ключа d['f'] то получим сообщение об ошибке. Во избежание таких казусов можно использовать проверку.

>>> 'f' in d        # работает только на ключах, по значениям выдает false
False
>>> 2 in d
False
      
>>> if not 'f' in d:      # здесь мы использовали оператор if
	print('missing')

missing
>>>  
 
if мы рассмотрим позднее.


Кортежи.

Объект-кортеж (tuple - "тьюпл" или "тьюпел"), в общих чертах напоминает список, который невозможно изменить - кортежи это последовательности, как списки, но они неизменяемые, как строки.
Кортеж заключается в круглые скобки. Поддерживает включение объекто различных типов и операции типичные для последовательностей.
  
>>> t = (1,2,3,4)
>>> len(t)
4
>>> t + (5,6)
(1, 2, 3, 4, 5, 6)
>>> t[0]
1

>>> t[0]=2
Traceback (most recent call last):
  File "<pyshell#149>", line 1, in <module>
    t[0]=2
TypeError: 'tuple' object does not support item assignment

- получаем ошибку, кортежи неизменяемые.

>>> t=('spam', 3.0, [11,22,33])
>>> t
('spam', 3.0, [11, 22, 33])
>>> t[1]
3.0
>>> t[2][1]
22
>>> t.append(4)
Traceback (most recent call last):
  File "<pyshell#154>", line 1, in <module>
    t.append(4)
AttributeError: 'tuple' object has no attribute 'append'

Главное достоинство кортежей - их неизменяемость, и в основном их используют для обеспечения целостности коллекций, передаваемых между компонентами программы.


Файлы.

Файлы являются одним из базовых типов, но для них отсутствует возможность создания объектов в виде литералов (это естественно, т.к. файлы достаточно сложный и своеобразный объект).

Поэтому чтобы создать файл, нужно вызвать функцю open, передав ей имя файла и строку режима доступа к файлу (привет Руби!). Смотрим:

>>> f = open('data.txt', 'w')
>>> f.write('Hello\n')
6
>>> f.write('World\n')
6
>>> f.close
<built-in method close of _io.TextIOWrapper object at 0x01677CB0>
>>> f.close()

- открываем файл для создания, указываем имя и 'w', важно!!! - если создаем файл не в текущем каталоге, а где-то в другом месте, то указываем полный путь к нему! 

Затем записываем в него пару слов (при этом Питон показывает нам кол-во записанных байтов). И закрываем файл.


Теперь мы прочитаем содержимое файла и в строку и отобразим её:

>>> f = open('data.txt')    # по умолчанию режим 'r' поэтому можно не указывать
>>> text = f.read()
>>> text
'Hello\nWorld\n'
>>> print(text)
Hello
World 
>>> text.split()
['Hello', 'World']

Запомните, что самый лучший способ чтения файлов состоит в том, чтобы не читать его содержимое целиком - файлы предоставляют итераторы, которые обеспечивают автоматическое построчное чтение содержимого файла в циклах for и в других контекстах.

Кстати, в Питоне текстовые файлы представляются в виде строк и автоматически кодируются и декодируются в Юникод, а двоичные файлы представляются в виде строк специального типа bytes, при этом никаких автоматических преобразований не происходит.


Множества.

Множества - это неупорядоченные коллекции уникальных и неизменяемых объектов. Создаются они функцией set или с помощью определения литералов и генераторов множеств. Множества напоминают словари, в которых ключи не имеют значений.

>>> x = set('spam')       # множества можно создавать из последовательностей
>>> y = {'h', 'a','m'}    # можно определять литералы множеств
>>> x, y
({'s', 'p', 'a', 'm'}, {'m', 'a', 'h'})

>>> x&y                     # Пересечение                   
{'m', 'a'}
>>> x|y                     # Объединение  
{'s', 'p', 'a', 'm', 'h'}
>>> x-y                     # Разность
{'s', 'p'}
>>> y-x
{'h'}
>>> {x**2 for x in [1,2,3,4]}     # генератор множеств
{16, 1, 9, 4}


Кроме того появились в Питоне вещественные числа с фиксированной точностью и рациональные числа (т.е. дроби).

>>> 1/3                 # вещественное число
0.3333333333333333
>>> (2/3) + (1/2)
1.1666666666666665

>>> import decimal                # вещественные числа с фиксированной точностью
>>> d = decimal.Decimal('3.141')
>>> d+1
Decimal('4.141')
>>> decimal.getcontext().prec = 2
>>> decimal.Decimal('1.00')/decimal.Decimal('3.00')
Decimal('0.33')

>>> from fractions import Fraction      # Рациональные числа, т.е. дроби 
>>> f = Fraction(2, 3)
>>> f
Fraction(2, 3)
>>> f + 1
Fraction(5, 3)
>>> f + Fraction(1,2)
Fraction(7, 6)

>>> from ff import Fraction           # fractions - это модуль оказывается
Traceback (most recent call last):
  File "<pyshell#36>", line 1, in <module>
    from ff import Fraction
ImportError: No module named 'ff'


Кроме того в Питон имеется логический тип данных - True и False (по сути 1 и 0). Крмое того существует объект None, обычно используемый для инициализации объекто и переменных:

>>> 1 > 2, 1 < 2
(False, True)
>>> bool('spam')
True
>>> x = None
>>> x
>>> print(x)
None
>>> l = [None] * 20
>>> l
[None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None]


Отметим некоторые особенности программного кода в Питон.

Тип объекта, возвращаемый встроенной функцией type, в свою очередь сам является объектом. Причем в версиях Питона 3.х типы объектов были объеденены с классами.
Пример:

>>> type(l)               # Переменная l представляет объект типа list, типы являются
<class 'list'>              классами и наоборот

>>> type(type(l))         # Даже сами типы являются объектами  
<class 'type'>
 
Исследовать типы объектов можно не только в интерактивной оболочке, но и в сценариях:

>>> if type(l) == type([]):     # Проверка типа
	print('yes')
yes

>>> if type(l == list):         # С использованием имени типа
	print('yes')
yes

>>> if isinstance(l, list):     # Проверка в ООП стиле
	print('yea')
yea

- Но использвание таких проверок практически всегда является неверным решением, т.к. наличие таких проверок отрицательно сказывается на гибкости кода, потомоу что такими проверками мы ограничиваем  наш код в типах данных.

Программный код на Питоне ориентируется на использование интерфейсов объектов (набором поддерживаемых операций), а не их типов.

Это тесно связано с идеей полиморфизма, которую пропагандирует Питон, полиморфизм является одной из ключевых концепций этого ЯП.


Классы, определяемые пользователем. стр. 149

ООП рассмотрим позже, но пока познакомимся с классами.

Классы позволяют нам определять новые типы объектов. 

Например создадим тип объектов, который моделирует сотрудников: 

>>> class Worker:
	def __init__(self, name, pay):    # инициализация при создании
      self.name = name                # self - это сам объект 
      self.pay = pay
	def lastName(self):
			return self.name.split()[-1]  # разбить строку по символам пробела
	def giveRaise(self, percent):
			self.pay *= (1.0 + percent)   # обновить сумму выплат

- кстати все def, в этом случае, должны быть на одном уровне в файле сценария (как здесь) иначе lastName и giveRaise будут воприниматься не как методы, а как атрибуты объекта класса Worker и в коде ниже будет ошибка.
Смотрим дальше и всё поймем.
      
Данный класс определяет новый тип объектов, которые обладают атрибутами name и pay (иногда атрибуты называют - информацией о состоянии), а также двумя описаниями поведения, оформленными в виде функций (которые обычно называют методами).

Обращение к имени класса как к функции приводит к созданию экземпляра нового типа, а методы класса автоматически получают ссылку на текущий экземпляр, обрабатываемый этими методами (аргумент self):

>>> bob = Worker('Bob Smith', 50000)
>>> sue = Worker('Sue Jones', 60000)
>>> bob.lastName()
'Smith'
>>> sue.lastName()
'Jones'
>>> sue.giveRaise(.10)
>>> sue.pay
66000.0

В этой модели ООП присутствует подразумеваемый объект "self" -  внутри функций, определяемых в классе, всегда присутствует подразумеваемый объект, и в нашем случае это self.
В некотором смысле типы, основанные на классах, просто создаются на базе основных типов и используют их функциональные возможности.
В данном случае пользовательский класс Worker - это всего лишь коллекция, состоящая из строки и числа (name и pay соответсвенно), плюс функции, выполняющие обработку этих двух встроенных объектов.

По сути в Питоне все данные, которые обрабатываются сценариями, являются объектами. Объекты с которыми мы познакомились действительно являются объектами, но для работы с ними не требуется обязательно использовать ООП подход.



Теперь, поскольку объекты представляют самое фундаментальное понятие для программирования на языке Питон, все наше внимание в первую очередь будет сосредоточено на объектах.

Поэтому мы приступаем к более детальному изучению концепции типов данных. 



Глава 5. Числа. стр. 153

Числовые типы в Питон:

- Целые и вещественные числа;
- Комплексные числа;
- Числа фиксированной точности;
- Рациональные числа;
- Множества;
- Логические значения;
- Целые числа неограниченной точности;
- Различные встроенные функции и модули для работы с числами.

В Питон 2.6 целые числа были обычные и длинные, в версии 3.х целые числа стали одного типа.

Шестнадцатиричные записываются 0х или 0Х и дальше число, восьмеричные 0о или 0О (число 0 и символ "о") и дальше восьмеричное число, двоичные начинаются с 0b или 0B.

Комплексные числа записываются в виде - действительная_часть + мнимая_часть, где мнимая_часть завершается символом j или J. Мнимая_часть может указываться без действительной части, т.к. действительная может быть ен важно (с технич точки зрения).

Операторы выражений:

+ , - , * , / , >> , ** , &  и другие.

Встроенные математические функции:

pow, abs, round, int, hex, bin и др.

Вспомогательные модули:

random, math и др.


Операторы выражений.

Одной из самых фундаментальных возможностей обработки чисел являются - выражения - комбинации чисел и операторов, которые выозвращают значения при выполнении интерпретатором Питон.

Таблица 5.2 Операторы выражений и правила определения старшинства. стр. 157-159


Смешанные операторы и определение старшинства.

Чем выше приоритет оператора тем ниже он стоит в таблице 5.2 и тем раньше он выполняется в смешанных выражениях.

Чтобы не было ошибо при чтении выражений можно группировать подвыражения круглыми скобками - (А+В)*С например так.


Смешивание типов и их преобразование.

Пусть нам нужно сложить целое и вещественное число (40 + 3.14), как же Питон вычисляет тип результата?  

В выражениях, где участвуют значения различных типов, интерпретатор сначала выполняет преобразование типов операндов к типу самого сложного операнда, а затем прмиеняет математику, специфиную для этого типа.

В Питоне можно принудительно преобразовывать тип, но это не обязательно:

>>> int(3.1415)
3
>>> float(3)
3.0
>>> 40 + 3.14       # вот пример автоматического приведения типа
43.14

Все эти автоматические преобразования производятся только при смешивании числовых типов в выражении.
Питон не выполняет автоматическое преобразование других типов, т.е. нельзя сложить строку и число без ручного преобразования типов (с этим мы познакомимся позднее).
>>> a = 'spam'
>>> b = 7
>>> a+b
...
TypeError: Can't convert 'int' object to str implicitly

>>> print(a+b)            # даже функция print не работает в этом случае
...
TypeError: Can't convert 'int' object to str implicitly


Применимость математических операндов к разным типам объектов характеризуется полиморфизмом, т.е. выполняемая операция зависит от типов объектов-операндов, над которыми она выполняется. 
Например + это сложение с числами и + это конкатенация со строками и списками.

 
Числа в действии.

Займемся программированием! Так мы лучше поймем действия с числами.

Для начала присвоим двум переменным a и b целочисленные значения. Переменные - это всего лишь имена, создаваемые в языке Питон, которые используются для обозначения информации в программе. О переменных подробно изучим позже, сейчас несколько моментов:

- Переменные создаются с помощью операции присваивания;
- При вычислении имена переменных замещаются их значениями;
- Прежде чем переменная сможет участвовать в выражениях, ей должно быть присвоено значение
- Переменные являются ссылками на объекты и никогда не объявляются заранее.

>>> a = 3         # Создается имя
>>> b = 4      

>>> a + 1, a - 1      # Сложение, вычитание
(4, 2)

>>> b * 3, b / 2      # Умножение, деление
(12, 2.0)

>>> a % 2, b ** 2     # Деление по модулю (остаток), возведение в степень
(1, 16)

>>> 2 + 4.0, 2.0 ** b  # Смешивание типов, преобразование
(6.0, 16.0)

С технической точки зрения результатами этих выражений являются - кортежи, состоящие из двух значений, т.к. мы вводили строки, которые содержали по два выражения, разделенных запятыми. Именно по этой причине результат отображается в круглых скобках.

И опять же напоминаем - перед использованием переменных им были присвоены значения. 
Именно поэтому при использовании счетчиков вначале они должны инициализироваться хотя бы нулевым значением, или перед использованием списка инициализировать его пустым значением и т.п.

>>> b / 2 + a             # Примеры автоматического порядка и ручного выполнения операторов
5.0
>>> print(b / (2.0 + a))
0.8

- кстати если бы хотели использовать целочисленное деление, то нужно было записать выражение так: b // 2 + a но об операции деления поговорим далее.


Форматы отображения чисел.

Обратимся к последнему прмиеру и посмотрим разницу:
>>> b / (2.0 + a)         # в примере в книге это выглядит так
0.80000000004

- но на моем ПК оба выражения одинаковы, это зависит от архитектуры компьютера
>>> b / (2.0 + a)         
0.8
>>> print(b / (2.0 + a))
0.8

>>> num = 1 / 3.0
>>> num
0.3333333333333333
>>> print(num)
0.3333333333333333

- вот опять у меня обычный выывод и с помощью print одинаковые, но нужно запомнить, что обычный вывод зачастую может быть длиннее чем вывод функции print.

>>> "%e" % num                # Вывод с использованием выражения форматирования строк
'3.333333e-01'
>>> '%4.2f' % num             # Альтернативный формат представления вещественных чисел
'0.33'
>>> '{0:4.2f}'.format(num)    # Метод форматирования строк
'0.33'    

- функция repr(), также как и функция автоматического вывода в интерактивной оболочке, выводит результаты в том виде, в каком они были указаны в программном коде (например 0.333333333333333);
- функция str(), как и операция print, обычно выполняет преобразование в более дружественное значение.
Некоторые объекты имеют оба варианта строкового представления.

Одно замечание - на моем ПК обе функции показывают одинаковое значение, это либо особенность архитектуры или влияние ОС на Питон.


Операции сравнения, простые и составные.

>>> 1 < 2
True
>>> 2.0 >= 1      # Числов 1 преобразуется в 1.0
True
>>> 2.0 == 2.0
True
>>> 2.0 == 2      # снова преобразование 2 в 2.0 
True
>>> 2.0 != 2.0    # Проверка на неравенство, false потомоу что 2.0 равно 2.0
False  

Можно комбинировать операторы сравнения, например для проверки вхождения числа в диапазон:

>>> x < y < z         # выражения идентичны, но в первом случае оно короче и быстрее
True
>>> x < y and y < z
True

>>> x < y > z         # более сложные цепочки
False
>>> x < y and y > z
False
>>> 1 < 2 < 3.0 < 4
True
>>> 1 > 2 > 3.0 > 4
False
	  
Рассмотрим пример с комбинацией операторов сравнения:

>>> 1 == 2 < 3      # то же, что и 1 == 2 and 2 < 3
False

- в этом выражении интерпретатор не сравнивает значение False (результат операции 1 == 2) с числом 3 - с технической точки зрения это соответствовало бы выражению 0 < 3, которое должно было бы вернуть True (т.к. True и False - это всего лишь числа 1 и 0, расширенные приписанными им свойствами), а в нашем случае мы получили значение выражения соответствующего "1 == 2 and 2 < 3".    

Запомним эту особенность, т.к. это важно.


Деление, классические, с округлением вниз и истинное.

X / Y  -  в Питон 3.х этот оператор выполняет операцию истинного деления, которая всегда сохраняет дробную часть независимо от типов операндов.

X // Y  - Деление с округлением вниз. Он всегда отсекает дробную часть, округляя результат до ближайшего наименьшего целого независимо от типов операндов.

>>> 10 / 4
2.5
>>> 10 // 4
2
>>> 10 / 4.0
2.5
>>> 10 // 4.0
2.0

- тип результата // зависит от типов операндов, если хотя один из них вещественное число, то и результат будет вещественным числом.
Оператор // используется в программах гораздо чаще чем мы могли подумать, например когда нужен целочисленный результат при деление целочисленных операндов.


Округление вниз и усечение дробной части.

Оператор // также называется оператором деления с округлением вниз - т.е. он округляет результат до ближайшего меньшего целого значения.
Посмтрим несколько примеров:
>>> import math
>>> math.floor(2.5)
2
>>> math.floor(-2.5)
-3
>>> math.trunc(2.5)
2
>>> math.trunc(-2.5)
-2

>>> 5 / 2, 5 / -2
(2.5, -2.5)
>>> 5 // 2, 5 // -2
(2, -3)
>>> 5 / 2.0, 5 / -2.0
(2.5, -2.5)
>>> 5 // 2.0, 5 // -2.0
(2.0, -3.0)

Почему усечение так важно?

>>> (5/2), (5/2.0), (5/-2.0), (5/-2)        # Классическое деление
(2.5, 2.5, -2.5, -2.5)
>>> (5//2), (5//2.0), (5//-2.0), (5//-2)    # Деление с округлением вниз
(2, 2.0, -3.0, -3)
>>> (9/3), (9.0/3), (9//3), (9//3.0)        # Оба оператора  
(3.0, 3.0, 3, 3.0) 
  
- мы видим различие действия операторов и опыт программистов подсказывает нам, что иногда нам нужны будут не просто математические значения, а логические, целочисленные результаты делений для работы программ, поэтмоу нужно внимательно следить за операциями деления и уметь правильно прмиенять оба оператора.


Комплексные числа. стр. 171


Шестнадцатеричная, восьмеричная и двоичная фомы записи чисел.

>>> 0o1, 0o20, 0o377            # восьмеричные литералы
(1, 16, 255)
>>> 0x01, 0x10, 0xff            # шестнадцатеричные литералы      
(1, 16, 255)
>>> 0b1, 0b10000, 0b11111111    # двоичные литералы
(1, 16, 255)

>>> oct(64), hex(64), bin(64)      # встроенные функции по переводу в системы счисления
('0o100', '0x40', '0b1000000')

функция int напротив - переводит числа из системы счисления в десятичную:

>>> int('64'), int('100', 8), int('40', 16), int('1000000', 2)
(64, 64, 64, 64)

Функция eval интерпретирует строку во входном аргументе как программный код на Питоне. Правда с ней нужно обращаться осторожно, иначе можно выполнить какой-то случайный код, например код подсунутый злоумышленниками и получит ьпустой жесткий диск например.

>>> eval('64'), eval('0o100'), eval('0x40'), eval('0b1000000')
(64, 64, 64, 64)

Строковые методы форматирования чисел:

>>> '{0:o}, {1:x}, {2:b}'.format(64,64,64)
'100, 40, 1000000'
>>> '%o, %x, %X' % (64, 255, 255)
'100, ff, FF'


Битовые операции. стр. 174


Другие встроенные стредства.

Рассмотрим модуль math:

>>> import math
>>> math.pi, math.e                       # константы  
(3.141592653589793, 2.718281828459045)
>>> math.sin(2*math.pi/180)               # Синус, тангенс, косинус  
0.03489949670250097
>>> math.sqrt(144), math.sqrt(2)          # Квадратный корень
(12.0, 1.4142135623730951)
>>> pow(2, 4), 2**4                       # Возведение в степень
(16, 16)
>>> abs(-42.0), sum((1,2,3,4))            # Абсолютное значение, сумма
(42.0, 10)
>>> min(3,1,2,4), max(3,1,2,4)            # Минимум, максимум
(1, 4) 

>>> math.floor(2.567), math.floor(-2.567)
(2, -3)
- округление вниз (до ближайшего наименьшего целого)

>>> math.trunc(2.567), math.trunc(-2.567)
(2, -2)
- усечение (отбрасывание дробной части)

>>> int(2.567), int(-2.567)
(2, -2)
- усечение (преобразование в целое число)

>>> round(2.567), round(2.467), round(2.567, 2)
(3, 2, 2.57)
>>> (1/3), round(1/3, 2)
(0.3333333333333333, 0.33) 
- округление (в Питоне 3.х)

Еще примеры вычисления корня:
>>> import math
>>> math.sqrt(144)
12.0
>>> 144 ** .5
12.0
>>> pow(144, .5)
12.0

Из всех этих примеров выделим одно замечание, модули - это внешние компоненты, а встроенные функции постоянно располагаются в пространстве имен, которое используется интерпретатором Питон по умолчанию для поиска имен, используемых программой.
Сейчас для нас актуально правило: если видишь модуль, то сразу вспоминай - импорт.

Пример еще одного импорта - модуль random:
>>> import random
>>> random.random()
0.6384048535018463
>>> random.random()
0.8669699558489125
>>> random.randint(1, 10)
1
>>> random.randint(1, 10)
10
>>> random.choice(['Hi bro', 'Guten tag', 'Hello love!'])
'Hi bro'
>>> random.choice(['Hi bro', 'Guten tag', 'Hello love!'])
'Guten tag'


Другие числовые типы. стр. 177

Числа с фиксированнйо точностью. 

Известны как числа типа - Decimal, по сутия являются вещественными, с фиксированным количеством знаков после запятой.
Причем можно указывать будут ли лишние числа усекаться или округляться, очень удобно для бухгалетрии например.

>>> 0.1 + 0.1 + 0.1 - 0.3
5.551115123125783e-17

- это пример проблемы с ограниченным количеством битовв представлении вещественных чисел.

>>> from decimal import Decimal
>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')
Decimal('0.0')

- вот так решается проблема с битами, с помощью функции Decimal из модуля decimal.

- если одно из чисел будет с двумя знаками (0.01) а остальные с одним (0.1), то рещульатт будет выведен с двумя знаками, Питон автоматически выбирает наибольшую точность.


Настройка точности.

Настройка в модуле decimal позволяет настраивать точность и режим округления (вверх, вниз и т.д.):

>>> import decimal
>>> decimal.Decimal(1)/decimal.Decimal(7)
Decimal('0.1428571428571428571428571429')
>>> decimal.getcontext().prec = 4
>>> decimal.Decimal(1)/decimal.Decimal(7)
Decimal('0.1429')

>>> 1999 + 1.33       # в книге, в этой строке ответ был 2000.32999999999
2000.33               # мой ПК решает всё правильно, странно...          
>>> decimal.getcontext().prec = 2
>>> pay = decimal.Decimal(str(1999 + 1.33))
>>> pay
Decimal('2000.33')


Менеджер конекста объектов класса Decimal.

В Питоне имеется возможность временно переопределять точность с помощью инструкции with менеджера конекстов. После выхода за пределы инструкции настройки восстанавливаются:
>>> import decimal
>>> decimal.Decimal('1.00')/decimal.Decimal('3.00')
Decimal('0.33')
>>> with decimal.localcontext() as ctx:
	ctx.prec = 1
	decimal.Decimal('1.00')/decimal.Decimal('3.00')

  Decimal('0.3')
>>> decimal.Decimal('1.00')/decimal.Decimal('3.00')
Decimal('0.33')


Рациональные числа.

По сути это дроби с числителем и знаменателем, числовой тип называется - Fraction.

Decimal и Fraction, похожи между собой по поведению и некоторым свойствам. Fraction так же находится в модуле.
Чтобы создать объект этого типа, необходимо импортировать модуль и вызвать конструктор класса, передав ему числитель и знаменатель:
>>> from fractions import Fraction
>>> x = Fraction(1, 3)
>>> y = Fraction(4, 6)    # автоматически будет упрощено функцией gcd до 2/3
>>> x
Fraction(1, 3)
>>> y
Fraction(2, 3)
>>> print(y)
2/3

Математические операции:

>>> x + y
Fraction(1, 1)
>>> x - y
Fraction(-1, 3)
>>> x * y
Fraction(2, 9)

Создадим рациональные числа другими способами:

>>> Fraction('.25')
Fraction(1, 4)
>>> Fraction('1.25')
Fraction(5, 4)
>>> Fraction('.25') + Fraction('1.25')
Fraction(3, 2)


Точность.

>>> Fraction(1, 10) + Fraction(1, 10) + Fraction(1, 10) - Fraction(3, 10)
Fraction(0, 1)

- как и в случае с Decimal мы получим точный вывод операции, по сравнению с числом выше - 5.551115123125783e-17

>>> 1/3
0.3333333333333333
>>> Fraction(1, 3)
Fraction(1, 3)
>>> decimal.getcontext().prec = 2
>>> decimal.Decimal(1)/ decimal.Decimal(3)
Decimal('0.33')

- и снова мы видим, что фактически рациональные числа сохраняют точность и автоматически упрощают результат.

>>> (1/3) + (6/12)
0.8333333333333333
>>> Fraction(1, 3) + Fraction(6, 12)
Fraction(5, 6)
>>> decimal.Decimal(str(1/3)) + decimal.Decimal(str(6/12))
Decimal('0.83')


Преобразование и смешивание в выражениях значений разных типов.

Для преобразования в рациональные числа был реализован метод as_integer_ratio, объекты рациональных чисел обладают методом from_float.

- в примерах ниже символ * - это специальный синтаксис распаковывания кортежа в отдельные аргументы, подробнее рассмотрим позднее.

Рассмотрим некоторые способы преобразований как в одну так и другую сторону:

>>> (2.5).as_integer_ratio()
(5, 2)
>>> f = 2.5
>>> z = Fraction(*f.as_integer_ratio())
>>> z
Fraction(5, 2)
>>> x
Fraction(1, 3)
>>> x + z
Fraction(17, 6)
>>> float(x)
0.3333333333333333
>>> float(z)
2.5
>>> float(x + z)
2.8333333333333335
>>> 17/6
2.8333333333333335
>>> Fraction.from_float(1.75)
Fraction(7, 4)
>>> Fraction(*(1.75).as_integer_ratio())
Fraction(7, 4)

При смешивании некоторых типов в выражениях иногда, чтобы сохранить точность, треубется вручную выполнить преобразование в тип Fraction.
>>> x
Fraction(1, 3)
>>> x + 2
Fraction(7, 3)
>>> x + 2.0
2.3333333333333335
>>> x + (1/3)
0.6666666666666666
>>> x + (1./3)
0.6666666666666666
>>> x + (4./3)
1.6666666666666665
>>> x + Fraction(4, 3)
Fraction(5, 3)

- В некоторых случаях при преобразовании вещественного числа в рациональное происходит потеря точности, потмоу что в своем первоначальном виде вещ. число может быть неточным.
- Поэтому нужно иногда вручную упростить число.

>>> 4.0 / 3
1.3333333333333333
>>> (4.0 / 3).as_integer_ratio()        # произойдет потеря точности
(6004799503160661, 4503599627370496)

>>> x
Fraction(1, 3)
>>> a = x + Fraction(*(4.0/3).as_integer_ratio())
>>> a
Fraction(22517998136852479, 13510798882111488)
>>> 22517998136852479 / 13510798882111488       # 5/3 (или близкое к нему!)
1.6666666666666665
>>> a.limit_denominator(10)               # упростить до ближайшего рационального
Fraction(5, 3)


Множества.

По определению, каждый элемент может присутствовать в множестве только в единственном экземпляре, не смотря на на то сколько раз он будет добавлен.
Множества применяются чаще в приложениях обработки числовых данных и при работе с БД.

Основы множеств.

Создать объект множества можно функцией set, передав ей последовательность или др. объект, поддерживающий итерации:

>>> x = set('abcde')
>>> y = set('bdxyz')
>>> x
{'a', 'c', 'b', 'd', 'e'}
>>> 'e' in x                # Проверка вхождения в множество
True
>>> x - y                   # Разность множеств   
{'a', 'c', 'e'}
>>> x | y                   # Объединение
{'a', 'z', 'x', 'y', 'c', 'b', 'd', 'e'}

>>> x & y                   # Пересечение  
{'b', 'd'}
>>> x ^ y                   # Симметрическая разность (XOR) 
{'a', 'z', 'x', 'y', 'c', 'e'}

>>> x > y, x < y            # Надмножество, подмножество
(False, False)


Методы (весь перечень смотрите п офункции dir):

add - вставляет новый элемент в множество;
update - выполняет объединение;
remove - удаляет элемент по его значению.   

>>> z = x.intersection(y)
>>> z
{'d', 'b'}
>>> z.add('spam')
>>> z
{'d', 'spam', 'b'}
>>> z.update(set(['x', 'y']))
>>> z
{'y', 'd', 'x', 'spam', 'b'}
>>> z.remove('b')
>>> z
{'y', 'd', 'x', 'spam'}

Операторы родственные упомянутым выше могут работать с любыми объектами итерируемых типов:

>>> s = set([1, 2, 3])
>>> s | set([3, 4])
{1, 2, 3, 4}
>>> s | [3, 4]
Traceback (most recent call last):
  File "<pyshell#121>", line 1, in <module>
    s | [3, 4]
TypeError: unsupported operand type(s) for |: 'set' and 'list'
>>> s.union([3, 4])
{1, 2, 3, 4}
>>> s.intersection((1, 3 , 5))
{1, 3}
>>> s.issubset(range(-5, 5))
True


Изменения в Питон 3.х

>>> set([1, 2, 3, 4])
{1, 2, 3, 4}
>>> {1, 2, 3, 4}        # Питон 3.х
{1, 2, 3, 4}

- эти два способа идентичны.

В Питон 3.х встроенная функция set всё еще необходима для создания пустых множеств и конструировании множеств на основе итерируемых объектов.

>>> set('spam')
{'p', 'm', 's', 'a'}
>>> s = {'s', 'p', 'a', 'm'}
>>> s.add('alot')
>>> s
{'alot', 'm', 'p', 'a', 's'}

Обратим внимание, что конструкция {} по-прежнему создает пустой словарь.

>>> s1 = {1, 2, 3, 4}
>>> s1 - {1, 2, 3, 4}         # вывод пустого множества
set()
>>> type({})                  # литерал {} обозначает пустой словарь   
<class 'dict'>
>>> s = set()                 # инициализация пустого множества
>>> s.add(1.23)
>>> s
{1.23}


Ограничения, связанные с неизменяемостью и фиксированные множества.

Множества могут включать объекты только неизменяемфых (так называемый "хешируемых") типов.
Отсюда следует, что списки и словари не могут добавляться в множество, однако можно исполььзовать кортежи, если необходимо сохранить составные значения.
>>> s
{1.23}
>>> s.add([1, 2, 3])
TypeError: unhashable type: 'list'
>>> s.add({'a':1})
TypeError: unhashable type: 'dict'
>>> s.add((1, 2, 3))
>>> s
{1.23, (1, 2, 3)}
>>> s | {(4, 5, 6), (1, 2, 3)}
{1.23, (4, 5, 6), (1, 2, 3)}
>>> (1, 2, 3) in s
True
>>> (1, 4, 3) in s
False
 
Кортежи в множествах могут использоваться, например, для хранения дат, записей, IP-адресов и т.д.
Сами по себе множества нельзя добавлять в другие множества, но с помощью функции frozenset можно, она которая создает неизменяемое множество, которое невозможно изменить, и это дает возможность добавлять.


Генераторы множеств.

>>> {x ** 2 for x in [1, 2, 3, 4]}
{16, 1, 9, 4}

Мы видим, что генераторы множеств, как и в случае с генератором списков выполняет свою работу так - "Вернуть множество, содержащее квадраты значений х, для каждого х из списка".

>>> {x for x in 'spam'}
{'p', 'm', 's', 'a'}

>>> {c * 4 for c in 'spam'}
{'ssss', 'pppp', 'aaaa', 'mmmm'}
>>> {c * 4 for c in 'spamham'}
{'ssss', 'hhhh', 'pppp', 'aaaa', 'mmmm'}

>>> s = {c * 4 for c in 'spam'}
>>> s | {'mmmm', 'xxxx'}
{'xxxx', 'mmmm', 'ssss', 'pppp', 'aaaa'}
>>> s & {'mmmm', 'xxxx'}
{'mmmm'}


Где могут использоваться множества?

Помимо математических вычислений множества могут использоваться в ряде прикладных областей.

Используя уникальность множеств можно использовать их для фильтрации повторов в других коллекциях.

>>> l = [1, 2, 1, 3, 2, 4, 5]
>>> set(l)
{1, 2, 3, 4, 5}
>>> l = list(set(l))
>>> l
[1, 2, 3, 4, 5]
  
Можно также использовать множества для хранения пунктов, которые уже были посещены в процессе обхода графа или другой циклической структуры.

Множества удобно использовать при работе с большими массивами данных (например запросы к БД) - операция пересечения двух множеств позволит получить объекты, присутствующие сразу в обеих категориях, а объединение - все объекты, присутствующие в любом из множеств.

>>> engin = {'bob', 'sue', 'ann', 'vic'}
>>> manag = {'tom', 'sue'}
>>> 'bob' in engin              # bob инженер?
True
>>> engin & manag               # Кто одновременно инженер и менеджер?
{'sue'}
>>> engin | manag               # Все сотрудники из обеих категорий    
{'tom', 'vic', 'bob', 'ann', 'sue'}
>>> manag - engin                   # Менеджеры не являющиеся инженерами
{'tom'}
>>> engin - manag               # Инженеры не являющиеся менеджерами
{'bob', 'ann', 'vic'}
>>> engin > manag               # Все менеджеры являются инженерами? (надмножество)
False
>>> {'bob', 'sue'} < engin      # Оба сотрудники инженеры? (подмножество)
True
>>> (manag | engin) > manag     # Множество всех сотрудников является 
True                              надмножеством менеджеров

>>> manag ^ engin               # Сотрудники принадлежащие какой-то одной категории
{'bob', 'ann', 'tom', 'vic'}
>>> (manag | engin) - (manag ^ engin)    # Пересечение!
{'sue'}

   

Логические значения.

Официально в Питон имеется логический тип bool, с двумя предопределенными значениями True и  False. Эти значения являются экземплярами класса bool, который в свою очередь является всего лишь подклассом (в ООП смысле) целочисленного типа int.
True и False ведут себя как целочисленные значения 1 и 0, за исключением, что выводятся на экран они по-другому.
Нужно внимательно следить, т.к. из-за особенности этого типа можно получить интересные результаты:

>>> type(True)
<class 'bool'>
>>> isinstance(True, int)
True
>>> True == 1
True
>>> True is 1
False
>>> True or False         # то же, что и 1 or 0 
True
>>> True + 4              # а вот и обещанный прикол, получилось как-будто 1 + 4
5


Числовые расширения.

Поскольку числовая обработка данных является популярным применением Питон вы найдете массу дополнительных инструментов.

Напрмиер расширение - NumPy (Numeric Python). Это расширение нужно устанавливать отдельно, оно не идет с Питоном вместе.



Глава 6. Интерлюдия о динамической типизации. стр. 194 

В этой главе мы детально ознакомимся с самой фундаментальной идеей языка Питон - динамической типизацией и полиморфизмом, которые составляют основу гибкости этого языка программирования.

Простым языком - полиморфизм, это когда одна функция (оператор, метод) могут по-разному выполняться для разных типов объектов, как например оператор + по-разному действует для чисел и строк.


Остутствие инструкций объявления.

Типы данных в Питон определяются автоматически во время выполнения, а не в результате объявления в программном коде (в отличие от С++ или Java).


Переменные, объекты и ссылки.

Отметим, что когда выполняется операция присваивания, типо a = 3, интерпретатор выполняет её, хотя перед этим ему нигде не сообщалось, что а - это имя переменной и тип - целочисленный объект.
В Питоне это происходит естественным способом:
 
- Создание переменной - переменная (т.е. имя), такая как a, создается автоматически когда в программном коде ей впервые присваивается значение.
Если переменная а уже есть то она просто получает новое значение

- Типы переменных - переменные не имеют никакой информации о типе или ограничениях, связанных с ним. Понятие типа присуще объектам, а не именам. Т.е. у нашей переменной "а" тип имеется лишь у объекта - 3 (целочисленный тип), а не у самой переменной "а". 
Переменные универсальны, они являются лишь ссылками на конкретные объекты в конкретные моменты времени.

- Использование переменной - когда переменная учатсвует в выражении её имя замещается объектом на который она ссылается в настоящий момент.
Конечно перед использованием переменную нужно инициализировать, иначе будет вызвана ошибка.

Рассмотрим команду а = 3, она выполняется в 3 этапа:

- создается объект, представляющий число 3;
- создается переменная а, если она еще отсутствует;
- в переменную а записывается ссылка на вновь созданный объект, представляющий число 3.

Имя - ссылка - объект

Кстати объекты могут ссылаться на другие объекты, например список ссылается на объекты из своего списка.
А переменные не могут ссылаться на другие переменные, только на объекты.

Ссылки на объекты это, своего рода, ассоциативные связи, реализованные в виде указателя на область памяти.

Переменные - это записи в системной таблице, где предусмотрено место для хранения ссылок, на объекты.

Объекты - это области памяти с объемом, достаточным для представления значений этих объектов.

Ссылки - это автоматически разыменовываемые указатели на объекты.


С технической точки зрения объекты не так просты. Они имеют два поля: описатель типа - хранит информацию о типе объекта и счетчик ссылок - используемый для определения когда память, занимаемая объектом, может быть освобождена.


Информация о типе хранится в объекте, но не в переменной.

>>> a = 3         # тип - целое число
>>> a = 'spam'    # тип - строка
>>> a = 1.23      # тип - вещественное число

- здесь у нас изменяется ссылка на объект, а не изменение типа переменной с числа на строку и обратно. Т.е. мы видим как переменная ссылается на конкретный объект в конкретный момент времени.

Итак, типы в Питон - это свойство объекта, а не переменной. Объект сам знает какого он типа, переменной эта информация не нужна.


Объекты уничтожаются автоматически. стр.198. 

>>> a = 3        
>>> a = 'spam'    

Каждый раз когда имя ассоциируется с новым объектом Питон освобождает память, занимаемую предыдущим объектом (если на него не ссылается какое-либо другое имя или объект).
Это называется - сбокрой мусора (garbage collection).

x = 42
x = 'spam'
x = 3.1415
x = [1, 2, 3]

- так, с условием, что на объекты не ссылаются другие переменные или объекты, с каждым новым присвоением х уничтожается старый объект.

Это происходит благодаря счетчику ссылок, с помощью которого интерпретатор следит за ссылками на объект. Как только счетчик равен 0 объект уничтожается.


Разделяемые ссылки.

>>> a = 3
>>> b = a

В итоге получается такая схема - имена a, b ссылаются своиими ссылками на один и тот же объект.
Это называется - разделяемая ссылка, несколько имен ссылаются на один и тот же объект.

Если мы теперь изменим а, то ситуация будет следующей:

>>> a = 3
>>> b = a
>>> a = 'spam'
>>> b
3

Т.е. мы видим, что ссылка у переменной b осталась на объект - 3, а ссылка переменной а изменилась, она стала на объект - 'spam'.
Теперь оба имени ссылаются на разные объекты.

И наоборот - при изменении b ссылка a не изменилась бы, а как и раньше ссылалась бы на объект - 3.

>>> a = 5
>>> b = a
>>> a = a + 6
>>> b
5

- даже такая сложная схема по-прежнему иллюстрирует, что оба имени ссылаются на разные объекты в конце выражений.


Разделяемые ссылки и изменяемые объекты.

Не забываем, что в Питон существуют объекты и операции, которые изменяют сами объекты. Например изменения элемента списка изменяют сам список.

>>> l1 = [1, 2, 3]
>>> l2 = l1

- применим одну из операций к спискам:

>>> l1[0] = 24
>>> l1
[24, 2, 3]
>>> l2
[24, 2, 3]

- здесь мы изменяем, не сам объект l1, а компонент объекта, и в итоге изменяется сам объект и получаем также изменение в переменной l2!

! - Такое поведение объектов нужно запомнить и внимательно следить за разработкой ваших программ, ведь можно не заметить как изменение одного объекта может привести к изменению другого и вы получите результат, которого совсем не ожидали. Тщательно проверяйте весь код.

Избежать такого поведения языка Питон можно выполнять копирование объектов, вместо создания ссылок.
Это можно сделать с помощью функции list и модуля copy из стандартной библиотеки.
Однако самый стандартный способ копирования это получение среза от начала до конца списка:

>>> l1 = [2, 3, 4]
>>> l2 = l1[:]
>>> l1[0] = 24
>>> l1
[24, 3, 4]
>>> l2
[2, 3, 4]

Словари нужно копировать другим способом, т.к. они не являются последовательностями. Чтобы скопировать словарь необходимо воспользоваться методом X.copy().

>>> import copy
>>> x = copy.copy(y)      # Создание "поверхностной" копии любого объекта y 
>>> x = copy.deepcopy(y)  # Создание полной копии: копируются все вложенные ссылки

- В число объектов, подверженных описанным выше изменениям входят такие объекты как - списки, словари и некоторые объекты, объявленные с помощью инструкции class.



Разделяемые ссылки и равенство.

>>> x = 42
>>> x = 'spam'

Т.к. интерпретатор Питона кэширует и повторно использует малые целые числа и небольшие строки, объект 42 скорее всего не будет уничтожен. Он останется в системной таблице для повторного использования (вдруг нам снова понадобится какой-нибудь объект равный 42).
Но это относится только к малому числу объектов, например к таким как - малые целые числа и небольшие строки.


Равенства.

>>> l = [1, 2, 3]
>>> m = l           # ссылка на один и тот же объект

>>> l == m          # Одно и то же значение
True
>>> l is m          # Один и тот же объект    
True

- т.е. оператор  ==  сравнивает значения объектов, а оператор - is проверяет идентичность объектов, т.е. ссылаются ли оба имени на один и тот же объект.

Если точнее, то is сравнивает указатели, которые реализуют ссылки и, т.о., может использоваться для выявления разделяемых ссылок в программном коде.

Для проверки простого равенства достаточно == (он чаще и используется).

>>> l = [1 ,2 , 3]
>>> m = [1, 2, 3]
>>> l == m
True
>>> l is m          # значения одинаковы, а объкты разные
False  

- видим наглядную разницу операторов.

Еще один интересный пример:

>>> x = 42
>>> y = 42
>>> x == y
True
>>> x is y
True

- здесь мы видим как переплетаются операторы сравнения и особенности кэширования в Питон, в результате видим, что обе переменные ссылаются на один объект, хотя, теоретически, должны ссылаться на разные объекты.

Мы можем запрашивать у интерпретатора количество ссылок на объект. Функция getrefcount из модуля sys возвращает значения поля счетчика ссылок в объекте.

>>> import sys
>>> sys.getrefcount(x)
11
>>> sys.getrefcount(1)
1156
>>> sys.getrefcount(y)
11
>>> sys.getrefcount(42)
12
>>> sys.getrefcount(1)
1156

- большая часть ссылок была создана системным программным кодом самой IDLE (например число 1).
Т.к. строки и числа не могут изменяться совершенно не важно сколько ссылок будет указывать на один и тот же объект, главное нужно запомнить, что в Питоне есть автоматическая сборка мусора и она реально работает.



Глава 7. Строки. стр. 207

Строки - упорядочненные последовательности символов, используемые для хранени и представления текстовой информации.

С функциональной точки зрения строки могут использоваться для представления всего, что может быть выражено в текстовой форме: символы и слова, содержимое текстовых файлов, загруженных в память, адреса в Интернете, программы на Питоне и т.п. И также для хранения двоичных значений байтов и символов Юникода.

Строки в Питоне играют ту же роль, что и массивы символов в С.  

Фактически, строки - это первый представитель большого класса объектов, называемых последовательностями. 
Строки неизменяемы, т.е. символы, которые они содержат, имеют определенный порядок следования слева направо и сами строки невозможно изменить.

стр. 208 табл. "Наиболее типичные литералы строк и операции"  

Литералы строк.

Строки в апострофах - 'spa"m'
Строки в кавычках - "spa'm"
Строки в тройных кавычках - '''...spam...''', """...spam..."""
Экранированные последовательности - "s\tp\na\0m"
Неформатированные строки - r"C:\new\test.spm"
Строки байтов в версии 3.0 - b'sp\x01am'
 

Строки в апострофах и кавычках.

>>> 'spam', "spam"      # строки в кавычках и апострофах идентичны
('spam', 'spam')
 
Такая транскрипция написания строк нужна для того, чтобы вставлять символы апострофа и кавычек в строки без использования слеша:

>>> "knight's", 'knight"s'    # вот такой простой пример использования обоих способов
("knight's", 'knight"s')

- можно и простой слеш использовать:

>>> "knight\"s", 'knight\'s'     # при этом меняется строка вывода, заметьте
('knight"s', "knight's")         # в выводе в строке нет набора символов одного типа  


Питон автоматически объединяет последовательность строковых литералов внутри выражения, хотя можно бы и добавить оператор + но Питон автоматически проводит конкатенацию строк:

>>> title = "Peace " 'of' " sheet"
>>> title
'Peace of sheet'

- а если поставим запятые, то получим кортеж, а не строку: 

>>> title = "Peace ", 'of', " sheet"
>>> title
('Peace ', 'of', ' sheet')


Экранированные последовательности представляют служебные символы.

С помощью слеша вставляются специальные символы, известные как - экранированные последовательности.
Экранированные последовательности удобно использовать для вставки в строки служебных символов.

>>> s = 'a\nb\tc'

\n - байт, содержащий двоичное значение кода символа новой строки

\t - символ табуляции

>>> s
'a\nb\t\c'
>>> print(s)
a
b  c

>>> len(s)
5

- длина этой строки 5 байтов, хотя в выводе функции print мы видим всего 3 символа.

стр. 212 - таблица "Экранированные последовательности"

>>> s = 'a\0b\0c'       # в этой строке два нулевых байта 
>>> s
'a\x00b\x00c'
>>> print(s)
a'null'b'null'c
>>> len(s)
5

В Питоне нулевой байт (символ null) не является признаком завершения строки, как в языке С.

Еще пример, запишем строку, в которой указаны двоичные значения 1 и 2 (записанные в восьмеричной форме), и далее следует двоичное значение 3 (записанное в шестнадцатеричной форме).

>>> s = '\001\002\x03'
>>> s
'\x01\x02\x03'

- мы видим, что интерпретатор Питон отображает непечатаемые символы в шестнадцатеричном представлении, независимо от того, в каком виде они были указаны внутри литерала.

>>> s = "s\tp\na\x00m"
>>> s
's\tp\na\x00m'			# \x00 - это нулевой символ в шестнадцатеричном представлении
>>> len(s)
7
>>> print(s)
s p
a m

Если интерпретор не понимает символ после слеша как корректный служебный символ, он просто соатвляет символ обратного слеша в строке: 

>>> x = "C:\py\code"
>>> x
'C:\\py\\code'
>>> print(x)
C:\py\code


Еще одно замечание, если нам требуется работать с двоичными данными, то открывать файлы с ними нужно в режиме двоичного доступа (добавляя к флагу режима открытия флаг b, например - 'rb', 'wb' b т.д.).
В Питоне 3.0 содержимое двоичных файлов интерпретируется как коллекция строк типа bytes, которые по своим возможностям напоминают обычные строки. 



Неформатированные строки подавляют экранирование.

Обратим внимание на команду, с помощью которой мы хотим открыть файл text.txt из папки C:\new - 

mytest = open('C:\new\text.txt', 'w')

- здесь мы видим в чем будет заключаться подводные камни: последовательность \n интерпретируется как символ новой строки, а последовательность \t замещается символом табуляции, и в итоге мы получим ошибку:

>>> mytest = open('C:\new\text.txt', 'w')
Traceback (most recent call last):
  File "<pyshell#9>", line 1, in <module>
    mytest = open('C:\new\text.txt', 'w')
OSError: [Errno 22] Invalid argument: 'C:\new\text.txt'


Именно в таких случаях удобно использовать неформатированные строки, для этого перед кавычками ставим символ r (в верхнем или нижнем регистре), он отключает механизм экранирования.

>>> mytest = open(r'C:\new\text.txt', 'w')
>>> mytest
<_io.TextIOWrapper name='C:\\new\\text.txt' mode='w' encoding='cp1251'>

Ну или, конечно, можно просто продублировать символы слеша:

>>> mytest = open('C:\\new\\text.txt', 'w')

Сам интерпретатор Питон, в определенных случаях, использует удваивание обратного слеша при выводе строк, обратный слеш:  

>>> path = r'C:\new\text.txt'
>>> path
'C:\\new\\text.txt'				# вот так интерпретатор представляет эту строку
>>> print(path)
C:\new\text.txt					# более дружественный формат представленя		
>>> len(path)
15
 
Так же как и с числами, при выводе результатов в интерактивной оболочке по умолчанию используется такой формат представления, как если бы это был программный код, отсюда и экранирование символов обратного слеша.
А инструкция print обеспечивает более дружественный формат. 
 

Помимо хранения имен каталогов в Windows, неформатированные строки обычно используются для регулярных выражений (поиск по шаблону, благодаря модулю re).
Следует отметить, что в сценариях Питона, в строках с именами каталогов систем Windows и Unix можно использовать простые символы слеша, потому что Питон стремится поддерживать переносимость для путей к файлам. 
И все же для каталогов в стиле Windows удобнее использовать неформатированные строки.


Замечание.
Даже неформатированная строка не должна заканчивать символом обратного слеша, иначе он заэкранирует собой закрывающую кавычку:

r"...\"   -  недопустимый строковый литерал!

Если такая необходимость есть, можно добавить два символа и затем удалить второй из них (r'1\nb\tc\\'[:-1]), добавить один символ вручную (r'1\nb\tc'+'\\') или использовать обычный синтаксис и дублировать все символы обратного слеша ('1\\nb\\tc\\') 



Тройные кавычки, многострочные блоки текста.

Этот формат иногда называют блочной строкой, который удобно использовать для определения многострочных блоков текста в программном коде.

Синтаксис состоит из трех символов кавыек (или апострофов), которые закрываются такими же тремя кавычками.
Внутри такой строки могут находиться и кавычки и апострофы, при этом их не нужно экранировать.

Примеры:

>>> mantra = """Always look
 on the dright
 side of life."""
>>> mantra
'Always look\n on the dright\n side of life.'
>>> print(mantra)
Always look
 on the dright
 side of life.
 
>>> man = """One
 two
 three."""
>>> man
'One\n two\n three.'

>>> man = """One			# здесь я сознательно после перевода строки удалил пробел перед three
  two
three."""					# оказывается, после перевода строки, в таком формате,
                              автоматически ставится пробел перед след строкой  
>>> man
'One\n  two\nthree.'		# как мы и видим, пробела нет и далее print нам всё покажет еще раз
>>> print(man)
One
  two
three.   

>>> mantra = """ Always look 	
 on the dright
 side of life."""				# вот я перед словом Always поставил пробел и все строки на одном
								  уровне стали, как видно после вывода инструкции print	
>>> print(mantra)
 Always look
 on the dright
 side of life.


Таким нехитрым способом мы можем пользоваться если нам необходимо ввести в программе многострочный текст, например сообщение об ошибке или код разметки на HTML или XML.


Еще одно применение тройных кавычек, это хакерский способ отключения строк программного кода во время разработки. 
Например если нам требуется отключить большой участок кода это довольно неудобно ведь в таком случае в сотне строк кода нужно ставить знак комментариев в каждой строке.
Но можно воспользоваться такой "хитростью":   

x = 1
"""
import os
print(os.getcwd())
"""
y = 2
 


Строки в действии. стр. 217

Базовые операции.

 

   


       
   
