
Т.к. в учебнике по Питону сразу написано о прикладном программировании, то сразу же поясним этот момент, что такое и с чем его едят.

# Прикладное программирование

Прикладная программа или приложение — программа, предназначенная для выполнения определённых задач и рассчитанная на непосредственное взаимодействие с пользователем. В большинстве операционных систем прикладные программы не могут обращаться к ресурсам компьютера напрямую, а взаимодействуют с оборудованием и другими программами посредством операционной системы. Также на простом языке — вспомогательные программы.

К прикладному программному обеспечению относятся компьютерные программы, написанные для пользователей или самими пользователями для задания компьютеру конкретной работы. Программы обработки заказов или создания списков рассылки — пример прикладного программного обеспечения. Программистов, которые пишут прикладное программное обеспечение, называют прикладными программистами.

Подразделения на группы прикладных программ:
 
    программные средства общего назначения
        Текстовые редакторы
        Текстовые процессоры
        Системы компьютерной вёрстки
        Графические редакторы
        СУБД
        Электронные таблицы
        Веб-браузеры
    программные средства развлекательного назначения
        Медиаплееры
        Компьютерные игры
    программные средства специального назначения
        Экспертные системы
        Трансляторы
        Мультимедиа-приложения (медиаплееры, программы для создания и редактирования видео, звука, text-to-speech и пр.)
        Гипертекстовые системы (электронные словари, энциклопедии, справочные системы)
        Системы управления содержимым
    профессиональные программные средства
        САПР
        АРМ
        АСУ
        АСУ ТП
        АСНИ
        Геоинформационные системы
        Биллинговые системы
        CRM
        CTRM/ETRM — системы управления складом
        SRM (Supplier Relationship Management) — системы управления взаимоотношениями с поставщиками
        BI (Business Intelligence) — аналитические системы
        DMS (Document Management System) — Система управления документами/Система автоматизации документооборота (системы электронного документооборота)
        CMS (Content Management System) — системы управления содержимым (контентом)
        WMS (Warehouse Management System) — системы управления складом (СУС)
        ERP-системы — системы планирования ресурсов предприятия
        EAM-системы — системы управления основными фондами предприятия
        MRM-системы — системы управления маркетинговыми ресурсами
        MES-системы — системы оперативного (цехового) управления производством и ремонтами
        Интеграционные шины данных (ESB)

По этому списку становится более ясно и понятно, что такое прикладное программирование и прикладные программы - приложения (не заметил в самом начале это понятного слова).

Стр. 45 
Автор упоминает о том, что одним из минусов Питона является скорость выполнения приложений, она не так высока как у С/С++, т.к. Питон это интерпретируемый ЯП.
Но вместе с тем Питон можно использовать для "быстрый" приложений, это достигается комбинированием компилированных и оптимизированных библиотек расширения. Т.е. для ускоренных вычислений мы должны выделить из приложения компоненты, требующие скорости, в виде компилированных расширений и связать их системой сценариев на Питоне.
Как это делается пока не известно, но нужно держать такие моменты в голове, нужно будет изучить далее.

стр. 47 
Список компаний и областей где активно используется Питон.

стр. 48
Области применения Питон:
- Системное программирование. Питон применяется для создания переносимых программ и утилит системного администрирования (так называемыми инструментами командной оболочки).
- Графический интерфейс. Тут всё понятно, пишется GUI для разных ПО.
- Веб-сценарии. Например пакет mod_python предназначен для запуска сценариев на языке Питон по управлением веб-сервера Апач (что очень нам подходит, т.к. у нас как раз Апач и стоит).
Также существуют пакеты веб-разработки, один из популярных это - Django и пр. (в т.ч. технология веб - MVC).
- Интеграция компонентов. Позволяет интегрировать код на Питоне в различные ЯП и приложения различных ОС.
- Приложения баз данных. В Питоне имеются интерфейся для работы со всеми основными реляционными БД.
- Быстрое создание прототипов. Информация об объединении нескольких модулей на разных ЯП, пока не понятно для меня, надеюсь дальше станет яснее.
- Программирование математических вычеслений. Расширение NumPy для математических вычислений, за счет интеграции с математическими библиотеками, написанными на компилирующих языках программирования - превращает Питон в сложный, но удобный инструмент программирования математических вычислений.   
- Игры, изображения, искусственный интеллект, XML, управление роботами и многое другое.

стр. 53
- Питон объектно-ориентированный язык. Но при этом ООП не является обязательным, Питон поддерживает и процедурный стиль программирования.
- Питон свободный ЯП.
- Питон переносим, т.е. на разных ОС один и тот же код, использующий стандартные библиотеки, будет выполняться интерпретатором без проблем (должен выполняться).
- Питон мощный ЯП. Динамическая типизация (привет Руби!); автоматическое управление памятью; модульное программирование (можно создавать модули, классы, исключения); встроенные типы объектов (строки, списки, словари); встроенные инструменты (конкатенация, сортировка, и т.д.); библиотеки утилит; утилиты сторонних разработчиков.
- Питон соединыемый. программы на Питоне могут с легкостью "склеиваться" с компонентами, написанными на других ЯП. Например пишем программу на Питоне, а потом по частям перенести на С (для скорости, например).
- Питон удобен.
- Питон прост в изучении. Хотя эта книга занимает почти 1300 страниц...
- Питон назван в честь комедийного сериала "Монти Пайтон". Может нужно произносить Пайтон, а не Питон, но буду писать здесь - Питон, потом переучимся, если что.


Интерпретатор - это такой модуль, который исполняет другие программы. Когда мы пишем код на Питоне, интерпретатор читает нашу программу и выполняет её инструкции. По сути, интерпретатор - это слой программной логики между нашим программным кодом и аппаратурой нашего ПК.

Схема выполнения программ на Питоне:

Исходный текст (m.py) -- Байт-код (m.pyc) -- Выполнение (PVM)

Интерпретатор транслирует текст программы (инструкции) в байт-код - низкоуровневое, платформонезависимое представление исходного текста программы.

Как только программа скомпилируется в байт-код он передается виртуальной машине Питон (PVM) - привет Java! Формально, PVM это последняя составляющая того, что называют интерпретатором Питон.

Интерпретатор Jython (первоначальное - JPython) - альтернативная реализация Питона с тесной интеграцией с Java. В ней код на Питоне компилируется в байт-код Java, а затем передается JVM (вирутальной машине Java).

IronPython - реализация Питона предназначена для обеспечения интеграции программ с приложениями, созданными для работы в среде Microsoft .NET Framework и Mono - открытом эквиваленте для ОС Linux.

Существует еще динамический компилятор Psyco, который во время компиляции переводит некоторые части байт-кода в двоичный код, для ускорения.

Shedsckin C++ транслирует код Питона в код на С++, который затем можно скомпилировать в машинный код. На момент создания книги он был в стадии тестирования и доработки, может уже в промышленных масштабах используетс, нужно проверить.

Также программы на Питоне можно переводить в настоящие исполняемые файлы (по типу .exe в Windows), которые объединяют в себя байт-код программы, PVM (интерпретатор) и файлы поддержки, необходимые программе.

В среде Питон файлы, в которых сохранен код, называют - модулями. Часто их называют программами на языке Питон. Файлы модулей, которые запускаются на выполнение непосредственно, иногда называют - сценариями, этим неофициальным термином обозначаются файлы программ верхнего уровня. Термин модуль зарезрвирован для обозначения файлов, которые могут импортироваться другими файлами.


В Unix системах возможно понадобится вводить путь к самому Питону, что-то типа /usr/bin/pythhon чтобы запускать программы (сценарии).



! - Ознакомимся с инструкциями import и from. И изучим запуск программ, модулей, сценариев.


# Первый сценарий на Питоне
import sys
print(sys.platform)
print(2*8)
x = 'Spam'
print(x*8) 

- импортирует модуль Python (библиотеку дополнительных инструментов), чтобы позднее получить название платформы
- sys.platform это просто строковая переменная, содержимое которой идентифицирует тип компьютера, на котором выполняется сценарий. 
- трижды вызывает функцию print и отображает результаты
- создает переменную x, которая создается в момент присваивания ей строкового объекта 

Заметим, что мы сохранили этот сценарий под именем script1.py хотя можно было и без расширения, но расширение *.py подразумевает, что сценарий можно будет в дальнейшем импортировать. Поэтому указываем его, т.к. этим действием мы обеспечим возможность дальнейшего использования кода.


Данные вывода можно передать в файл (например текстовый)командой:

script1.py > info.txt

- т.о. мы наблюдаем т.н. "Перенаправление потоков"


В Unix можно указывать специальный комментарий, который сможет запускать сценарий без указания пути к Питону.
Т.н. "hash bang":

#!/usr/bin/python
print("Hello men")


стр. 90 - о команде env, которая позволит запустить Питон если вы не знаете его расположение на компьютере.


Кстати напомним, что если в конце сценария добавить функцию input() то после вывода данных программы командная строка не закроется сама (как это может быть если мы запустим программу в Виндовс нажатием на ярлык файла).

В Питоне 3.0 функция input() заменила собой функцию raw_input() из Питона 2.6


! - О модулях.

Итак, каждый файл с исходным текстом на Питоне, имя которого оканчивается расширением .py является модулем.
Другие файлы могут обращаться к программным компонентам, объявляемым модулем, импортируя этот модуль.

По сути, инструкция import (здесь впервые мы делаем акцент на различиях инструкций и функций в Питоне, далее будем пытаться понять в чем они различаются и вообще понимать суть обоих терминов)

В итоге, после импорта, содержимое модуля становится доступным внешнему миру через его атрибуты.

Модульная система является центральной идеей Питона.

Крупные программы обычно организованы в виде множества файлов модулей, которые импортируют и испольщуют функциональные возможности из другших модулей. При этом один из модулей определяется как основной файл верхнего уровня, который запускате всю программу.

Отметим, что операция импорта, на заключительном этапе. приводит к выполнению программного кода загружаемого файла. Т.о. импорт файла является еще одним способом запустить его.

-- Поработаем с импортом модулей (файлов).

скопируем наш script1.py в папку с Питоном (C:\Python34) и попробуем его импортировать.

>>> import script1
win32
256
SpamSpamSpamSpamSpamSpamSpamSpam

- видим, что мы запустили выполнение инструкций в этом модуле/файле (см. выше о запуске).

>>> import script1
>>> import script1

- а новая попытка импорта ни к чему не привела, интерпретатор не выполняет никаких действий и не выводит ничего. Даже если мы изменим теперь script1.py все равно ничего не будет выводиться.

Однократный запуск модуля при импорте сделан специально - т.к. эта операция требует слишком больших затрат вычислительных ресурсов, чтобы выоплнять её несколько раз в ходе выполнения программы.

- маленькое отступление - В ходе выполнения импорта, производится поиск файлов, компиляция их в байт-код и выполнение этого байт-кода. Вот почему операция затратная.


Для многократного запуска файла в одном сеансе можно воспользоваться встроенной функцией reload, доступной в модуле imp из стандартной библиотеки. В Питоне 2.6 эта функция была обычной встроенной, но в Питоне 3.0 она была перенесена в модуль imp.

>>> from imp import reload
>>> reload(script1)
win32
256
SpamSpamSpamSpamSpamSpamSpamSpam
<module 'script1' from 'C:\\Python34\\script1.py'>

- Инструкция from в этом примере просто копирует имя функции из модуля. Функция reload загружает и запускает текущую версию программного кода в файле. 
Даже если файл был изменен в другом окне reload также выводит и изменения (изменили 2*8 на 2*10):  

>>> reload(script1)
win32
1024
SpamSpamSpamSpamSpamSpamSpamSpam
<module 'script1' from 'C:\\Python34\\script1.py'>
        
- только не забываем изменять модуль (script1) котоырй находится именно в папке с Питоном, а не где-то еще откуда оне был скопирован - наступил на эти грабли, изменял script1.py, который был в папке D:\Job\python и удивлялся - почему не видно изменений в интерпретаторе.  
 

Еще одно замечание - функция reload ожидает получить имя уже загруженного модуля, поэтому модуль нужно перед этим импортировать (что мы и сделали вначале).

Заметим, что reload - это функция, которая вызывается (поэтому нужны скобки вокруг имени модуля), import - это инструкция, и скобок не нужно когда что-то импортируем.

<module 'script1' from 'C:\\Python34\\script1.py'>  -  это дополнительная строка, представление результата, возвращаемого функцией reload после перезагрузки модуля. Более подробно обсудим её позднее.


Можно импортировать модуль imp (import imp) и затем использовать синтаксис - imp.reload(M) или так как мы обсудили выше. Этот новый синтаксис формата - module.attribute


Особенность - имена, загруженные с помощью инструкции from, не обновляются вызовом функции reload, а имена, загруженные инструкцией import - обновляются, как мы видели из примеров выше.

   

! - О модулях. Атрибуты. стр. 97

В широком понимании модули играют роль библиотек инструментов. Модуль - это, главным образом, всего лишь пакет имен переменных, известный как - пространство имен. Имена внутри этого пакета называются атрибутами, т.е. атрибут - это имя переменной, которая связана с определенным объектом (таким как модуль).

В типичном случае импортирующий программный код получает доступ ко всем именам верхнего уровня, определяемым в файле модуля.
Эти имена обычно связаны с функциональными возможнстями, экспортируемыми модулем - функциями, классами, переменными и т.д., которые предназначены для использования в других файлах и программах.

Снаружи доступ к именам в файле модуля можно получить с помощью двух инструкций, import и from, а также с помощью функции reload.

например, файл myfile.py содержит код:

title = "To beer or not to beer"

При импортировании этого модуля выполняется его программный код, котоый создает атрибут модуля. В нашем случае инструкция присваивания создает атрибут с именем title.

Доступ к этому атрибуту можно получить двумя способами. 
Первый - загрузить модуль инструкцией import и обратиться к атрибуту по его имени, уточнив его именем модуля:

>>> import myfile
>>> print(myfile.title)
To beer or not to beer


Синтаксис object.attribute позволяет получить доступ к любому атрибуту в любом объекте.

Второй способ - воспользоваться инструкцией from:

>>> from myfile import title
>>> print(title)
To beer or not to beer


Инструкция from во многом подобна инструкции import, которая выполняет присваивание имен в импортирующем компоненте.
Инструкция from копирует атрибуты модуля так, что они становятся простыми переменными в программном коде, выполняющем импорт, благодаря чем мы и обращаемся к атрибутам без указания модуля (в отличие от синтаксиса object.attribute).

Т.о. мы видим, что импортирующий компонент получает доступ к именам, определенным в файле на верхнем уровне. Это могут быт ьне только переменные, но и функции и классы и т.п., что очень важно для языка Питон.


Рассмотрим пример модуля с тремя переменными.

a = 'Billy'
b = 'Villy'
c = 'Dilly'
print(a, b, c) 

>>> import myfile
Billy Villy Dilly
>>> myfile.a, myfile.b
('Billy', 'Villy')

>>> from myfile import a, b, c
>>> a, b
('Billy', 'Villy')

Итак, видим, что инструкция import получает модуль со всеми его атрибутами, а from получает копии имен из этого модуля.


Модули в Питоне являются самой крупной структурной единицей в программах этого ЯП.

Вообще программы на Питоне состоят из множества модулей свзязанных инструкциями import. Т.о. модули позволяют уменьшить вероятность конфликтов имен в программном коде, даже если они одинаковые (модули то разные), можно и запутаться в модулях, конечно, но это уже личное дело разработчика.

! - Не забудьте, что инструкция from может затереть переменные в импортирующем файле, если в импортируемом модуле есть переменные с такими же именами. Будьте бдительны и осторожны, следите за именами в обеих файлах.


Еще одна любопытная функция exec. Позволяет выполнять файлы практически не импортируя модуль. Причем след. вызов exec будет выполнять текущую версию файла и даже при изменении его выводит ьвсё правильно.

>>> exec(open('script1.py').read())
win32
1024
SpamSpamSpamSpamSpamSpamSpamSpam
>>> exec(open('script1.py').read())
win32
16384
SpamSpamSpam
>>>          
 
Предупреждение! Использование функции exec затирает существущие переменные, пример:

>>> x = 99
>>> exec(open('script1.py').read())
win32
16384
SpamSpamSpam
>>> x
'Spam'


стр. 121.

Данные в Питон представлены в форме объектов - либо встроенных, либо созданных разработчиком.

Объекты - это области памяти со значениями и ассоциированными с ними наборами операций.

1. Программы делятся на модули.
2. Модули содержат инструкции.
3. Инсрукции состоят из выражений.
4. Выражения создают и обрабатывают объекты.


Как мы вскоре узнаем, значительная доля работы приходится на реализацию объектов, известных также как структуры данных, которые предназначены для представления составляющих предметной области.


Базовые типы данных. стр. 123.

Числа
Строки
Списки (типо массивы) []
Словари (типо хеш) {}
Кортежи (ни то ни се) ()
и т.д.


Строки, списки, кортежи - это, так называемые, последовательности в языке Питон, упорядоченные коллекции объектов. Естественно, строки попроще последовательности, другие посложнее, но в целом все они собой являют тип объектов - последовательности. 
Со строками сложнее, они нам видятся цельными объектами, но по сути являются последовательностями односимвольных строк (т.е. символов).
Такая вот особенность этих базовых типов в Питон.
 

Далее мы узнаем, что структурные элементы программ, такие как функции, модули и классы, также являются объектами в Питоне.


Когда выполняется код:

>>> 'spam'

- то, гвооря техническим языком, выполняется выражение-литерал, которое генерирует и возвращает новый строковый объект. Подобным образом создаются объекты других типов.

Отметим, что как только создается объект, он будет ассоциирован со своим собственным набором операций на протяжении всего времени существования. Т.е. мы можем выполнить над объектом только те операции, которые применимы к его типу.

 
стр. 129

Методы в Питоне, это - функции, присоединенные к объекту, которые запускаются выражением вызова.

Например относительно строк, метод find возвращает смещение переданной ему подстроки или -1 если поиск не увенчался успехом, а replace проводит глобальный поиск с заменой.

Но при этом объект, к которому мы применяли методы (наша строка-испытатель 'spam'), не изменяется, а создается новая строка.

 Т.е. отметим, что выражение вида "s = (s.replace('pa', 'XYZ'))" строку 'spam' изменяет, а "s.replace('pa', 'XYZ')" не изменяет, просто метод возвращает новую строку, а прежняя остается собой. Вот такие вот особенности.
 
split() - разбивает строку по разделителю и и создает список строк
line = 'aaa, sss, bbb, cccccc, dd'
line.split(',')
['aaa', ' sss', ' bbb', ' cccccc', ' dd']

upper() - преобразует символы в верхний регистр

isalpha() - проверка содержимого: isalpha, isdigit и т.д.
s = 'spam'
>>> s.isalpha()
True
>>> s.isdigit()
False

Существуют также методы подстановки:
>>> '%s, eggs, and %s' % ('spam','SPAM')
'spam, eggs, and SPAM'
>>> '{0}, eggs, and {1}'.format('spam','SPAM!')
'spam, eggs, and SPAM!'

Следует знать, что инструментальные стредства Питон делятся на несколько уровней:
- универсальные операции, которые могут применяться к нескольким типам, реализованы в виде встроенных функций и выражений (типа len(x), x[0] и др.);
- а операции, специфичные для определенного типа, реализованы в виде методов (см. выше методы для строк).

Помощь по методам мы можем получить применив команду - dir(s), а т.к. мы знаем, что s у нас по прежнему строка, то получим все методы относящиеся к строкам.
Точнее сказать, функция dir() возвращает нам список всех атрибутов, определенных внутри модуля.


Имена вида __len__ представляют собой реализацию строкового объекта и доступны для поддержки специализации. В общем случае двойное подчеркивание вначале и конце имени используются интерпретатором Питон для обозначения особенностей внутренней реализации.

А имена без подчеркиваний обозначают методы строковых объектов.

Так же мы можем получим специализированные имена и имена методов для любого другого вида объектов.  

Справку по конкретному методу получаем командой - help(s.upper)

Пробовал по функциям с подчеркиваниями смотерть справку, но там непонятно, вводил например - help(len(s)) - т.е. по типу как используется эта функция, и получил кучу вывода непонятного, с командой - help(iter(s)) вывод получился короче, т.е. справку я смотрю вроде правильно, но описание непонятное.
Надо учить английский.

Использование шаблонов. Как я понял шаблоны в Питоне это т.н. регулярные выражения.

>>> import re
>>> match = re.match('Hello[ \t]*(.*)world', 'Hello   Python world')
>>> match.group(1)
'   Python '

В этом примере выполняется поиск строки, начинающейся со слова 'Hello', вслед за которым следуют ноль или более символов табуляции или пробелов, за которыми могут следовать произвольные символы, которые будут сохранены, как группа совпадения, и завершающая словом "world".
Если такое совпадение будет найдено, части этой подстроки будут доступны в виде групп. Например следующий шаблон возвращает три группы, разделенные символами слеша:
>>> match = re.match('/(.*)/(.*)/(.*)', '/usr/home/userlib')
>>> match.groups()
('usr', 'home', 'userlib')


Списки.

Списки - это самое общее представление последовательностей, реализованных в языке Питон.

Списки - это упорядоченные по местоположению коллекции объектов произвольных типов, размер которых не ограничен.
В отличие от строк списки являются изменяемыми объектами.

>>> l = [123, 'spam', 1.23]
>>> len(l)
3
>>> l[0]
123
>>> l[:-1]
[123, 'spam']
>>> l + [4,5,6]
[123, 'spam', 1.23, 4, 5, 6]
>>> l
[123, 'spam', 1.23]
 
Как видим, со списками мы можем производить те же операции, что и со строками, только результатом операций являются списки, а не строки.

Списки в Питоне являются аналогами массивов в других ЯП, но обладают более широкими возможностями.

>>> l.append('NI')
>>> l
[123, 'spam', 1.23, 'NI']
>>> l.pop(2)              # аналог этой команды - del l[2]
1.23
>>> l
[123, 'spam', 'NI']

>>> m = ['bb', 'aa','cc']
>>> m.sort()
>>> m
['aa', 'bb', 'cc']
>>> m.reverse()
>>> m
['cc', 'bb', 'aa']
>>> 
 
Как видим, т.к. списки являются изменяемыми, большинство методов списков не создают новый список, а изменяют оригинал.

При обращении за выход границ массива или попытке присвоения значения элементу за границей массива (l[99]=1) происходит ошибка и программа выдает соответствующее сообщение.


Вложенные списки.

>>> m = [[1,2,3],[4,5,6],[7,8,9]]
>>> m
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

>>> m[1]    # получить вторую строку (второй список)                          
[4, 5, 6]

>>> m[1][2]  # из второй строки получить элемент с индексом 2
6
   
Вместе с тем этот вложенный список можно представтиь в виде матрицы.

И при обработке матрицы можно эффективно воспользоваться - выражениями генераторов списков.

>>> col = [row[1] for row in m]
>>> col
[2, 5, 8]
>>> m
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

- вот такой командой мы выбрали элементы второго столбца, при этом оригинальная матрица не изменилась. 
Команда переводится так - "Получить элементы row[1] из каждой строки матрицы m и создать из них новый список".

>>> [row[1] + 1 for row in m]
[3, 6, 9]
>>> m
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

- добавить 1 к каждому элементу в столбце 2

>>> [row[1] for row in m if row[1] % 2==0]
[2, 8]
>>> m
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

- отфильтровать в выводе результата нечетные значения

Генераторы списков возвращают новые списки, но могут использоваться и для любых других объектов, допускающих выполнение итераций.Смотрим пару примеров.

Например выберем элементы по диагонали матрицы:
>>> diag = [m[i][i] for i in[0,1,2]]
>>> diag
[1, 5, 9]

Или дублирование символов в строке:
>>> doubl = [c * 2 for c in 'spam']
>>> doubl
['ss', 'pp', 'aa', 'mm']

Можно использовать круглые скобки для создания генераторов, которые воспроизводят результаты по требованию.
>>> g = (sum(row) for row in m)
>>> g
>>> next(g)
6
>>> next(g)
15
>>> next(g)
24
>>> next(g) 

- если далее продолжить команду next(g) - получаем сообщение об ошибке.

Можно еще обернуть вызов функции в список и она вернет все значения сразу:

>>> list(map(sum, m))
[6, 15, 24]

С помощью генераторов можно создавать множества и словари:

>>> {sum(row) for row in m}     # создадим множество сумм строк
{24, 6, 15}

>>> {i:sum(m[i]) for i in range(3)}    # Таблица пар ключ\значение сумм строк
{0: 6, 1: 15, 2: 24}

>>> [ord(x) for x in 'spaam']         # список кодов символов
[115, 112, 97, 97, 109]

>>> {ord(x) for x in 'spaam'}         # множество ликвидирует дубликаты
{112, 97, 115, 109}

>>> {x: ord(x) for x in 'spaam'}        # ключи словарей являются уникальными
{'a': 97, 'm': 109, 's': 115, 'p': 112}


Словари.

Словари в Питоне - известны как отображения, как-бы не являются последовательностями.

Отображения - это коллекция объектов, но доступ к ним осуществляется не по определенным смещениям от начала коллекции, а по ключам.
Отображения не предусматривают какого-либо упорядочения элементов по их позиции, они просто отображают ключи на связанные с ними позиции.
Словари - единственный тип отображений в Питоне. Они также изменяемые, как списки.

Определим словарь как литерал, обрамляется он в фигурные скобки, как хеш в Руби:

>>> d = {'food': 'spam', 'quant':4, 'color':'red'}
>>> d
{'quant': 4, 'food': 'spam', 'color': 'red'} 
>>> d['food']
'spam'
>>> d['quant'] +=1                          # здесь мы прибавили 1 к значению ключа quant
>>> d
{'quant': 5, 'food': 'spam', 'color': 'red'}

Есть другие способы создания словарей:
>>> d={}
>>> d['name']='Bob'
>>> d['job']='dev'
>>> d['age']=40
>>> d
{'age': 40, 'name': 'Bob', 'job': 'dev'}

Любопытная особенность, маленькое различие в выводе отдельного элемента и при использовании меода print:
>>> print(d['name'])
Bob
>>> d['name']
'Bob'                 # видим, что в этом случае имя в кавычках



Вложенность словарей.

Допустим нам нужно описать человека более подробно, для этого мы несколько усложним структуру словаря, на примере будет всё понятно:
# создаем словарь с вложениями
>>> rec = {'name':{'first':'Bob', 'last':'Smith'}, 'job':['dev','mgr'], 'age':40.5}
# выборку можно осуществлять стандартно по ключу, смотрим вложенный словарь 
>>> rec['name']
{'last': 'Smith', 'first': 'Bob'}
# выборка по вложенным элементам
>>> rec['name']['last']
'Smith'
# смотрим вложенный список
>>> rec['job']
['dev', 'mgr']
>>> rec['job'][-1]
'mgr'
>>> rec['job'].append('janitor')
>>> rec
{'age': 40.5, 'name': {'last': 'Smith', 'first': 'Bob'}, 'job': ['dev', 'mgr', 'janitor']}


Здесь мы видим как сильно похожи и взаимосвязаны способы работы со списками и словарями.


К тому же эти примеры демонстрируют нам гибкость языка Питон, в сравнении с другими более строгими ЯП.

К тому же можно освободить память вручную, например просто присвоив значение rec = 0, хотя в Питоне память освобождается атвоматически (т.н. "сборка мусора"). При этом не забывайте проверить не находится ли объект в базе данных или это может быть файл.


Сортировка. Цикл for

Порядок вывода ключей словаря может не совпадать с порядком их определения, т.е. например:
>>> d = {'a':1, 'b':2, 'c':3}
>>> d
{'a': 1, 'c': 3, 'b': 2}
>>> d['d']=4
>>> d
{'a': 1, 'd': 4, 'b': 2, 'c': 3}  

Отсортируем по ключам, методами keys sort и циклом for

>>> ks = list(d.keys())
>>> ks
['a', 'd', 'b', 'c']
>>> ks.sort()
>>> ks
['a', 'b', 'c', 'd']
>>> for key in ks:
	print(key, '=>', d[key])
	
a => 1
b => 2
c => 3
d => 4


Или можно воспользоваться новой функцией - sorted и не нужно будет трех этапов, причем переменную key мы можем назвать хоть mmm - оказывается это не специальное обозначение ключа (как я вначале подумал), а просто переменная относящаяся к ключу.

Я забыл, что ks - это уже отсортированный список ключей, а не весь наш словарь. А во втором случае, когда используем sorted, всё равно всё работает даже если вместо key писать bbb, такая вот крута функция.
 
>>> d
{'a': 1, 'd': 4, 'b': 2, 'c': 3}
>>> for key in sorted(d):
	print(key, '=>', d[key])
	
a => 1
b => 2
c => 3
d => 4


Вот мы и познакомились с циклом for.

Переменная цикла, определяемая пользователем (в нашем случае это key), служит для ссылки на текущий элемент.
Еще один пример цикла for, в котором происходит обход всех символов и перевод в верхний регистр:
>>> for c in 'spam':
	print(c.upper())
S
P
A
M


Пример цикла while:
>>> x = 4
>>> while x>0:
	print('spam!'*x)
	x -=1
spam!spam!spam!spam!
spam!spam!spam!
spam!spam!
spam! 

 
Цикл for и выражения-генераторы фактически представляют собой универсальное средство выполнения итераций. Обе констркции способны работать с любыми объектами, которые поддерживают протокол итераций.

Любой инструмент Питона, сканирующий объект слева направо использует протокол итераций. Пример - функция sorted.

Любой генератор списков, например:
>>> squar = [x**2 for x in [1,2,3,4,5]]
>>> squar
[1, 4, 9, 16, 25]

можно представит ьв виде эквивалентного цикла for:
>>> squar = []
>>> for x in [1,2,3,4,5]:
	squar.append(x**2)
>>> squar
[1, 4, 9, 16, 25]

Следует отметить, что генераторы и родственные им функции map и filter обычно выполняются быстре ечем цикл for.
Но о скорости лучше не беспокоиться, потому что главное правило Питона - это удобный код и простота, а оптимизацию можно оставить на потом.


Проверка с помощью оператора if.

>>> d
{'a': 1, 'b': 2, 'c': 3}
>>> d['e']=99
>>> d
{'a': 1, 'b': 2, 'e': 99, 'c': 3}

Если мы захотим проверить значение ключа d['f'] то получим сообщение об ошибке. Во избежание таких казусов можно использовать проверку.

>>> 'f' in d        # работает только на ключах, по значениям выдает false
False
>>> 2 in d
False
      
>>> if not 'f' in d:      # здесь мы использовали оператор if
	print('missing')

missing
>>>  
 
if мы рассмотрим позднее.


Кортежи.

Объект-кортеж (tuple - "тьюпл" или "тьюпел"), в общих чертах напоминает список, который невозможно изменить - кортежи это последовательности, как списки, но они неизменяемые, как строки.
Кортеж заключается в круглые скобки. Поддерживает включение объектов различных типов и операции типичные для последовательностей.
  
>>> t = (1,2,3,4)
>>> len(t)
4
>>> t + (5,6)
(1, 2, 3, 4, 5, 6)
>>> t[0]
1

>>> t[0]=2
Traceback (most recent call last):
  File "<pyshell#149>", line 1, in <module>
    t[0]=2
TypeError: 'tuple' object does not support item assignment

- получаем ошибку, кортежи неизменяемые.

>>> t=('spam', 3.0, [11,22,33])
>>> t
('spam', 3.0, [11, 22, 33])
>>> t[1]
3.0
>>> t[2][1]
22
>>> t.append(4)
Traceback (most recent call last):
  File "<pyshell#154>", line 1, in <module>
    t.append(4)
AttributeError: 'tuple' object has no attribute 'append'

Главное достоинство кортежей - их неизменяемость, и в основном их используют для обеспечения целостности коллекций, передаваемых между компонентами программы.


Файлы.

Файлы являются одним из базовых типов, но для них отсутствует возможность создания объектов в виде литералов (это естественно, т.к. файлы достаточно сложный и своеобразный объект).

Поэтому чтобы создать файл, нужно вызвать функцю open, передав ей имя файла и строку режима доступа к файлу (привет Руби!). Смотрим:

>>> f = open('data.txt', 'w')
>>> f.write('Hello\n')
6
>>> f.write('World\n')
6
>>> f.close
<built-in method close of _io.TextIOWrapper object at 0x01677CB0>
>>> f.close()

- открываем файл для создания, указываем имя и 'w', важно!!! - если создаем файл не в текущем каталоге, а где-то в другом месте, то указываем полный путь к нему! 

Затем записываем в него пару слов (при этом Питон показывает нам кол-во записанных байтов). И закрываем файл.


Теперь мы прочитаем содержимое файла и в строку и отобразим её:

>>> f = open('data.txt')    # по умолчанию режим 'r' поэтому можно не указывать
>>> text = f.read()
>>> text
'Hello\nWorld\n'
>>> print(text)
Hello
World 
>>> text.split()
['Hello', 'World']

Запомните, что самый лучший способ чтения файлов состоит в том, чтобы не читать его содержимое целиком - файлы предоставляют итераторы, которые обеспечивают автоматическое построчное чтение содержимого файла в циклах for и в других контекстах.

Кстати, в Питоне текстовые файлы представляются в виде строк и автоматически кодируются и декодируются в Юникод, а двоичные файлы представляются в виде строк специального типа bytes, при этом никаких автоматических преобразований не происходит.


Множества.

Множества - это неупорядоченные коллекции уникальных и неизменяемых объектов. Создаются они функцией set или с помощью определения литералов и генераторов множеств. Множества напоминают словари, в которых ключи не имеют значений.

>>> x = set('spam')       # множества можно создавать из последовательностей
>>> y = {'h', 'a', 'm'}    # можно определять литералы множеств
>>> x, y
({'s', 'p', 'a', 'm'}, {'m', 'a', 'h'})

>>> x&y                     # Пересечение                   
{'m', 'a'}
>>> x|y                     # Объединение  
{'s', 'p', 'a', 'm', 'h'}
>>> x-y                     # Разность
{'s', 'p'}
>>> y-x
{'h'}
>>> {x**2 for x in [1,2,3,4]}     # генератор множеств
{16, 1, 9, 4}


Кроме того появились в Питоне вещественные числа с фиксированной точностью и рациональные числа (т.е. дроби).

>>> 1/3                 # вещественное число
0.3333333333333333
>>> (2/3) + (1/2)
1.1666666666666665

>>> import decimal                # вещественные числа с фиксированной точностью
>>> d = decimal.Decimal('3.141')
>>> d+1
Decimal('4.141')
>>> decimal.getcontext().prec = 2
>>> decimal.Decimal('1.00')/decimal.Decimal('3.00')
Decimal('0.33')

>>> from fractions import Fraction      # Рациональные числа, т.е. дроби 
>>> f = Fraction(2, 3)
>>> f
Fraction(2, 3)
>>> f + 1
Fraction(5, 3)
>>> f + Fraction(1,2)
Fraction(7, 6)

>>> from ff import Fraction           # fractions - это модуль оказывается
Traceback (most recent call last):
  File "<pyshell#36>", line 1, in <module>
    from ff import Fraction
ImportError: No module named 'ff'


Кроме того в Питон имеется логический тип данных - True и False (по сути 1 и 0). Крмое того существует объект None, обычно используемый для инициализации объекто и переменных:

>>> 1 > 2, 1 < 2
(False, True)
>>> bool('spam')
True
>>> x = None
>>> x
>>> print(x)
None
>>> l = [None] * 20
>>> l
[None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None]


Отметим некоторые особенности программного кода в Питон.

Тип объекта, возвращаемый встроенной функцией type, в свою очередь сам является объектом. Причем в версиях Питона 3.х типы объектов были объеденены с классами.
Пример:

>>> type(l)               # Переменная l представляет объект типа list, типы являются
<class 'list'>              классами и наоборот

>>> type(type(l))         # Даже сами типы являются объектами  
<class 'type'>
 
Исследовать типы объектов можно не только в интерактивной оболочке, но и в сценариях:

>>> if type(l) == type([]):     # Проверка типа
	print('yes')
yes

>>> if type(l == list):         # С использованием имени типа
	print('yes')
yes

>>> if isinstance(l, list):     # Проверка в ООП стиле
	print('yea')
yea

- Но использвание таких проверок практически всегда является неверным решением, т.к. наличие таких проверок отрицательно сказывается на гибкости кода, потомоу что такими проверками мы ограничиваем  наш код в типах данных.

Программный код на Питоне ориентируется на использование интерфейсов объектов (набором поддерживаемых операций), а не их типов.

Это тесно связано с идеей полиморфизма, которую пропагандирует Питон, полиморфизм является одной из ключевых концепций этого ЯП.


Классы, определяемые пользователем. стр. 149

ООП рассмотрим позже, но пока познакомимся с классами.

Классы позволяют нам определять новые типы объектов. 

Например создадим тип объектов, который моделирует сотрудников: 

>>> class Worker:
	def __init__(self, name, pay):    # инициализация при создании
      self.name = name                # self - это сам объект 
      self.pay = pay
	def lastName(self):
			return self.name.split()[-1]  # разбить строку по символам пробела
	def giveRaise(self, percent):
			self.pay *= (1.0 + percent)   # обновить сумму выплат

- кстати все def, в этом случае, должны быть на одном уровне в файле сценария (как здесь) иначе lastName и giveRaise будут воприниматься не как методы, а как атрибуты объекта класса Worker и в коде ниже будет ошибка.
Смотрим дальше и всё поймем.
      
Данный класс определяет новый тип объектов, которые обладают атрибутами name и pay (иногда атрибуты называют - информацией о состоянии), а также двумя описаниями поведения, оформленными в виде функций (которые обычно называют методами).

Обращение к имени класса как к функции приводит к созданию экземпляра нового типа, а методы класса автоматически получают ссылку на текущий экземпляр, обрабатываемый этими методами (аргумент self):

>>> bob = Worker('Bob Smith', 50000)
>>> sue = Worker('Sue Jones', 60000)
>>> bob.lastName()
'Smith'
>>> sue.lastName()
'Jones'
>>> sue.giveRaise(.10)
>>> sue.pay
66000.0

В этой модели ООП присутствует подразумеваемый объект "self" -  внутри функций, определяемых в классе, всегда присутствует подразумеваемый объект, и в нашем случае это self.
В некотором смысле типы, основанные на классах, просто создаются на базе основных типов и используют их функциональные возможности.
В данном случае пользовательский класс Worker - это всего лишь коллекция, состоящая из строки и числа (name и pay соответсвенно), плюс функции, выполняющие обработку этих двух встроенных объектов.

По сути в Питоне все данные, которые обрабатываются сценариями, являются объектами. Объекты с которыми мы познакомились действительно являются объектами, но для работы с ними не требуется обязательно использовать ООП подход.



Теперь, поскольку объекты представляют самое фундаментальное понятие для программирования на языке Питон, все наше внимание в первую очередь будет сосредоточено на объектах.

Поэтому мы приступаем к более детальному изучению концепции типов данных. 



Глава 5. Числа. стр. 153

Числовые типы в Питон:

- Целые и вещественные числа;
- Комплексные числа;
- Числа фиксированной точности;
- Рациональные числа;
- Множества;
- Логические значения;
- Целые числа неограниченной точности;
- Различные встроенные функции и модули для работы с числами.

В Питон 2.6 целые числа были обычные и длинные, в версии 3.х целые числа стали одного типа.

Шестнадцатиричные записываются 0х или 0Х и дальше число, восьмеричные 0о или 0О (число 0 и символ "о") и дальше восьмеричное число, двоичные начинаются с 0b или 0B.

Комплексные числа записываются в виде - действительная_часть + мнимая_часть, где мнимая_часть завершается символом j или J. Мнимая_часть может указываться без действительной части, т.к. действительная может быть ен важно (с технич точки зрения).

Операторы выражений:

+ , - , * , / , >> , ** , &  и другие.

Встроенные математические функции:

pow, abs, round, int, hex, bin и др.

Вспомогательные модули:

random, math и др.


Операторы выражений.

Одной из самых фундаментальных возможностей обработки чисел являются - выражения - комбинации чисел и операторов, которые выозвращают значения при выполнении интерпретатором Питон.

Таблица 5.2 Операторы выражений и правила определения старшинства. стр. 157-159


Смешанные операторы и определение старшинства.

Чем выше приоритет оператора тем ниже он стоит в таблице 5.2 и тем раньше он выполняется в смешанных выражениях.

Чтобы не было ошибо при чтении выражений можно группировать подвыражения круглыми скобками - (А+В)*С например так.


Смешивание типов и их преобразование.

Пусть нам нужно сложить целое и вещественное число (40 + 3.14), как же Питон вычисляет тип результата?  

В выражениях, где участвуют значения различных типов, интерпретатор сначала выполняет преобразование типов операндов к типу самого сложного операнда, а затем прмиеняет математику, специфиную для этого типа.

В Питоне можно принудительно преобразовывать тип, но это не обязательно:

>>> int(3.1415)
3
>>> float(3)
3.0
>>> 40 + 3.14       # вот пример автоматического приведения типа
43.14

Все эти автоматические преобразования производятся только при смешивании числовых типов в выражении.
Питон не выполняет автоматическое преобразование других типов, т.е. нельзя сложить строку и число без ручного преобразования типов (с этим мы познакомимся позднее).
>>> a = 'spam'
>>> b = 7
>>> a+b
...
TypeError: Can't convert 'int' object to str implicitly

>>> print(a+b)            # даже функция print не работает в этом случае
...
TypeError: Can't convert 'int' object to str implicitly


Применимость математических операндов к разным типам объектов характеризуется полиморфизмом, т.е. выполняемая операция зависит от типов объектов-операндов, над которыми она выполняется. 
Например + это сложение с числами и + это конкатенация со строками и списками.

 
Числа в действии.

Займемся программированием! Так мы лучше поймем действия с числами.

Для начала присвоим двум переменным a и b целочисленные значения. Переменные - это всего лишь имена, создаваемые в языке Питон, которые используются для обозначения информации в программе. О переменных подробно изучим позже, сейчас несколько моментов:

- Переменные создаются с помощью операции присваивания;
- При вычислении имена переменных замещаются их значениями;
- Прежде чем переменная сможет участвовать в выражениях, ей должно быть присвоено значение
- Переменные являются ссылками на объекты и никогда не объявляются заранее.

>>> a = 3         # Создается имя
>>> b = 4      

>>> a + 1, a - 1      # Сложение, вычитание
(4, 2)

>>> b * 3, b / 2      # Умножение, деление
(12, 2.0)

>>> a % 2, b ** 2     # Деление по модулю (остаток), возведение в степень
(1, 16)

>>> 2 + 4.0, 2.0 ** b  # Смешивание типов, преобразование
(6.0, 16.0)

С технической точки зрения результатами этих выражений являются - кортежи, состоящие из двух значений, т.к. мы вводили строки, которые содержали по два выражения, разделенных запятыми. Именно по этой причине результат отображается в круглых скобках.

И опять же напоминаем - перед использованием переменных им были присвоены значения. 
Именно поэтому при использовании счетчиков вначале они должны инициализироваться хотя бы нулевым значением, или перед использованием списка инициализировать его пустым значением и т.п.

>>> b / 2 + a             # Примеры автоматического порядка и ручного выполнения операторов
5.0
>>> print(b / (2.0 + a))
0.8

- кстати если бы хотели использовать целочисленное деление, то нужно было записать выражение так: b // 2 + a но об операции деления поговорим далее.


Форматы отображения чисел.

Обратимся к последнему прмиеру и посмотрим разницу:
>>> b / (2.0 + a)         # в примере в книге это выглядит так
0.80000000004

- но на моем ПК оба выражения одинаковы, это зависит от архитектуры компьютера
>>> b / (2.0 + a)         
0.8
>>> print(b / (2.0 + a))
0.8

>>> num = 1 / 3.0
>>> num
0.3333333333333333
>>> print(num)
0.3333333333333333

- вот опять у меня обычный выывод и с помощью print одинаковые, но нужно запомнить, что обычный вывод зачастую может быть длиннее чем вывод функции print.

>>> "%e" % num                # Вывод с использованием выражения форматирования строк
'3.333333e-01'
>>> '%4.2f' % num             # Альтернативный формат представления вещественных чисел
'0.33'
>>> '{0:4.2f}'.format(num)    # Метод форматирования строк
'0.33'    

- функция repr(), также как и функция автоматического вывода в интерактивной оболочке, выводит результаты в том виде, в каком они были указаны в программном коде (например 0.333333333333333);
- функция str(), как и операция print, обычно выполняет преобразование в более дружественное значение.
Некоторые объекты имеют оба варианта строкового представления.

Одно замечание - на моем ПК обе функции показывают одинаковое значение, это либо особенность архитектуры или влияние ОС на Питон.


Операции сравнения, простые и составные.

>>> 1 < 2
True
>>> 2.0 >= 1      # Числов 1 преобразуется в 1.0
True
>>> 2.0 == 2.0
True
>>> 2.0 == 2      # снова преобразование 2 в 2.0 
True
>>> 2.0 != 2.0    # Проверка на неравенство, false потомоу что 2.0 равно 2.0
False  

Можно комбинировать операторы сравнения, например для проверки вхождения числа в диапазон:

>>> x < y < z         # выражения идентичны, но в первом случае оно короче и быстрее
True
>>> x < y and y < z
True

>>> x < y > z         # более сложные цепочки
False
>>> x < y and y > z
False
>>> 1 < 2 < 3.0 < 4
True
>>> 1 > 2 > 3.0 > 4
False
	  
Рассмотрим пример с комбинацией операторов сравнения:

>>> 1 == 2 < 3      # то же, что и 1 == 2 and 2 < 3
False

- в этом выражении интерпретатор не сравнивает значение False (результат операции 1 == 2) с числом 3 - с технической точки зрения это соответствовало бы выражению 0 < 3, которое должно было бы вернуть True (т.к. True и False - это всего лишь числа 1 и 0, расширенные приписанными им свойствами), а в нашем случае мы получили значение выражения соответствующего "1 == 2 and 2 < 3".    

Запомним эту особенность, т.к. это важно.


Деление, классические, с округлением вниз и истинное.

X / Y  -  в Питон 3.х этот оператор выполняет операцию истинного деления, которая всегда сохраняет дробную часть независимо от типов операндов.

X // Y  - Деление с округлением вниз. Он всегда отсекает дробную часть, округляя результат до ближайшего наименьшего целого независимо от типов операндов.

>>> 10 / 4
2.5
>>> 10 // 4
2
>>> 10 / 4.0
2.5
>>> 10 // 4.0
2.0

- тип результата // зависит от типов операндов, если хотя один из них вещественное число, то и результат будет вещественным числом.
Оператор // используется в программах гораздо чаще чем мы могли подумать, например когда нужен целочисленный результат при деление целочисленных операндов.


Округление вниз и усечение дробной части.

Оператор // также называется оператором деления с округлением вниз - т.е. он округляет результат до ближайшего меньшего целого значения.
Посмтрим несколько примеров:
>>> import math
>>> math.floor(2.5)
2
>>> math.floor(-2.5)
-3
>>> math.trunc(2.5)
2
>>> math.trunc(-2.5)
-2

>>> 5 / 2, 5 / -2
(2.5, -2.5)
>>> 5 // 2, 5 // -2
(2, -3)
>>> 5 / 2.0, 5 / -2.0
(2.5, -2.5)
>>> 5 // 2.0, 5 // -2.0
(2.0, -3.0)

Почему усечение так важно?

>>> (5/2), (5/2.0), (5/-2.0), (5/-2)        # Классическое деление
(2.5, 2.5, -2.5, -2.5)
>>> (5//2), (5//2.0), (5//-2.0), (5//-2)    # Деление с округлением вниз
(2, 2.0, -3.0, -3)
>>> (9/3), (9.0/3), (9//3), (9//3.0)        # Оба оператора  
(3.0, 3.0, 3, 3.0) 
  
- мы видим различие действия операторов и опыт программистов подсказывает нам, что иногда нам нужны будут не просто математические значения, а логические, целочисленные результаты делений для работы программ, поэтмоу нужно внимательно следить за операциями деления и уметь правильно прмиенять оба оператора.


Комплексные числа. стр. 171


Шестнадцатеричная, восьмеричная и двоичная фомы записи чисел.

>>> 0o1, 0o20, 0o377            # восьмеричные литералы
(1, 16, 255)
>>> 0x01, 0x10, 0xff            # шестнадцатеричные литералы      
(1, 16, 255)
>>> 0b1, 0b10000, 0b11111111    # двоичные литералы
(1, 16, 255)

>>> oct(64), hex(64), bin(64)      # встроенные функции по переводу в системы счисления
('0o100', '0x40', '0b1000000')

функция int напротив - переводит числа из системы счисления в десятичную:

>>> int('64'), int('100', 8), int('40', 16), int('1000000', 2)
(64, 64, 64, 64)

Функция eval интерпретирует строку во входном аргументе как программный код на Питоне. Правда с ней нужно обращаться осторожно, иначе можно выполнить какой-то случайный код, например код подсунутый злоумышленниками и получит ьпустой жесткий диск например.

>>> eval('64'), eval('0o100'), eval('0x40'), eval('0b1000000')
(64, 64, 64, 64)

Строковые методы форматирования чисел:

>>> '{0:o}, {1:x}, {2:b}'.format(64,64,64)
'100, 40, 1000000'
>>> '%o, %x, %X' % (64, 255, 255)
'100, ff, FF'


Битовые операции. стр. 174


Другие встроенные стредства.

Рассмотрим модуль math:

>>> import math
>>> math.pi, math.e                       # константы  
(3.141592653589793, 2.718281828459045)
>>> math.sin(2*math.pi/180)               # Синус, тангенс, косинус  
0.03489949670250097
>>> math.sqrt(144), math.sqrt(2)          # Квадратный корень
(12.0, 1.4142135623730951)
>>> pow(2, 4), 2**4                       # Возведение в степень
(16, 16)
>>> abs(-42.0), sum((1,2,3,4))            # Абсолютное значение, сумма
(42.0, 10)
>>> min(3,1,2,4), max(3,1,2,4)            # Минимум, максимум
(1, 4) 

>>> math.floor(2.567), math.floor(-2.567)
(2, -3)
- округление вниз (до ближайшего наименьшего целого)

>>> math.trunc(2.567), math.trunc(-2.567)
(2, -2)
- усечение (отбрасывание дробной части)

>>> int(2.567), int(-2.567)
(2, -2)
- усечение (преобразование в целое число)

>>> round(2.567), round(2.467), round(2.567, 2)
(3, 2, 2.57)
>>> (1/3), round(1/3, 2)
(0.3333333333333333, 0.33) 
- округление (в Питоне 3.х)

Еще примеры вычисления корня:
>>> import math
>>> math.sqrt(144)
12.0
>>> 144 ** .5
12.0
>>> pow(144, .5)
12.0

Из всех этих примеров выделим одно замечание, модули - это внешние компоненты, а встроенные функции постоянно располагаются в пространстве имен, которое используется интерпретатором Питон по умолчанию для поиска имен, используемых программой.
Сейчас для нас актуально правило: если видишь модуль, то сразу вспоминай - импорт.

Пример еще одного импорта - модуль random:
>>> import random
>>> random.random()
0.6384048535018463
>>> random.random()
0.8669699558489125
>>> random.randint(1, 10)
1
>>> random.randint(1, 10)
10
>>> random.choice(['Hi bro', 'Guten tag', 'Hello love!'])
'Hi bro'
>>> random.choice(['Hi bro', 'Guten tag', 'Hello love!'])
'Guten tag'


Другие числовые типы. стр. 177

Числа с фиксированнйо точностью. 

Известны как числа типа - Decimal, по сутия являются вещественными, с фиксированным количеством знаков после запятой.
Причем можно указывать будут ли лишние числа усекаться или округляться, очень удобно для бухгалетрии например.

>>> 0.1 + 0.1 + 0.1 - 0.3
5.551115123125783e-17

- это пример проблемы с ограниченным количеством битовв представлении вещественных чисел.

>>> from decimal import Decimal
>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')
Decimal('0.0')

- вот так решается проблема с битами, с помощью функции Decimal из модуля decimal.

- если одно из чисел будет с двумя знаками (0.01) а остальные с одним (0.1), то рещульатт будет выведен с двумя знаками, Питон автоматически выбирает наибольшую точность.


Настройка точности.

Настройка в модуле decimal позволяет настраивать точность и режим округления (вверх, вниз и т.д.):

>>> import decimal
>>> decimal.Decimal(1)/decimal.Decimal(7)
Decimal('0.1428571428571428571428571429')
>>> decimal.getcontext().prec = 4
>>> decimal.Decimal(1)/decimal.Decimal(7)
Decimal('0.1429')

>>> 1999 + 1.33       # в книге, в этой строке ответ был 2000.32999999999
2000.33               # мой ПК решает всё правильно, странно...          
>>> decimal.getcontext().prec = 2
>>> pay = decimal.Decimal(str(1999 + 1.33))
>>> pay
Decimal('2000.33')


Менеджер конекста объектов класса Decimal.

В Питоне имеется возможность временно переопределять точность с помощью инструкции with менеджера конекстов. После выхода за пределы инструкции настройки восстанавливаются:
>>> import decimal
>>> decimal.Decimal('1.00')/decimal.Decimal('3.00')
Decimal('0.33')
>>> with decimal.localcontext() as ctx:
	ctx.prec = 1
	decimal.Decimal('1.00')/decimal.Decimal('3.00')

  Decimal('0.3')
>>> decimal.Decimal('1.00')/decimal.Decimal('3.00')
Decimal('0.33')


Рациональные числа.

По сути это дроби с числителем и знаменателем, числовой тип называется - Fraction.

Decimal и Fraction, похожи между собой по поведению и некоторым свойствам. Fraction так же находится в модуле.
Чтобы создать объект этого типа, необходимо импортировать модуль и вызвать конструктор класса, передав ему числитель и знаменатель:
>>> from fractions import Fraction
>>> x = Fraction(1, 3)
>>> y = Fraction(4, 6)    # автоматически будет упрощено функцией gcd до 2/3
>>> x
Fraction(1, 3)
>>> y
Fraction(2, 3)
>>> print(y)
2/3

Математические операции:

>>> x + y
Fraction(1, 1)
>>> x - y
Fraction(-1, 3)
>>> x * y
Fraction(2, 9)

Создадим рациональные числа другими способами:

>>> Fraction('.25')
Fraction(1, 4)
>>> Fraction('1.25')
Fraction(5, 4)
>>> Fraction('.25') + Fraction('1.25')
Fraction(3, 2)


Точность.

>>> Fraction(1, 10) + Fraction(1, 10) + Fraction(1, 10) - Fraction(3, 10)
Fraction(0, 1)

- как и в случае с Decimal мы получим точный вывод операции, по сравнению с числом выше - 5.551115123125783e-17

>>> 1/3
0.3333333333333333
>>> Fraction(1, 3)
Fraction(1, 3)
>>> decimal.getcontext().prec = 2
>>> decimal.Decimal(1)/ decimal.Decimal(3)
Decimal('0.33')

- и снова мы видим, что фактически рациональные числа сохраняют точность и автоматически упрощают результат.

>>> (1/3) + (6/12)
0.8333333333333333
>>> Fraction(1, 3) + Fraction(6, 12)
Fraction(5, 6)
>>> decimal.Decimal(str(1/3)) + decimal.Decimal(str(6/12))
Decimal('0.83')


Преобразование и смешивание в выражениях значений разных типов.

Для преобразования в рациональные числа был реализован метод as_integer_ratio, объекты рациональных чисел обладают методом from_float.

- в примерах ниже символ * - это специальный синтаксис распаковывания кортежа в отдельные аргументы, подробнее рассмотрим позднее.

Рассмотрим некоторые способы преобразований как в одну так и другую сторону:

>>> (2.5).as_integer_ratio()
(5, 2)
>>> f = 2.5
>>> z = Fraction(*f.as_integer_ratio())
>>> z
Fraction(5, 2)
>>> x
Fraction(1, 3)
>>> x + z
Fraction(17, 6)
>>> float(x)
0.3333333333333333
>>> float(z)
2.5
>>> float(x + z)
2.8333333333333335
>>> 17/6
2.8333333333333335
>>> Fraction.from_float(1.75)
Fraction(7, 4)
>>> Fraction(*(1.75).as_integer_ratio())
Fraction(7, 4)

При смешивании некоторых типов в выражениях иногда, чтобы сохранить точность, треубется вручную выполнить преобразование в тип Fraction.
>>> x
Fraction(1, 3)
>>> x + 2
Fraction(7, 3)
>>> x + 2.0
2.3333333333333335
>>> x + (1/3)
0.6666666666666666
>>> x + (1./3)
0.6666666666666666
>>> x + (4./3)
1.6666666666666665
>>> x + Fraction(4, 3)
Fraction(5, 3)

- В некоторых случаях при преобразовании вещественного числа в рациональное происходит потеря точности, потмоу что в своем первоначальном виде вещ. число может быть неточным.
- Поэтому нужно иногда вручную упростить число.

>>> 4.0 / 3
1.3333333333333333
>>> (4.0 / 3).as_integer_ratio()        # произойдет потеря точности
(6004799503160661, 4503599627370496)

>>> x
Fraction(1, 3)
>>> a = x + Fraction(*(4.0/3).as_integer_ratio())
>>> a
Fraction(22517998136852479, 13510798882111488)
>>> 22517998136852479 / 13510798882111488       # 5/3 (или близкое к нему!)
1.6666666666666665
>>> a.limit_denominator(10)               # упростить до ближайшего рационального
Fraction(5, 3)


Множества.

По определению, каждый элемент может присутствовать в множестве только в единственном экземпляре, не смотря на на то сколько раз он будет добавлен.
Множества применяются чаще в приложениях обработки числовых данных и при работе с БД.

Основы множеств.

Создать объект множества можно функцией set, передав ей последовательность или др. объект, поддерживающий итерации:

>>> x = set('abcde')
>>> y = set('bdxyz')
>>> x
{'a', 'c', 'b', 'd', 'e'}
>>> 'e' in x                # Проверка вхождения в множество
True
>>> x - y                   # Разность множеств   
{'a', 'c', 'e'}
>>> x | y                   # Объединение
{'a', 'z', 'x', 'y', 'c', 'b', 'd', 'e'}

>>> x & y                   # Пересечение  
{'b', 'd'}
>>> x ^ y                   # Симметрическая разность (XOR) 
{'a', 'z', 'x', 'y', 'c', 'e'}

>>> x > y, x < y            # Надмножество, подмножество
(False, False)


Методы (весь перечень смотрите п офункции dir):

add - вставляет новый элемент в множество;
update - выполняет объединение;
remove - удаляет элемент по его значению.   

>>> z = x.intersection(y)
>>> z
{'d', 'b'}
>>> z.add('spam')
>>> z
{'d', 'spam', 'b'}
>>> z.update(set(['x', 'y']))
>>> z
{'y', 'd', 'x', 'spam', 'b'}
>>> z.remove('b')
>>> z
{'y', 'd', 'x', 'spam'}

Операторы родственные упомянутым выше могут работать с любыми объектами итерируемых типов:

>>> s = set([1, 2, 3])
>>> s | set([3, 4])
{1, 2, 3, 4}
>>> s | [3, 4]
Traceback (most recent call last):
  File "<pyshell#121>", line 1, in <module>
    s | [3, 4]
TypeError: unsupported operand type(s) for |: 'set' and 'list'
>>> s.union([3, 4])
{1, 2, 3, 4}
>>> s.intersection((1, 3 , 5))
{1, 3}
>>> s.issubset(range(-5, 5))
True


Изменения в Питон 3.х

>>> set([1, 2, 3, 4])
{1, 2, 3, 4}
>>> {1, 2, 3, 4}        # Питон 3.х
{1, 2, 3, 4}

- эти два способа идентичны.

В Питон 3.х встроенная функция set всё еще необходима для создания пустых множеств и конструировании множеств на основе итерируемых объектов.

>>> set('spam')
{'p', 'm', 's', 'a'}
>>> s = {'s', 'p', 'a', 'm'}
>>> s.add('alot')
>>> s
{'alot', 'm', 'p', 'a', 's'}

Обратим внимание, что конструкция {} по-прежнему создает пустой словарь.

>>> s1 = {1, 2, 3, 4}
>>> s1 - {1, 2, 3, 4}         # вывод пустого множества
set()
>>> type({})                  # литерал {} обозначает пустой словарь   
<class 'dict'>
>>> s = set()                 # инициализация пустого множества
>>> s.add(1.23)
>>> s
{1.23}


Ограничения, связанные с неизменяемостью и фиксированные множества.

Множества могут включать объекты только неизменяемфых (так называемый "хешируемых") типов.
Отсюда следует, что списки и словари не могут добавляться в множество, однако можно исполььзовать кортежи, если необходимо сохранить составные значения.
>>> s
{1.23}
>>> s.add([1, 2, 3])
TypeError: unhashable type: 'list'
>>> s.add({'a':1})
TypeError: unhashable type: 'dict'
>>> s.add((1, 2, 3))
>>> s
{1.23, (1, 2, 3)}
>>> s | {(4, 5, 6), (1, 2, 3)}
{1.23, (4, 5, 6), (1, 2, 3)}
>>> (1, 2, 3) in s
True
>>> (1, 4, 3) in s
False
 
Кортежи в множествах могут использоваться, например, для хранения дат, записей, IP-адресов и т.д.
Сами по себе множества нельзя добавлять в другие множества, но с помощью функции frozenset можно, она которая создает неизменяемое множество, которое невозможно изменить, и это дает возможность добавлять.


Генераторы множеств.

>>> {x ** 2 for x in [1, 2, 3, 4]}
{16, 1, 9, 4}

Мы видим, что генераторы множеств, как и в случае с генератором списков выполняет свою работу так - "Вернуть множество, содержащее квадраты значений х, для каждого х из списка".

>>> {x for x in 'spam'}
{'p', 'm', 's', 'a'}

>>> {c * 4 for c in 'spam'}
{'ssss', 'pppp', 'aaaa', 'mmmm'}
>>> {c * 4 for c in 'spamham'}
{'ssss', 'hhhh', 'pppp', 'aaaa', 'mmmm'}

>>> s = {c * 4 for c in 'spam'}
>>> s | {'mmmm', 'xxxx'}
{'xxxx', 'mmmm', 'ssss', 'pppp', 'aaaa'}
>>> s & {'mmmm', 'xxxx'}
{'mmmm'}


Где могут использоваться множества?

Помимо математических вычислений множества могут использоваться в ряде прикладных областей.

Используя уникальность множеств можно использовать их для фильтрации повторов в других коллекциях.

>>> l = [1, 2, 1, 3, 2, 4, 5]
>>> set(l)
{1, 2, 3, 4, 5}
>>> l = list(set(l))
>>> l
[1, 2, 3, 4, 5]
  
Можно также использовать множества для хранения пунктов, которые уже были посещены в процессе обхода графа или другой циклической структуры.

Множества удобно использовать при работе с большими массивами данных (например запросы к БД) - операция пересечения двух множеств позволит получить объекты, присутствующие сразу в обеих категориях, а объединение - все объекты, присутствующие в любом из множеств.

>>> engin = {'bob', 'sue', 'ann', 'vic'}
>>> manag = {'tom', 'sue'}
>>> 'bob' in engin              # bob инженер?
True
>>> engin & manag               # Кто одновременно инженер и менеджер?
{'sue'}
>>> engin | manag               # Все сотрудники из обеих категорий    
{'tom', 'vic', 'bob', 'ann', 'sue'}
>>> manag - engin                   # Менеджеры не являющиеся инженерами
{'tom'}
>>> engin - manag               # Инженеры не являющиеся менеджерами
{'bob', 'ann', 'vic'}
>>> engin > manag               # Все менеджеры являются инженерами? (надмножество)
False
>>> {'bob', 'sue'} < engin      # Оба сотрудники инженеры? (подмножество)
True
>>> (manag | engin) > manag     # Множество всех сотрудников является 
True                              надмножеством менеджеров

>>> manag ^ engin               # Сотрудники принадлежащие какой-то одной категории
{'bob', 'ann', 'tom', 'vic'}
>>> (manag | engin) - (manag ^ engin)    # Пересечение!
{'sue'}

   

Логические значения.

Официально в Питон имеется логический тип bool, с двумя предопределенными значениями True и  False. Эти значения являются экземплярами класса bool, который в свою очередь является всего лишь подклассом (в ООП смысле) целочисленного типа int.
True и False ведут себя как целочисленные значения 1 и 0, за исключением, что выводятся на экран они по-другому.
Нужно внимательно следить, т.к. из-за особенности этого типа можно получить интересные результаты:

>>> type(True)
<class 'bool'>
>>> isinstance(True, int)
True
>>> True == 1
True
>>> True is 1
False
>>> True or False         # то же, что и 1 or 0 
True
>>> True + 4              # а вот и обещанный прикол, получилось как-будто 1 + 4
5


Числовые расширения.

Поскольку числовая обработка данных является популярным применением Питон вы найдете массу дополнительных инструментов.

Напрмиер расширение - NumPy (Numeric Python). Это расширение нужно устанавливать отдельно, оно не идет с Питоном вместе.



Глава 6. Интерлюдия о динамической типизации. стр. 194 

В этой главе мы детально ознакомимся с самой фундаментальной идеей языка Питон - динамической типизацией и полиморфизмом, которые составляют основу гибкости этого языка программирования.

Простым языком - полиморфизм, это когда одна функция (оператор, метод) могут по-разному выполняться для разных типов объектов, как например оператор + по-разному действует для чисел и строк.


Остутствие инструкций объявления.

Типы данных в Питон определяются автоматически во время выполнения, а не в результате объявления в программном коде (в отличие от С++ или Java).


Переменные, объекты и ссылки.

Отметим, что когда выполняется операция присваивания, типо a = 3, интерпретатор выполняет её, хотя перед этим ему нигде не сообщалось, что а - это имя переменной и тип - целочисленный объект.
В Питоне это происходит естественным способом:
 
- Создание переменной - переменная (т.е. имя), такая как a, создается автоматически когда в программном коде ей впервые присваивается значение.
Если переменная а уже есть то она просто получает новое значение

- Типы переменных - переменные не имеют никакой информации о типе или ограничениях, связанных с ним. Понятие типа присуще объектам, а не именам. Т.е. у нашей переменной "а" тип имеется лишь у объекта - 3 (целочисленный тип), а не у самой переменной "а". 
Переменные универсальны, они являются лишь ссылками на конкретные объекты в конкретные моменты времени.

- Использование переменной - когда переменная учатсвует в выражении её имя замещается объектом на который она ссылается в настоящий момент.
Конечно перед использованием переменную нужно инициализировать, иначе будет вызвана ошибка.

Рассмотрим команду а = 3, она выполняется в 3 этапа:

- создается объект, представляющий число 3;
- создается переменная а, если она еще отсутствует;
- в переменную а записывается ссылка на вновь созданный объект, представляющий число 3.

Имя - ссылка - объект

Кстати объекты могут ссылаться на другие объекты, например список ссылается на объекты из своего списка.
А переменные не могут ссылаться на другие переменные, только на объекты.

Ссылки на объекты это, своего рода, ассоциативные связи, реализованные в виде указателя на область памяти.

Переменные - это записи в системной таблице, где предусмотрено место для хранения ссылок, на объекты.

Объекты - это области памяти с объемом, достаточным для представления значений этих объектов.

Ссылки - это автоматически разыменовываемые указатели на объекты.


С технической точки зрения объекты не так просты. Они имеют два поля: описатель типа - хранит информацию о типе объекта и счетчик ссылок - используемый для определения когда память, занимаемая объектом, может быть освобождена.


Информация о типе хранится в объекте, но не в переменной.

>>> a = 3         # тип - целое число
>>> a = 'spam'    # тип - строка
>>> a = 1.23      # тип - вещественное число

- здесь у нас изменяется ссылка на объект, а не изменение типа переменной с числа на строку и обратно. Т.е. мы видим как переменная ссылается на конкретный объект в конкретный момент времени.

Итак, типы в Питон - это свойство объекта, а не переменной. Объект сам знает какого он типа, переменной эта информация не нужна.


Объекты уничтожаются автоматически. стр.198. 

>>> a = 3        
>>> a = 'spam'    

Каждый раз когда имя ассоциируется с новым объектом Питон освобождает память, занимаемую предыдущим объектом (если на него не ссылается какое-либо другое имя или объект).
Это называется - сбокрой мусора (garbage collection).

x = 42
x = 'spam'
x = 3.1415
x = [1, 2, 3]

- так, с условием, что на объекты не ссылаются другие переменные или объекты, с каждым новым присвоением х уничтожается старый объект.

Это происходит благодаря счетчику ссылок, с помощью которого интерпретатор следит за ссылками на объект. Как только счетчик равен 0 объект уничтожается.


Разделяемые ссылки.

>>> a = 3
>>> b = a

В итоге получается такая схема - имена a, b ссылаются своиими ссылками на один и тот же объект.
Это называется - разделяемая ссылка, несколько имен ссылаются на один и тот же объект.

Если мы теперь изменим а, то ситуация будет следующей:

>>> a = 3
>>> b = a
>>> a = 'spam'
>>> b
3

Т.е. мы видим, что ссылка у переменной b осталась на объект - 3, а ссылка переменной а изменилась, она стала на объект - 'spam'.
Теперь оба имени ссылаются на разные объекты.

И наоборот - при изменении b ссылка a не изменилась бы, а как и раньше ссылалась бы на объект - 3.

>>> a = 5
>>> b = a
>>> a = a + 6
>>> b
5

- даже такая сложная схема по-прежнему иллюстрирует, что оба имени ссылаются на разные объекты в конце выражений.


Разделяемые ссылки и изменяемые объекты.

Не забываем, что в Питон существуют объекты и операции, которые изменяют сами объекты. Например изменения элемента списка изменяют сам список.

>>> l1 = [1, 2, 3]
>>> l2 = l1

- применим одну из операций к спискам:

>>> l1[0] = 24
>>> l1
[24, 2, 3]
>>> l2
[24, 2, 3]

- здесь мы изменяем, не сам объект l1, а компонент объекта, и в итоге изменяется сам объект и получаем также изменение в переменной l2!

! - Такое поведение объектов нужно запомнить и внимательно следить за разработкой ваших программ, ведь можно не заметить как изменение одного объекта может привести к изменению другого и вы получите результат, которого совсем не ожидали. Тщательно проверяйте весь код.

Избежать такого поведения языка Питон можно выполнять копирование объектов, вместо создания ссылок.
Это можно сделать с помощью функции list и модуля copy из стандартной библиотеки.
Однако самый стандартный способ копирования это получение среза от начала до конца списка:

>>> l1 = [2, 3, 4]
>>> l2 = l1[:]
>>> l1[0] = 24
>>> l1
[24, 3, 4]
>>> l2
[2, 3, 4]

Словари нужно копировать другим способом, т.к. они не являются последовательностями. Чтобы скопировать словарь необходимо воспользоваться методом X.copy().

>>> import copy
>>> x = copy.copy(y)      # Создание "поверхностной" копии любого объекта y 
>>> x = copy.deepcopy(y)  # Создание полной копии: копируются все вложенные ссылки

- В число объектов, подверженных описанным выше изменениям входят такие объекты как - списки, словари и некоторые объекты, объявленные с помощью инструкции class.



Разделяемые ссылки и равенство.

>>> x = 42
>>> x = 'spam'

Т.к. интерпретатор Питона кэширует и повторно использует малые целые числа и небольшие строки, объект 42 скорее всего не будет уничтожен. Он останется в системной таблице для повторного использования (вдруг нам снова понадобится какой-нибудь объект равный 42).
Но это относится только к малому числу объектов, например к таким как - малые целые числа и небольшие строки.


Равенства.

>>> l = [1, 2, 3]
>>> m = l           # ссылка на один и тот же объект

>>> l == m          # Одно и то же значение
True
>>> l is m          # Один и тот же объект    
True

- т.е. оператор  ==  сравнивает значения объектов, а оператор - is проверяет идентичность объектов, т.е. ссылаются ли оба имени на один и тот же объект.

Если точнее, то is сравнивает указатели, которые реализуют ссылки и, т.о., может использоваться для выявления разделяемых ссылок в программном коде.

Для проверки простого равенства достаточно == (он чаще и используется).

>>> l = [1 ,2 , 3]
>>> m = [1, 2, 3]
>>> l == m
True
>>> l is m          # значения одинаковы, а объкты разные
False  

- видим наглядную разницу операторов.

Еще один интересный пример:

>>> x = 42
>>> y = 42
>>> x == y
True
>>> x is y
True

- здесь мы видим как переплетаются операторы сравнения и особенности кэширования в Питон, в результате видим, что обе переменные ссылаются на один объект, хотя, теоретически, должны ссылаться на разные объекты.

Мы можем запрашивать у интерпретатора количество ссылок на объект. Функция getrefcount из модуля sys возвращает значения поля счетчика ссылок в объекте.

>>> import sys
>>> sys.getrefcount(x)
11
>>> sys.getrefcount(1)
1156
>>> sys.getrefcount(y)
11
>>> sys.getrefcount(42)
12
>>> sys.getrefcount(1)
1156

- большая часть ссылок была создана системным программным кодом самой IDLE (например число 1).
Т.к. строки и числа не могут изменяться совершенно не важно сколько ссылок будет указывать на один и тот же объект, главное нужно запомнить, что в Питоне есть автоматическая сборка мусора и она реально работает.



Глава 7. Строки. стр. 207

Строки - упорядочненные последовательности символов, используемые для хранени и представления текстовой информации.

С функциональной точки зрения строки могут использоваться для представления всего, что может быть выражено в текстовой форме: символы и слова, содержимое текстовых файлов, загруженных в память, адреса в Интернете, программы на Питоне и т.п. И также для хранения двоичных значений байтов и символов Юникода.

Строки в Питоне играют ту же роль, что и массивы символов в С.  

Фактически, строки - это первый представитель большого класса объектов, называемых последовательностями. 
Строки неизменяемы, т.е. символы, которые они содержат, имеют определенный порядок следования слева направо и сами строки невозможно изменить.

стр. 208 табл. "Наиболее типичные литералы строк и операции"  

Литералы строк.

Строки в апострофах - 'spa"m'
Строки в кавычках - "spa'm"
Строки в тройных кавычках - '''...spam...''', """...spam..."""
Экранированные последовательности - "s\tp\na\0m"
Неформатированные строки - r"C:\new\test.spm"
Строки байтов в версии 3.0 - b'sp\x01am'
 

Строки в апострофах и кавычках.

>>> 'spam', "spam"      # строки в кавычках и апострофах идентичны
('spam', 'spam')
 
Такая транскрипция написания строк нужна для того, чтобы вставлять символы апострофа и кавычек в строки без использования слеша:

>>> "knight's", 'knight"s'    # вот такой простой пример использования обоих способов
("knight's", 'knight"s')

- можно и простой слеш использовать:

>>> "knight\"s", 'knight\'s'     # при этом меняется строка вывода, заметьте
('knight"s', "knight's")         # в выводе в строке нет набора символов одного типа  


Питон автоматически объединяет последовательность строковых литералов внутри выражения, хотя можно бы и добавить оператор + но Питон автоматически проводит конкатенацию строк:

>>> title = "Peace " 'of' " sheet"
>>> title
'Peace of sheet'

- а если поставим запятые, то получим кортеж, а не строку: 

>>> title = "Peace ", 'of', " sheet"
>>> title
('Peace ', 'of', ' sheet')


Экранированные последовательности представляют служебные символы.

С помощью слеша вставляются специальные символы, известные как - экранированные последовательности.
Экранированные последовательности удобно использовать для вставки в строки служебных символов.

>>> s = 'a\nb\tc'

\n - байт, содержащий двоичное значение кода символа новой строки

\t - символ табуляции

>>> s
'a\nb\t\c'
>>> print(s)
a
b  c

>>> len(s)
5

- длина этой строки 5 байтов, хотя в выводе функции print мы видим всего 3 символа.

стр. 212 - таблица "Экранированные последовательности"

>>> s = 'a\0b\0c'       # в этой строке два нулевых байта 
>>> s
'a\x00b\x00c'
>>> print(s)
a'null'b'null'c
>>> len(s)
5

В Питоне нулевой байт (символ null) не является признаком завершения строки, как в языке С.

Еще пример, запишем строку, в которой указаны двоичные значения 1 и 2 (записанные в восьмеричной форме), и далее следует двоичное значение 3 (записанное в шестнадцатеричной форме).

>>> s = '\001\002\x03'
>>> s
'\x01\x02\x03'

- мы видим, что интерпретатор Питон отображает непечатаемые символы в шестнадцатеричном представлении, независимо от того, в каком виде они были указаны внутри литерала.

>>> s = "s\tp\na\x00m"
>>> s
's\tp\na\x00m'			# \x00 - это нулевой символ в шестнадцатеричном представлении
>>> len(s)
7
>>> print(s)
s p
a m

Если интерпретор не понимает символ после слеша как корректный служебный символ, он просто соатвляет символ обратного слеша в строке: 

>>> x = "C:\py\code"
>>> x
'C:\\py\\code'
>>> print(x)
C:\py\code


Еще одно замечание, если нам требуется работать с двоичными данными, то открывать файлы с ними нужно в режиме двоичного доступа (добавляя к флагу режима открытия флаг b, например - 'rb', 'wb' b т.д.).
В Питоне 3.0 содержимое двоичных файлов интерпретируется как коллекция строк типа bytes, которые по своим возможностям напоминают обычные строки. 



Неформатированные строки подавляют экранирование.

Обратим внимание на команду, с помощью которой мы хотим открыть файл text.txt из папки C:\new - 

mytest = open('C:\new\text.txt', 'w')

- здесь мы видим в чем будет заключаться подводные камни: последовательность \n интерпретируется как символ новой строки, а последовательность \t замещается символом табуляции, и в итоге мы получим ошибку:

>>> mytest = open('C:\new\text.txt', 'w')
Traceback (most recent call last):
  File "<pyshell#9>", line 1, in <module>
    mytest = open('C:\new\text.txt', 'w')
OSError: [Errno 22] Invalid argument: 'C:\new\text.txt'


Именно в таких случаях удобно использовать неформатированные строки, для этого перед кавычками ставим символ r (в верхнем или нижнем регистре), он отключает механизм экранирования.

>>> mytest = open(r'C:\new\text.txt', 'w')
>>> mytest
<_io.TextIOWrapper name='C:\\new\\text.txt' mode='w' encoding='cp1251'>

Ну или, конечно, можно просто продублировать символы слеша:

>>> mytest = open('C:\\new\\text.txt', 'w')

Сам интерпретатор Питон, в определенных случаях, использует удваивание обратного слеша при выводе строк, обратный слеш:  

>>> path = r'C:\new\text.txt'
>>> path
'C:\\new\\text.txt'				# вот так интерпретатор представляет эту строку
>>> print(path)
C:\new\text.txt					# более дружественный формат представленя		
>>> len(path)
15
 
Так же как и с числами, при выводе результатов в интерактивной оболочке по умолчанию используется такой формат представления, как если бы это был программный код, отсюда и экранирование символов обратного слеша.
А инструкция print обеспечивает более дружественный формат. 
 

Помимо хранения имен каталогов в Windows, неформатированные строки обычно используются для регулярных выражений (поиск по шаблону, благодаря модулю re).
Следует отметить, что в сценариях Питона, в строках с именами каталогов систем Windows и Unix можно использовать простые символы слеша, потому что Питон стремится поддерживать переносимость для путей к файлам. 
И все же для каталогов в стиле Windows удобнее использовать неформатированные строки.


Замечание.
Даже неформатированная строка не должна заканчивать символом обратного слеша, иначе он заэкранирует собой закрывающую кавычку:

r"...\"   -  недопустимый строковый литерал!

Если такая необходимость есть, можно добавить два символа и затем удалить второй из них (r'1\nb\tc\\'[:-1]), добавить один символ вручную (r'1\nb\tc'+'\\') или использовать обычный синтаксис и дублировать все символы обратного слеша ('1\\nb\\tc\\') 



Тройные кавычки, многострочные блоки текста.

Этот формат иногда называют блочной строкой, который удобно использовать для определения многострочных блоков текста в программном коде.

Синтаксис состоит из трех символов кавыек (или апострофов), которые закрываются такими же тремя кавычками.
Внутри такой строки могут находиться и кавычки и апострофы, при этом их не нужно экранировать.

Примеры:

>>> mantra = """Always look
 on the dright
 side of life."""
>>> mantra
'Always look\n on the dright\n side of life.'
>>> print(mantra)
Always look
 on the dright
 side of life.
 
>>> man = """One
 two
 three."""
>>> man
'One\n two\n three.'

>>> man = """One			# здесь я сознательно после перевода строки удалил пробел перед three
  two
three."""					# оказывается, после перевода строки, в таком формате,
                              автоматически ставится пробел перед след строкой  
>>> man
'One\n  two\nthree.'		# как мы и видим, пробела нет и далее print нам всё покажет еще раз
>>> print(man)
One
  two
three.   

>>> mantra = """ Always look 	
 on the dright
 side of life."""				# вот я перед словом Always поставил пробел и все строки на одном
								  уровне стали, как видно после вывода инструкции print	
>>> print(mantra)
 Always look
 on the dright
 side of life.


Таким нехитрым способом мы можем пользоваться если нам необходимо ввести в программе многострочный текст, например сообщение об ошибке или код разметки на HTML или XML.


Еще одно применение тройных кавычек, это хакерский способ отключения строк программного кода во время разработки. 
Например если нам требуется отключить большой участок кода это довольно неудобно ведь в таком случае в сотне строк кода нужно ставить знак комментариев в каждой строке.
Но можно воспользоваться такой "хитростью":   

x = 1
"""
import os
print(os.getcwd())
"""
y = 2
 


Строки в действии. стр. 217

Базовые операции.

>>> len('abc')				# Длина: число элементов 
3
>>> 'abc' + 'def'			# Конкатенация (сложение строк): новая строка 
'abcdef'
>>> 'NIL!' * 4				# Повторение: подобно 'NIL!'+'NIL!'+'NIL!'
'NIL!NIL!NIL!NIL!'

>>> print('--------------------')		# пример удобства базовых операций, на примере повторения
--------------------
>>> print('-' * 20)
--------------------


- Обратим внимание, здесь происходит перегрузка операторов, + и *, которые используются для операций сложения и умножения с числами.

! - Но складывать строки и числа нельзя! Это приведет к ошибке.


Выполним обход элементов строки в цикле, используя инструкцию for, и проверим вхождение подстроки в строку с помощью оператора выражений in, который, по сути, выполняет операцию поиска.
В случае поиска подстрок, оператор in напоминает метод str.find(), который мы рассмотрим далее, но in возвращает логический результат, а не позицию подстроки в строке:

>>> myjob = "hacker"
>>> for c in myjob: print(c, end=' ')		# символ : обязателен, без него выдает ошибку
											  хотя вся команда в одну строку				
h a c k e r 

>>> for c in myjob: print(c, end='\\')

h\a\c\k\e\r\

>>> 'k' in myjob
True
>>> 'z' in myjob
False
>>> 'spam' in 'abcspamdef'
True

- Оператор цикла for присваивает переменной очередной элемент последовательности (в нашем случае - строки) и для каждого элемента выполняет одну или более инструкций.
В результате переменная 'c' превращается в своего рода курсор, который постепенно перемещается по строке.
Далее в книге мы более подробнее рассмотрим средства выполнения итераций.



Доступ по индексам и извлечение подстроки.

Т.к. строки это у нас упорядоченные коллекции символов, то обращаться к элементам строки можно по номерам позиций.
Индексирование - операция, с указанием числового смещения в квадратных скобках после имени строки.


стр. 219 рис. 7.1 Смещения и срезы. Наглядно демонстрируется индексация.


Индексирование в Питон начинается с 0. Т.е. первый символ имеет индекс 0, второй 1 и т.д. Индексация с конца начинается с -1 (т.к. отрицательного 0 мы не знаем), в принципе всё это понятно и по рисунку 7.1.

>>> s = 'spam'
>>> s[0], s[-2]
('s', 'a')

-  s[0] возвращает нам элемент со смещением 0, это, естественно первый символ,
-  s[-2] возвращает второй символ с конца, это эквивалентно записи (4+(-2)) от начала.
   
>>> s[1:3], s[1:], s[:-1]
('pa', 'pam', 'spa')

- эти операции демонстрируют нам операции - извлечения среза, в некотором роде это форма синтаксического анализа. В случае среза Питон возвращает новый объект, содержащий непрерывную область, определяемую парой смещений.

Левая граница смещения (нижняя) - включительна, а правая (верхняя) - не входит в срез. 
Если левая или правая или обе границы опущены, по умолчанию принимаются значения раные 0 (см. пример выше).

Краткая справка.

Операция индексирования (s[i]) извлекает компоненты по их смещениям:

- Первый элемент имеет смещение 0.
- Отрицательные индексы определяют смещение в обратном порядке.
- s[0] извлекает первый элемент.
- s[-2] извлекает второй с конца элемент (так же, как и выражение s[len(s)-2]).

Операция извлечения подстроки (s[i:j]) извлекает непрерывный раздел последовательности:

- Элемент с индексом, равным верхней границе, не включается в срез.
- Если границы не указаны, по умолчанию они берутся равными 0 (по одной, или обе сразу, не важно).
- s[1:3] извлекает элементы со смещением от 1 до 3 (не включая элемент со смещением 3).
- s[1:] извлекает элементы, начиная со смещения 1 и до конца.
- s[:3] извлекает элементы, начиная со смещения 0 и до 3 (не включая его).
- s[:] извлекает элементы, начиная со смещения 0 и до конца - это эффективный способ создать поверхностную копию последовательности s.


Последний пункт списка - это самый обычный трюк, с его помщью создается полная поверхностная копия объекта, т.е. объект с тем же значением, но расположенный в другой области памяти.
Этот прием не очень полезен с неизменяемыми объектами (строки), но его ценность возрастает при работе с изменяемми объектами (списки).


Расширенная операция извлечения подстроки: третий предел.

Вообще, в операции среза имеется еще и третий, необязательный, индекс. Т.е. полная форма записи выглядит как - s[I:J:K], где К - это шаг среза. По умолчанию шаг равен 1, поэтмоу при обычной операции извлечения мы его не указываем.

Например выражение Х[1:10:2] вернет каждый второй элемент последовательности Х в диапазоне смещений от 1 до 9 (т.е. 1, 3, 5, 7, 9).

>>> s = 'abcdefghijklmnop'
>>> s[1:10:2]
'bdfhj'
>>> s[::2]
'acegikmo'


Можно также использовать отрицательное значение шага, например:

>>> s = 'hello'
>>> s[::-1]
'olleh'   

- в результате получаем перевернутую последовательность.

Выражение s[5:1:-1] извлечет элемент со 2 по 5 в обратном порядке (5, 4, 3, 2):

>>> s = 'abcdefg'
>>> s[5:1:-1]
'fedc'


Далее в книге мы еще встретимся с срезами с тремя пределами когда будем изучать цикл for.

Также познакомимся с тем, что операция извлечения среза эквивалентна операции индексирования, в которй в качестве индекса используется специальный объект среза, что может быть важно для разработчиков классов, которым требуется реализовать поддержку обеих операций:

>>> 'spam'[1:3]				# Синтаксис извлечения среза
'pa'
>>> 'spam'[slice(1, 3)]     # Использование объекта среза
'pa'
>>> 'spam'[::-1]
'maps'
>>> 'spam'[slice(None, None, -1)]
'maps' 


Примеры для изучения.

Ознакомимся с примером, в котором аргументы командной строки, переданные сценарию Питон при запуске, доступны в виде атрибута argv встроенного модуля sys:

#File echo.py
import sys
print(sys.argv)     
 
% echo.py -a -b -c
['C:\\Python34\\myfile.py', '-a', '-b', '-c']  


Из этого вывода, с помощью операции среза, мы можем получить список аргументов, без имени программы, делается это все с помощью небольшого изменения: 

#File echo.py
import sys
print(sys.argv[1:])     
 
% echo.py -a -b -c			# простое решение, если нам нужно получить только аргументы из консоли
['-a', '-b', '-c']  

       
Также операция среза позволяет нам удалять лишние элементы из строк, например перевод строки можно удалить срезом line[:-1] хотя предпочтительнее использовать метод line.rstrip



Инструменты преобразования строк.

Один из девизов Питона - не поддаваться искушению делать предположения о том, что имелось в виду.

Например случай когда Питон не дает сложить строку с числом, даже если строка выглядит как число:
'42' + 1	# будет сообщение об ошибке

Т.к. в этом случае суть оператора + не ясна для интерпретатора (сложение или конкатенация), он воспринимает такую инструкцию как ошибочную.

Вообще в Питоне отвергается любая магия, которая может осложнить жизнь программиста.


В подобных случаях можно использовать инструменты преобразования, например:

>>> int("42"), str(42)		# преобразование из/в строку 
(42, '42')
>>> repr(42)		# преобразование в строку, как если бы она была лдитералом в программном коде 
'42' 	

- функция repr преобразует объект в строковое представление, но возвращает объект в виде строки программного кода, который можно выполнить, чтобы воссоздать объект.

>>> print(str('spam'), repr('spam'))
spam 'spam'

>>> print('spam')			# добавил это выражение сам, чтобы яснее было выражение выше
spam    


Итак, мы можем вручную выполнять необходимые преобразования операндов перед операциями:

>>> s = '42'
>>> i = 1
>>> s + i
...
TypeError: Can't convert 'int' object to str implicitly
>>> 
>>> int(s) + i			# выполняем операцию сложения
43
>>> s + str(i)			# выполняем операцию конкатенации
'421'


И с вещественными числами:

>>> str(3.1415), float("1.5")
('3.1415', 1.5)
>>> 
>>> text = "1.234E-10"
>>> float(text)
1.234e-10


Далее в книге мы познакомимся со встроенной функцией eval - она выполняет строку, содержащую программный код на Питоне, и поэтому может выполнять преобразование строки в объект любого вида.

Функции int и float преобразуют только числа, но они и работают быстрее и безопаснее, потому что не принимают программный код произвольного выражения.



Преобразование кодов символов.

Имеется также возможность выполнить преобразование одиночного символа в его целочисленный код ASCII, для чего нужно передать этот символ функции ord - она возвращает фактическое числовое значение соотвествующего байта в памяти.

Обратное преобразование выполняется функцией chr, она получает код ASCII и преобразует его в символ:

>>> ord('s')
115
>>> chr(115)
's'


Пример некоторой символьной математики:

>>> s = '5'
>>> s = chr(ord(s) +1)
>>> s
'6'
>>> s = chr(ord(s)+1)
>>> s
'7'


Пример преобразования альтернативный встроенной функции int:

>>> int('5')
5
>>> ord('5') - ord('0')
5


Такие преобразования могут использоваться с операторами цикла, для получения целочисленных значений из строковых представлений двоичных чисел.
В каждой итерации текущее значение умножается на 2 и затем к нему прибавляется числовое значение следующей цифры:

>>> b = '1101'	    # двоичные цифры преобразуются в числа с помощью функции ord			 	
>>> i = 0
>>> while b != '':
	i = i*2 +(ord(b[0]) - ord('0'))
	b = b[1:]

	
>>> i
13


Операция побитового сдвига влево (i << 1) могла бы дать тот же эффект, что и операция умножения на 2. А также с помощью функций int и bin:

>>> int('1101', 2)
13
>>> bin(13)
'0b1101'



Изменение строк. стр. 225

Итак, строки - неизменяемая последовательность. Неизменяемая означает, что мы не можем изменить элемент строки, выполнив присваиваниме по индексу:

>>> s = 'spam'
>>> s[0] = "x"
...
TypeError: 'str' object does not support item assignment 


Чтобы изменить строку, нужно создать новую (с помощью операций извлечения подстроки и конкатенации) и, при необходимости, присвоить результат первоначальному имени:

>>> s = s + 'SPAM'		# можно назвать как "изменение" первоначальной строки
>>> s
'spamSPAM'

>>> s = s[:4] + 'Burger' + '!'		# здесь мы замещаем символы таким нехитрым способом
>>> s
'spamBurger!'

- замешение можно провести методом replace:

>>> s = 'splot'
>>> s = s.replace('pl', 'pamal')
>>> s
'spamalot'


Т.о. мы видим, что строковые методы созадют новые строковые объекты, при этом мы можем присвоить их переменной (хоть новой хоть старой переменной).

К тому же создание нового объекта для каждого изменения это не столь неэффектвиная операция как может показаться, на самом деле при создании новых объектов они используют те же области памяти, что и прежние.

Интерпретатор Питон работает намного бытсрее чем омжно было бы ожидать.


Ниже приведем два примера подстановки значений объектов в строку (при этом объекты преобразуются в строку) при помощи т.н. спецификаторов формата:

>>> 'That is %d %s bird!' % (1, 'dead')		# Выражение форматирования	
'That is 1 dead bird!'

>>> 'That is {0} {1} bird!'.format(1, 'dead')	   # Метод форматирования, применяем сразу к строке
'That is 1 dead bird!'

- Замечание! Во втором примере я попытался вместо 0 и 1 вставить 12 и 13 и интерпретатор выдал ошибку. 
Насколько я понимаю, 0 и 1 это индексированные номера параметров передаваемых методом - т.е. 0 это индекс параметра 1 (из метода format), а 1 - это индекс параметра 'dead' (из метода format).  


Далее мы сначала познакомимся с методами строк, а затем уже перейдем к приемам форматирования строк.

Примечание:
- В Питоне 3.0 появился новый строковый тип bytearray, который относится к категории изменяемых. В действительности же, объекты типа bytearray не являются строками - это последовательности 8-битных целых чисел. При отображении они выводятся как строки символов ASCII. Объекты этого типа обеспечивают возможность хранения больших объемов текста, который требуется изменять достаточно часто.
И далее мы увидим, что ord и chr могут работать с символами Юникода.



Строковые методы. стр. 227

Методы - это просто функции, которые связаны с определенными объектами. Формально они являются атрибутами, присоединенными к объектам, которые ссылаются на функции.

В Питоне выражения и встроенные функции могут работать с наборами типов, но методы  - являются  специфичными для типов объектов (т.е. строковые методы работают только с строками и т.п.).

В Питоне 3.0 некоторые методы могут относиться к разным типам (напр. count), но при этом функциональность такого метода может быть разной для разных типов.


Функции - это пакеты программного кода, а вызовы методов объединяют в себе выполнение двух операций (извлечение атрибута и вызов функций).

Извлечение атрибута - выражение вида object.attribute означает: "Извлечь значение атрибута attribute из объекта object".

Вызов функции - выражение вида function(arguments) означает: "Вызвать программный код функции function, передав ему ноль или более объектов-аргументов arguments, разделенных запятыми, и вернуть значение функции".

Объединение этих двух действий позволяет вызвать метод объекта. 

Выражение вызова метода object.method(arguments) вычисляется слева направо, т.е. интерпретатор сначала извлекает метод объекта, а затем вызывает его, передавая ему входные аргументы. 
Если метод возвращает какой-либо результат, он становится результатом всего выражения вызова метода.  
       

Как мы увидим далее большинство объектов обладает методами, которые можно вызвать, и все они доступны с использованием одного и того же синтаксиса вызова метода.


Табл. 7.3 Строковые методы.  стр. 228


Примеры использования строковых методов: изменение строк. стр. 229

Изменим два символа в середине строки:

>>> s = 'spammy'
>>> s = s[:3] + 'xx' +  s[5:]
>>> s
'spaxxy'

Также можно воспользоваться методом replace (в этом случае даже логичнее это метод):

>>> s = 'spammy'
>>> s = s.replace('mm', 'xx')
>>> s
'spaxxy'

Метод repalce является более универсальным чем кажется. Он принимает в качестве аргумента оригинальную подстроку (любой длины) строку замены (также любой длины), и выполняет глобальный поиск с заменой:

>>> 'aa$bb$cc$dd'.replace('$', 'SPAM')
'aaSPAMbbSPAMccSPAMdd'

- видм, что в подобном случае метод replace может использоваться как инструмент реализации поиска с заменой по шаблону.


Если нужно заменить подстроку фиксир. размера, которая может быть в любом месте, можно также выполнить операцию замены или найти подстроку с помощью метода find:

>>> s = 'xxxxSPAMxxxxSPAMxxxx'
>>> where = s.find('SPAM')					# поиск позиции
>>> where									# подстрока найдена со смещением 4
4
>>> s = s[:where] + 'EGGS' + s[(where+4):]
>>> s
'xxxxEGGSxxxxSPAMxxxx'

- если подстркоа не найдена метод find возвращает -1


Еще один вариант сипользования метода replace заключается в передаче третьего аргумента, который определяет число производимых замен:

>>> s = 'xxxxSPAMxxxxSPAMxxxx'
>>> s.replace('SPAM', 'EGGS')			# заменить все найденные подстроки
'xxxxEGGSxxxxEGGSxxxx'
>>> 
>>> s.replace('SPAM', 'EGGS', 1)		# заменить одну подстроку
'xxxxEGGSxxxxSPAMxxxx' 
 	   
- заметьте! Несмотря на то, что метод называется replace (заменить), в действительности он создает новую строку, т.е. методы, на самом деле, никогда не изменяют строки, даже если у них и громкое название как у replace.


Такое создание новых строк может оказаться недостатком использования методов. Если в сценарии много изменений длинных строк (при этом ведь создается такое же количество новых строк), можно повысить производительность сценария, преобразовав строку в изменяемый объект:

>>> s = 'spammy'
>>> l = list(s)
>>> l
['s', 'p', 'a', 'm', 'm', 'y']


Встроенная функция list (или функция-конструктор объекта) создает новый список из элементов любой послед-ти.

>>> l[3] = 'x'
>>> l[4] = 'x'
>>> l
['s', 'p', 'a', 'x', 'x', 'y']


И теперь можно преобразовать обратно:

>>> s
'spammy'
>>> s = ''.join(l)
>>> s
'spaxxy'

join - является строк. методом (не списка), вызывается с указанием строки-разделителя (в нашем случае - пустой строки).
Можно использовать произвольную строку-разделитель:

>>> 'SPAM'.join(['aaa', 'bbb', 'ccc'])		# это пример из книги
'aaaSPAMbbbSPAMccc'

- теперь покажу пример , который я сам решил попробовать:

>>> 'SPAM'.join([l])
...
TypeError: sequence item 0: expected str instance, list found
>>> 
>>> l
['s', 'p', 'a', 'x', 'x', 'y']
>>> a = 'SPAM'.join(l)
>>> a
'sSPAMpSPAMaSPAMxSPAMxSPAMy'

- видим, что просто так не получилось со списком, пришлось присвоить значение выражения переменной. Нужно это запомнить и обдумать в дальнейшем!


Строковый тип bytearray (благодаря, что объекты этого типа изменяются непосредственно) представляет отличную альтернативу комбинации функций list/join, особенно когда текст приходится часто менять.  
  	   
	   
Примеры методов строк: разбор текста.

Разбор текста - анализ структуры и извлечение подстрок.

>>> line = 'aaa bbb ccc'
>>> col1 = line[:3]
>>> col3 = line[8:]
>>> col1, col3
('aaa', 'ccc')

Конечно этот прием может использоваться если известны позиции искомых подстрок.


Пример избавления от разделителя подстрок (например, пробел - у нас):

>>> line = 'aaa bbb ccc'
>>> cols = line.split()
>>> cols
['aaa', 'bbb', 'ccc']

- мы не указали разделитель потомоу что по-умолчанию, в качестве строки-разделителя, использ. пробельные символы - символы пробела, табуляция или перевод строки.

>>> line = 'aaa\tbbb\tccc'
>>> cols = line.split()
>>> cols
['aaa', 'bbb', 'ccc']


Еще пример разделителей:

>>> line = 'bob,hacker,40'
>>> cols = line.split(',')
>>> cols
['bob', 'hacker', '40']

>>> line = "I'mSPAMBobhackerSPAM40"
>>> cols = line.split('SPAM')
>>> cols
["I'm", 'Bobhacker', '40']



Другие часто используемые методы строк в действии. стр. 232

Например, есть методы - удаляют символ пробела в конце строки, преобразуют регистр символов, проверяют характер содержимого строки и наличие подстроки вначале или в конце и т.п.:

>>> line = "The khights who say Ni!\n"
>>> line.rstrip()
'The khights who say Ni!'
>>> line.upper()
'THE KHIGHTS WHO SAY NI!\n'
>>> line.isalpha()
False
>>> line.endswith('Ni!\n')
True
>>> line.startswith('The')
True 


А есть и альтернативные пути:

>>> line = "The khights who say Ni!\n"

>>> line.find('Ni') != -1			# Поиск с использованием вызова метода или выражения
True
>>> line.find('Ni')
20
>>> 'Ni' in line
True
>>> sub = 'Ni!\n'
>>> line.endswith(sub)			# Проверка наличия подстроки в конце строки с пом. метода или среза
True
>>> line[-len(sub):] == sub
True


Нужно обратить внимание, что строк. методы не поддерживают - шаблоны. Для обработи текста с использ. шаблонов нужно использ. моджль re. Несмотря на это ограничение, строковые методы иногда бывают эффективнее чем функции модуля re.



Оригинальный модуль string (был удален из Питон 3.0). стр. 233

Ранее, в Питон 2.6

Пусть переменная х ссылается на строк. объект, тогда вызов метода объекта будет таким:

x.method(arguments)

что эквивалентно вызову аналогичной функции из модуля string:

string.method(x, arguments)

Пример:

s = 'a + b + c'
x = s.replace('+', 'spam')
x
'aspambspamc' 

и эта же операция с помощью модуля string:

import string
y = string.replace(s, '+', 'spam')
y
'aspambspamc' 

на этом закончим обзор модуля.



Выражения форматирования строк.

Операции форматирования строк позволяют подставить в строки значения различных типов за одно действие. Их удобно использовать, например, когда требуется отформатироват ьтекст для вывода на экран.

Есть два способа форматирования строк:

- Выражения форматирования строк - этот способ основан на модели функции printf из языка С;

- Метод форматирования строк - более уникальный для Питона, возможности которого в знач. степени пересекаются с возможностями выражений форматирования.


В языке Питон имеется двухместный оператор  %  предназначенный для работы со строками, он обеспечивает простой способ форматирования значений, согласно заданной строке формата.

Оператор % обеспечивает компактную запись кода с множественной подстановкой.

Порядок форматирвоания такой:

1. Слева от оператора % указать строку формата, с одним или более спецификаторов формата, каждый из которых начинается с символа % (пр. %d);

2. Справа от оператора % указать объект (или объекты, в виде кортежа), знач. которого должно быть подставлено на место спецификатора (или спецификаторов) в левой части выражения.


Вспомним пример выше и применим новые знания:

>>> 'That is %d %s bird!' % (1, 'dead')			# выражение форматирования
'That is 1 dead bird!'

>>> 'That is %s %d bird!' % (1, 'dead')			# также видим кортеж справа, т.к. неск-ко знач.	
...
TypeError: %d format: a number is required, not str

>>> 'That is %s %d bird!' % ('dead', 1)
'That is dead 1 bird!'
>>> 'That is %s %s bird!' % ('dead', 1)
'That is dead 1 bird!'


Операции форматирования имеют мощные возможности, рассмотрим еще примеры:

>>> ex = "Ni"
>>> "The knights who say %s!" % ex
'The knights who say Ni!'
>>> 
>>> "%d %s %d you" % (1, 'spam', 4)
'1 spam 4 you'
>>> 
>>> "%s -- %s -- %s" % (42, 3.14159, [1,2,3])
'42 -- 3.14159 -- [1, 2, 3]'


Объекты  любого типа могут быть преобразованы в строку (напр. пр ивыводе на экран это происходит), поэтому для любого объекта может быть указан спецификатор %s.

Также запомните - выражение форматирования создает новую строку.


Табл. 7.4 Спецификаторы формата. стр. 236


Спецификаторы в левой части поддерживают целый набор операций, с сложным синтаксисом. 

Синтаксис использования спецификатора формата:
   
%[(name)][flags][width][.precision]code 

Символ спецификатора формата (code) из табл. 7.4 располагается в самом конце.

Между символом % и символом спецификатора можно добавлять след. информацию: ключ в словаре (name); список флагов (flags), могут определять, например, выравнивание (-), знак числа (+); ширину поля (width) и число знаков после десятичной точки (precision) и мн. др.
width и precision могут принимать значения *, чтобы показать, что их значения должны извлекаться из след. элемента в списке входных значений.

Пример форматирования целого числа с параметрами по умолчанию, а затем целое число выведем в поле шириной 6 символов, выравнивание по левому краю и с дополнением ведущими нулями:

>>> x = 1234
>>> res = "integers: ...%d...%-6d...%06d" % (x, x, x)
>>> res
'integers: ...1234...1234  ...001234'  
 
Спецификаторы e, f, g отображают вещественные числа:

>>> x = 1.23456789
>>> x
1.23456789
>>> '%e | %f | %g' % (x, x, x)
'1.234568e+00 | 1.234568 | 1.23457'


Для вещественных чисел можно доп. указать: выравнивание по левому краю, дополнение вед. нулями, знак числа, ширину поля и число знаков после десятичной точки.

Для простых задач можно использовать функцию str:

>>> '%-6.2f | %05.2f | %+06f' % (x, x, x)
'1.23   | 01.23 | +1.234568'

>>> "%s" % x, str(x)
('1.23456789', '1.23456789')


Если ширина поля и количество знаков после точки не известны, можно указать их при выполнении, а в строке формата использовать символ *, чтобы указать интерпретатору, что эти значения должны извлекаться из очередного элемента в списке входных значений, справа от оператора %.

Пример, число 4 в кортеже определяет кол-во знаков после точки:

>>> '%f, %.2f, %.*f' % (1/3.0, 1/3.0, 4, 1/3.0)
'0.333333, 0.33, 0.3333' 



Форматирование строк из словаря. стр. 238.

В спецификаторах формата можно такжде использовать ключи словаря, который будет указываться в правой части:

>>> "%(n)d %(x)s" % {'n':1, 'x':'spam'}
'1 spam'

Такое извлечение значения по ключу (с спецификаторами) часто используется в программах, создающих код разметки HTML или XML.


Рассмотрим интересный способ, в котором мы отдельн оподготовим строку для форматирования и отдельно блок для форматирования, который указывается справа от оператора % (в данном случае это будет словарь):

>>> reply = """
Greetings...
Hello %(name)s!
Your age squared is %(age)s
"""
>>> values = {'name': 'Bob', 'age': 40}		# Подготовка фактических значений
>>> print(reply % values)					# Подстановка значений

Greetings...
Hello Bob!
Your age squared is 40

>>> 

- Необычный ход, не знал, что так тоже можно. Как видим - способ интересный, что-то уже новое для нас. Можно использовать для поиска и вывода шаблонов, или подстановки, очень удобно.


Встр. функция vars() - возвращает словарь, содержащий все переменные, существующие на момент её вызова:

>>> food = 'spam'
>>> age = 400
>>> vars()
{'__loader__': <class '_frozen_importlib.BuiltinImporter'>, 'food': 'spam', 'reply': '\nGreetings...\nHello %(name)s!\nYour age squared is %(age)s\n', '__doc__': None, 'age': 400, 'values': {'age': 40, 'name': 'Bob'}, '__name__': '__main__', '__package__': None, '__builtins__': <module 'builtins' (built-in)>, '__spec__': None}

- vars() выдает нам, в выводе, словарь с переменными и их значениями; если внимательно поискать можем найти и наши ранние переменные (reply, values) и новые (food, age = 400) и др.


Если задействовать vars() в правой части оператора форматирования, можно отформатировать значения, по именам переменных (т.е. по ключам словаря):

>>> "%(age)d %(food)s" % vars()
'400 spam'



Метод форматирования строк. стр. 239.

В Питон 2.6 и 3.0 появился новый способ форматирования строк, более близкий по духу к Питону. Новый способ, по-прежнему, опирается на некоторые концепции функции printf языка С и имеет более подробный и явный синтаксис.
Оба способа форматирования значительно пересекаются по возможностям и вследствии этого программистам трудно выбрать какой использовать. Вообще - используйте какой понравится по синтаксису.

Основы.

Метод format использует строку, относительно которой он вызывается, как шаблон и принимает произвольное количество аргументов, представляющих значения для подстановки.

Спецификаторы и их параметры окружаются фигурными скобками {}, они могут определять порядковый номер {1} или имена именованных аргументов {food}.
Также аргументы могут передаваться функциям и методам в виде позиционных и именованных аргументов.

>>> templ = '{0}, {1} and {2}'				# используем порядковые номера аргументов
>>> templ.format('spam', 'ham', 'eggs')
'spam, ham and eggs'

>>> templ = '{0}, {2} and {1}'				# меняем местами номера аргументов, всё работает  
>>> templ.format('spam', 'ham', 'eggs')
'spam, eggs and ham'

>>> templ = '{motto}, {pork}, and {food}'	# Имена именованных аргументов
>>> templ.format(motto = 'spam', pork = 'ham', food = 'eggs')
'spam, ham, and eggs'
       
>>> templ = '{motto}, {0}, and {food}'		# комбинация вариантов спецификаторов
>>> templ.format('ham', motto = 'spam', food = 'eggs')
'spam, ham, and eggs'

>>> '{motto}, {0}, and {food}'.format('ham', motto = 'spam', food = 'eggs')
'spam, ham, and eggs'

- метод можно вызывать прямо к объекту, не обязательно сначала строку присваивать переменной.


>>> '{motto}, {0}, and {food}'.format(42, motto = 3.14, food = [1, 2])
'3.14, 42, and [1, 2]'

- format также предоставляет возможность подстановки значений объектов любых типов.


Метод format создает и возвращает новый объект строки, и его можно использовать в дальнейшем: 

>>> x = '{motto}, {0}, and {food}'.format(42, motto = 3.14, food = [1, 2])
>>> x
'3.14, 42, and [1, 2]'

>>> x.split(' and ')		# мы получили два элемента списка '3.14, 42,' и '[1, 2]'
['3.14, 42,', '[1, 2]']

>>> y = x.replace('and', 'but no milk')		# замена подстроки
>>> y
'3.14, 42, but no milk [1, 2]'



Использование ключей, атрибутов и смещений.

При использовании format (как и %), в строках формата можно ссылаться на имена атрибутов объекта и ключи словарей, [] - означает ключи словаря, а точка . - прим-ся для доступа к атрибутам объектов, на которые ссылаются спецификаторы.

Примеры: 
первый - подстановка ключа 'spam' словаря и атрибута значение 'platform' объекта модуля sys (позиционные аргументы);  
второй - то же самое, но объекты для подстановки передаются в виде именованных аргументов.

>>> 'My {1[spam]} runs {0.platform}'.format(sys, {'spam': 'laptop'})
'My laptop runs win32'


В скобках [] в строках формата можно также указывать смещение от начала списка (или любой последовательности), но тольк оположительное смещение.
Чтобы обратиться по отриц. смещению, получить срез или вставить результат произвольного выражения, данные нужно подготовить отдельно, за пределами строки формата:

>>> somelist = list('SPAM')
>>> somelist
['S', 'P', 'A', 'M']

>>> 'first = {0[0]}, third = {0[2]}'.format(somelist)
'first = S, third = A'

>>> 'first = {0[0]}, third = {0[-1]}'.format(somelist)
...
TypeError: list indices must be integers, not str

- как видим, если [-1] использовать внутри строки формата, это приведет к ошибке!

>>> 'first = {0}, last = {1}'.format(somelist[0], somelist[-1])
'first = S, last = M'

>>> parts = somelist[0], somelist[-1], somelist[1:3]
>>> 'first = {0}, last = {1}, middle = {2}'.format(*parts)
"first = S, last = M, middle = ['P', 'A']"

- также, если использовать [1:3] внутри строки формата, это приведет к ошибке! 


- еще одно замечание, в последнем примере, в части .format(*parts), символ * обязателен, без него возникает ошибка:

>>> parts = somelist[0], somelist[-1], somelist[1:3]
>>> 'first = {0}, last = {1}, middle = {2}'.format(parts)
...
IndexError: tuple index out of range



Специальные приемы форматирования. 

Метод format имеет возможности более точного форматирования, вслед за идентификатором символа подстановки, через двоеточие, можно указать спецификатор формата, поределяющий ширину поля вывода, выравнивание и код типа значения.

Синтаксис спецификатора формата:

{fieldname! conversionflag:formatspec}

Поля спецификатора:

- fieldname - порядковый номер или имя именованного аргумента, за которым может следовать необязательное имя ".name" атрибута или индекс "[index]" элементов.
- conversionflag - может быть r, s или a, которые определяют применение к значению встреонной функции repr, str или ascii соответственно.
- formatspec - определяет способ представления значения, описывает такие характеристики представления, как ширина поля вывода, выравнивание, дополнение, количество знаков после десятичной точки и т.д., и завершается необязательным кодом типа значения.

Поле formatspec, следующее за двоеточием, имеет синтаксис (квадратные скобки указывают необязательные поля):

[[fill]align][sign][#][0][width][.precision][typecode]

- в поле align может указываться символ <, >, = или ~, обозначающие выравнивание по левому/правому краю, дополнение знака числа или выравнивание по центру.

Также formatspec может содержать вложенные {} строки форматирования с именами полей, чтобы извлекать значения динамически.


Дополнительно метод format позволяет использовать код 'b' для отображения целых чисел в двоичном формате, код % означает символ процента, а для десятичных целых чисел используется код 'd'.


Пример. 
Спецификатор {0:10} предписывает вывести значение первого позиционного аргумента в поле шириной 10 символов, {1:<10} предписывает вывести значение второго позиционного аргумента в поле шириной 10 символов, с выравниванием по левому краю, а спецификатор {0.platform:>10} предписывает вывести значение атрибута platform первого позиционного аргумента в поле шириной 10 символов, с выравниванием по правому краю:

>>> '{0:10} = {1:10}'.format('spam', 123.4567)
'spam       =   123.4567'
>>> '{0:>10} = {1:<10}'.format('spam', 123.4567)
'      spam = 123.4567  '
>>> '{0.platform:>10} = {1[item]:<10}'.format(sys, dict(item = 'laptop'))
'     win32 = laptop    '


format с вещественными числами:

>>> '{0:e}, {1:.3e}, {2:g}'.format(3.14159, 3.14159, 3.14159)
'3.141590e+00, 3.142e+00, 3.14159'

>>> '{0:f}, {1:.2f}, {2:06.2f}'.format(3.14159, 3.14159, 3.14159)
'3.141590, 3.14, 003.14'
   
{2:g} предписывает вывести третий аргумент, отформатированный в соответствии с представленным вещественных чисел по умолчанию, предусмотренным кодо 'g'.
{1:.2f} предписывает использовать формат 'f' представления вещественных чисел с двумя знаками после десятичной точки.
{2:06.2f} ограничивает ширину поля вывода 6 символами и предписывает дополнить число нулями слева.


Вывод чисел в восьмеричном, шестнадцатеричном и двоичном форматах:

>>> '{0:X}, {1:o}, {2:b}'.format(255, 255, 255)
'FF, 377, 11111111'

- и сравним с алтернативными методами:
 
>>> bin(255), int('11111111', 2), 0b11111111
('0b11111111', 255, 255)
>>> hex(255), int('FF', 16), 0xFF
('0xff', 255, 255)
>>> oct(255), int('377', 8), 0o377
('0o377', 255, 255) 
 
    
Параметры форматирования можно указывать непосредственно в стркое форматирования:

>>> '{0:.2f}'.format(1/3.0)
'0.33'
>>> '%.2f' % (1/3.0)
'0.33'

- или динамически извлекать из списка аргументов:

>>> '{0:.{1}f}'.format(1/3.0, 4)
'0.3333'
>>> '%.*f' % (4, 1/3.0)
'0.3333'


В Питон 2.6 и 3.0 появилась встроенная функция format, которая может использоваться для форматирования одиночных значений. С тех. точки зрения, функция format вызывает метод format__ объекта, который в свою очередь вызывает метод str.format каждого форматируемого элемента.



Сравнение с оператором форматирования % стр. 243

В общем случае, применение оператора форматирования выглядит проще, чем вызов метода format:

>>> print(' %s = %s ' % ('spam', 42))
 spam = 42 
 
>>> print(' {0} = {1} '.format('spam', 42))
 spam = 42  


В более сложных случаях, оба способа имеют почти одинаковую сложность.
 
Не будем здесь приводить подробные различия, в случае необходимости почитаем их потом, или дополним.



Общие категории типов.

Сделаем паузу после исследования строк. Рассмотрим некоторые общие концепции большинства типов, которые будем рассматривать далее.

Типы одной категории имеют общий набор операций.

Формально в Питоне существуют три категории типов (и, соответственно, операций):

- Числа (целые, вещественные, с фиксированной точностью, рациональные и др.);
- Последовательности (строки, списки, кортежи);
- Отображения (словари).

Множества - образуют отдельную категорию типов (не отображают ключи в значения, не являются упорядоченными последовательностями).


Т.е., например, для любых объектов последовательностей X и Y справедливо следующее:

X + Y  создает новый объект последовательности, включающий содержимое обоих операндов; 

X * N  создает новый объект последовательности, включающий N копий операнда X.


- и так для всех остальных категорий типов и операций, т.е. операции последовательностей одинаково действуют на любые виды последовательностей и это же правило сохраняется для категории чисел и отображений.



Изменяемые типы допускают непосредственное изменение.

Неизменяемые (числа, строки, кортежи, фиксированные множества): 
- объекты неизменяемых типов не поддерживают непосредственное изменение значения объекта, однако можно создават ьновые объекты с помощью выражений и присваивать их требуемым переменным.

Изменяемые (списки, словари, множества):
- изменяемые типы наоборот, всегда могут изменяться непосредственно, с помощью операций, которые не создают новые объекты. Изменяемые объекты могут быть скопированы, но поддерживают и возможности непосредственного изменения.




Глава 8. Списки и словари. стр. 253

Оба типа объектов изменяемые и являются коллекциями других объектов.


Списки. стр. 253

Список - гибкий тип упорядоченных коллекций. Могут содержать объекты любых типов: числа, строки и даже другие списки.

Ну и, естественно, списки могут изменяться непосредственно, они - изменяемые объекты.

Основные свойства списков. Списки это:

- Упорядоченные коллекции объектов произвольных типов. Т.о. списки это лишь место, в котором собраны др. объекты, поэтому их можно рассматривать как группы. Имеется позиционное упорядочивание элементов слева направо (как у последовательностей);

- Доступ к элементам по смещению. Есть операции извлечения элемента по индексу смещения, срезы, конкатенация;

- Переменная длина, гетерогенность и произвольное число уровней вложенности. Списки могут содержать не только односимвольные строки, но и любые др. объекты (гетерогенность). Могут изменять длину (непосредственное изменение). Имеют возможность создания произвольного числа уровней вложенности.

- Относятся к категории изменяемых объектов. Могут изменяться непосредственно и поддерживают все операции над последоватльностями (как и у строк). Естественно после операций (конкатенация и срез) над списком возвращается новый список, а не строки. Естественно списки поддерживают операции, неподдерживаемые строками (непосредственное изменение элементов, удаление, по длине и т.п.).   

- Массивы ссылок на объекты. Формально списки могут содержать ноль или более сылок на объекты. Они чем-то напоминают массивы указателей (адресов). Списки - это самые настоящие массивы языка С, реализованные в интерпретаторе Питон, а не связанные структурой данных. 
И запомним, всякий раз, когда выполняется присваивание объекта элементу какой-либо структуры или имени переменной, интерпретатор Питона сохраняет ссылку на этот объект, а не его копию (кроме случаев явного запроса операции копирования.)   
 

Табл. 8.1 Литералы списков и операции. стр. 255


Литералы:

L = []							# Пустой список	

L = [0, 1, 2, 3]				# Четыре элемента

L = ['abc', ['def', 'ghi']]		# Вложенные списки



Списки в действии. стр. 256

Базовые операции над списками.

>>> len([1, 2, 3])				# Длина
3
>>> [1, 2, 3] + [4, 5, 6]		# Конкатенация
[1, 2, 3, 4, 5, 6]
>>> ['Ni!'] * 4					# Повторение
['Ni!', 'Ni!', 'Ni!', 'Ni!']


Также понимаем, что  прис операции сложения, справа и слева должны быть последовательности одного типа, нельзя конкатенировать списки и строки, нужно их преобразовывать:

>>> str([1, 2]) + "34"		# то же, что и "[1, 2]" + "34"
'[1, 2]34'

>>> [1, 2] + list("34")		# то же, что и [1, 2] + ["3", "4"]
[1, 2, '3', '4']



Итерации по спискам и генераторы списков.

>>> 3 in [1, 2, 3]			# Проверка на вхождение
True
>>> for x in [1, 2, 3]:
	print(x, end=' ')		# Итерации
	
1 2 3 

- цикл for выбирает элементы последовательности в порядке слева направо и выполняет одну или более инструкций для каждого.


>>> res = [c * 4 for c in 'SPAM']			# Генератор списков
>>> res
['SSSS', 'PPPP', 'AAAA', 'MMMM'] 


Эквивалент генератора списков, цикл for:

>>> res = []
>>> for c in 'SPAM':
	res.append(c * 4)
	
>>> res
['SSSS', 'PPPP', 'AAAA', 'MMMM']



Функция map действуе тпохоже, но применяет к элементам последовательности не выражение, а функцию и создает новый список:

>>> list(map(abs, [-1, -2, 0, 1, 2]))		# вероятно abs это - абсолютное значение
[1, 2, 0, 1, 2]

list



Индексы, срезы и матрицы. стр. 258

>>> L = ['spam', 'Spam', 'SPAM!']
>>> L[2]							# Отчет смещений начинается с нуля
'SPAM!'
>>> L[-2]							# Отрицательное смещение
'Spam'
>>> L[1:]							# Операция среза возвращает список
['Spam', 'SPAM!']


Рассмотрим простейшую матрицу:

>>> matrix = [[1, 2, 3],[4, 5, 6],[7 , 8 , 9]]		# лишние пробелы в [7 , 8 , 9] 
													  не влияют на правильную работу 
>>> matrix
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

>>> matrix[1]
[4, 5, 6]
>>> matrix[1][1]
5
>>> matrix[2][0]
7

>>> mat = [[1, 2, 3],				# есть и такой способ записи матрицы, неск-ко строк
       [4, 5, 6],
       [7, 8, 9]]
>>> mat
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> mat[1][1]
5



Изменение списка. стр. 259

Присваивание по индексам и срезам.

>>> s = ['spam', 'Spam', 'SPAM!']
>>> s[1] = 'eggs'
>>> s
['spam', 'eggs', 'SPAM!']
>>> 
>>> s[0:2] = ['eat', 'more']
>>> s
['eat', 'more', 'SPAM!']

- происходит непосредственное изменение списка.

Прсиваивание работает как в С, интерпретатор замещает старую ссылку на объект в указанном смещении на новую.

Присваивание срезу, выполняется за два действия:

- Удаление. Раздел списка, определяемый слева от оператора =, удаляется.

- Вставка. Новые элементы, справа от оператора =, вставляются в список, начиная с левого края, где находился прежний, удаленный срез.

При этом мы видим, что число удаляемых элементов не обязательно должно быть равно количеству вставляемых элементов (можно удалить больше чем вставить и наоборот, вставить больше чем удалить).


Обычно используются более простые способы замены, вставки, и удаления (напр. конкатенация, методы insert, pop, remove).



Методы списков.

>>> s
['eat', 'more', 'SPAM!']

>>> s.append('please')				# метод добавляет элемент в конец списка
>>> s
['eat', 'more', 'SPAM!', 'please']

>>> s.sort()						# Сортировка элементов списка ('S' < 's')
>>> s
['SPAM!', 'eat', 'more', 'please']


Методы - это функции (в действительности - атрибуты, ссылающиеся на функции), которые связаны с определенным типом объектов.


Метод append один из самых популярных методов, добавляет элемент (ссылку на объект) в конец списка.

append принимает только один аргумент (т.е. один объект, а не список).


Метод sort - сортирует, упорядочивает элементы. Можно изменять порядок сортировки с помощью именованных аргументов - специальных синтаксических конструкций вида "name=value", которые используются в вызовах функций для передачи параметров настройки по их именам.

Пример - аргумент key метода sort, а также reverse:

>>> d = ['abc', 'ABD', 'abe']		# Сортировка с учетом регистра символов
>>> d.sort()
>>> d
['ABD', 'abc', 'abe']
>>> 
>>> d = ['abc', 'ABD', 'abe']		
>>> d.sort(key=str.lower)			# Приведение символов к нижнему регистру
>>> d
['abc', 'ABD', 'abe']				# сами элементы не изменилсь после действия аргумента key	
>>> 
>>> d = ['abc', 'ABD', 'abe']		
>>> d.sort(key=str.lower, reverse=True)		# Изменяет направление сортировки
>>> d
['abe', 'ABD', 'abc'] 						# сами элементы не изменились после 
                                              действия аргументов	


Замечание! В Питоне 3.х нельзя сортировать	список с различными типами объектов:										  
>>> t = [3, 2, 1, 'sss']
>>> t.sort()
...
TypeError: unorderable types: str() < int()											  


Отметим, append и sort изменяют сам объект списка (а возвращают None). Т.е. при использовании этих методов нет необходимости в присвоении результата.


Также в последних версиях Питона сортировку можно выполнить с помощью встроенной функции, при этом взвращая новый список, не изменяя старыый:


>>> d = ['abc', 'ABD', 'abe']
>>> sorted(d, key=str.lower, reverse=True)		# встроенная функция сортировки
['abe', 'ABD', 'abc']

>>> d
['abc', 'ABD', 'abe']

>>> d = ['abc', 'ABD', 'abe']
>>> sorted([x.lower() for x in d], reverse=True)		# Элементы, предварительно изменяются
['abe', 'abd', 'abc']

>>> d
['abc', 'ABD', 'abe']
  
- во втором примере выполняется сортировка не оригинального, а уже измененного (временного) списка, получившегося с помощью генератора списков.


Иногда функция sorted, может оказаться удобнее метода sort.


reverse - изменяет порядок элементов на обратный

extend и pop - вставляют несколько элементов в конец списка и удаляют элементы из конца списка соответственно.

reversed - во многом напоминает функцию sorted, но её необходимо обертывать в вызов функции list, потому что она возвращает итератор:

>>> l = [1, 2]
>>> l.extend([3, 4, 5])		# Добавляет элементы в конец списка 
>>> l						  в отличие от append, где добавляется только один объект	
[1, 2, 3, 4, 5]
>>> l.pop()					# Удаляет и возвращает последний элемент
5
>>> l
[1, 2, 3, 4]
>>> l.reverse()
>>> l
[4, 3, 2, 1]
>>> list(reversed(l))
[1, 2, 3, 4]
  

В некоторых программах pop и append реализуют структуру данных типа стек - "последний пришел, первый вышел" (Last-In-First-Out, LIFO). Конец списка - вершина стека:

>>> l = []
>>> l.append(1)			# Втолкнуть в стек
>>> l.append(2)
>>> l
[1, 2]
>>> l.pop()				# Вытолкнуть из стека
2
>>> l
[1]    
 

pop - может принимать необязательное смещение эелемента, который удаляется из списка и возвращается (по умолчанию - это последний элемент)

remove - позволяет удалять элементы с определенными значениями

insert - позволяет вставлять элементы в определенную позицию

index - позволяет отыскивать смещение элемента по заданноу значению

>>> l = ['spam', 'eggs', 'ham']
>>> l.index('eggs')					# Узнаем индекс объекта
1
>>> l.insert(1, 'toast')			# Вставка в требуемую позицию
>>> l
['spam', 'toast', 'eggs', 'ham']
>>> l.remove('eggs')				# Удаление элемента с определенным значением
>>> l
['spam', 'toast', 'ham']
>>> l.pop(1)						# Удаление элемента в указанной позиции
'toast'
>>> l
['spam', 'ham']

>>> l = ['spam', 'eggs', 'ham', 'toast']
>>> l
['spam', 'eggs', 'ham', 'toast']
>>> l.pop(-3)						# Причем можно указать и отрицательное смещение
'eggs'
>>> l
['spam', 'ham', 'toast']

- Кстати! Наконец-то понятно, что такое метод, который что-то возвращает (как - pop, к примеру) и метод, который не возвращает (т.е. просто что-то делает, ну как - remove, например).
Очень полезное знание!


Прочие часто используемые операции над списками.

Инструкция del для удаления элемента или среза:

>>> l = ['SPAM', 'eggs', 'ham', 'toast']

>>> del l[0]							# Удаление одного элемента из списка
>>> l
['eggs', 'ham', 'toast']
>>> del l[1:]							# Удаление среза
>>> l									# То же, что и l[1:] = [] 	
['eggs']

В последнем примере нужно оговориться, что операция присваивания пустого списка по индексу элемента приводит к сохранению ссылки на пустой список в этом элементе, а не к его удалению:

>>> l = ['eggs', 'ham', 'toast']
>>> l[1:] = []
>>> l
['eggs']

>>> l[0] = []
>>> l
[[]]				# Вот и подтверждение пустого списка вместо удаления элемента
>>> del l[0]
>>> l
[]


>>> l = ['SPAM', 'eggs', 'ham', 'toast']
>>> del(l[0])
>>> l
['eggs', 'ham', 'toast']
>>> del l[0]
>>> l
['ham', 'toast'] 
  
- Замечание! Как видим из этого примера - del, в моем интерпретаторe IDLE, одинаково работает как без скобок так и со скобками, или у меня глюк или это особенности работы инструкций в Питоне (не даром сказано ни метод, ни функция, а именно инструкция) - еще одна особенность, нужно бы запомнить и изучить. 
  


Словари. стр. 264

После списков словари являются, пожалуй, самым гибким из встроенных типов данных в Питон.

В отличие от списков, словари не являются упорядоченными коллекциями, в них элементы извлекаются по ключу, а не по смещению.

Основные характеристики словарей:

- Доступ к элементам по ключу, а не по индексу. Иногда словари называют ассоциативными массивами, или хешами. Для получения элементов применяется не смещение, а ключ, играя т.о. роль индекса элемента.

- Неупорядоченные коллекции произвольных объектов. Элементы словарей хранятся в произвольном порядке, это было сделано для более быстрого поиска. Ключи описывают символическое (не физическое) местоположение элементов в словаре.

- Переменная длина, гетерогенность и произвольное число уровней вложенности. Словари могут увеличиваться и уменьшаться (непосредственно, без создания копий). Могут содержать объекты любых типов и поддерживают произвольное число уровней вложенности. 

- Относятся к категории "изменяемых отображений". Словари явл-ся изменяемыми объектами, но не поддерживают операции над последовательностями как строки и списки. Словари - это неупорядоченные коллекции. Словари - единственный встроенный представитель объектов-отображений (объекты, которые отображают ключи на значения).

- Таблицы ссылок на объекты (хеш-таблицы). Если списки - это массивы ссылок на объекты, с возможностью доступа к элементам по их позиции, то словари - это неупорядоченные таблицы ссылок на объекты, которые поддерживают доступ к элементам по ключу. Внутри словари реализованы как хеш-таблицы (структуры данных, которые обеспечивают очень высокую скорость поиска). Интерпретатор Питон использует оптимизированные алгоритмы хеширования для обеспечения максимально высокой скорости поиска ключей. Словари хранят ссылки на объекты (а не их копии).


Таблица 8.2 Литералы словарей и операции. стр. 266

d = {}									# Пустой словарь

d = {'spam' : 2, "eggs" : 3}			# Словарь из двух элементов

d = {'spam' : {'ham' : 1, 'eggs' : 2}	# Вложение



Словари в действии. стр. 267

Базовые операции над словарями.

>>> d = {'spam':2, 'ham':1, 'eggs':3}		# Создание словаря
>>> d
{'spam': 2, 'eggs': 3, 'ham': 1}			# Вот оно - случайный порядок следования

>>> d['spam']								# Извлечение значения по ключу
2


функция len - возвращает число элементов в словаре, или, то же самое, длину ключей;

оператор in - позволяет проверить наличие ключа, и только ключа! попытка проверки наличия определенного  элемента выдает - false, видимо разработчики Питона решили, что и так сойдет, находите ключ, а потом по нему смотрите значение.

метод keys - возвращает все ключи, имеющиеся в словаре, в виде списка;

>>> d = {'spam':2, 'ham':1, 'eggs':3}
>>> len(d)								# Число элементов словаря
3

>>> 'ham' in d							# Начинаем испытание проверки на вхождение
True
>>> 3 in d
False
>>> '3' in d
False
>>> d = {'spam':'pam', 'ham':'tam', 'eggs':'dam'}
>>> 'spam' in d
True
>>> 'pam' in d
False
>>> 
>>> d = {'spam':2, 'ham':1, 'eggs':3}
>>> list(d.keys())
['spam', 'eggs', 'ham']					# Создает новый список ключей
>>> 

- конечно метод keys пришлось обернуть в функцию list, т.к. keys возвращает итератор, а не список.
А вызов функции list принудительно выполняет обход всех значений итератора.



Изменение словарей.

В примерах ниже ознакомимся с операциями изменения словарей, кстати в Питоне все типы-коллекции могут вкладываться друг в друга в произвольном порядке.

>>> d = {'eggs':3, 'ham':1, 'spam':2}
>>> d
{'ham': 1, 'eggs': 3, 'spam': 2}
>>> 
>>> d['ham'] = ['grill', 'bake', 'fry']			# Изменение элемента
>>> d
{'ham': ['grill', 'bake', 'fry'], 'eggs': 3, 'spam': 2}		# Вложение получилось
>>> 
>>> del d['eggs']								# Удаление элемента
>>> d
{'ham': ['grill', 'bake', 'fry'], 'spam': 2}
>>> 
>>> d['brumch'] = 'Bacon'						# Добавление нового элемента
>>> d
{'ham': ['grill', 'bake', 'fry'], 'brumch': 'Bacon', 'spam': 2}


Операция присваивания по существующему ключу словаря приводит к замене предыдущего значения, ассоциируемого с этим ключом.
В отличие от списков, словари допускают присваивание по новому ключу (которого не было в словаре), в этом случае просто создается новый элемент словаря (пример с ключом 'brumch').



Дополнительные методы словарей.

метод values - возвращает список значений элементов словаря:

>>> d = {'spam':2, 'ham':1, 'eggs':3}
>>> list(d.values())
[1, 3, 2]


метод items - возвращает кортежи пар (key, value), вернее даже список кортежей пар:

>>> d = {'spam':2, 'ham':1, 'eggs':3}
>>> list(d.items())
[('ham', 1), ('eggs', 3), ('spam', 2)]


При попытке вызвать несуществующий элемент словаря мы получим ошибку, но метод get позволяет вернуть значение по умолчанию или None:

>>> d.get('spam')
2
>>> print(d.get('toast'))
None
>>> d.get('toast', 88)
88


Метод update - своего рода метод конкатенации словарей, он объединяет ключи и значения одного словаря с ключами и значениями другого, просто перезаписывая значения с одинаковыми ключами:

>>> d
{'ham': 1, 'eggs': 3, 'spam': 2}
>>> d2 = {'toast':4, 'muffin':5}
>>> d.update(d2)
>>> d
{'ham': 1, 'toast': 4, 'muffin': 5, 'eggs': 3, 'spam': 2}


>>> d = {'spam':2, 'ham':1, 'eggs':3}			# А теперь посмотрим на перезапись элементов 
>>> d2 = {'toast':4, 'spam':5}					# Пусть в d2 будет тоже ключ 'spam' как и в d
>>> d.update(d2)
>>> d											# update d по d2	
{'ham': 1, 'toast': 4, 'eggs': 3, 'spam': 5}
>>> d2
{'spam': 5, 'toast': 4}

>>> d = {'spam':2, 'ham':1, 'eggs':3}
>>> d2 = {'toast':4, 'spam':5}
>>> d2.update(d)								# update d2 по d
>>> d
{'ham': 1, 'eggs': 3, 'spam': 2}
>>> d2
{'ham': 1, 'spam': 2, 'eggs': 3, 'toast': 4} 

- как видим разница очевидна, порядок конкатенации имеет значение. 


Метод pop удаляет ключ из словаря и возвращает его значение

>>> d
{'ham': 1, 'toast': 4, 'muffin': 5, 'eggs': 3, 'spam': 2}
>>> d.pop('muffin')
5
>>> d.pop('toast')					# Удаляет ключ и возвращает значение заданного ключом элемента
4									# или проще - значение заданного ключа (пары ключ:значение)
									# возвращает не индекс! а значение!!! не путать!		
>>> d
{'ham': 1, 'eggs': 3, 'spam': 2}


Сравним метод pop с работой ег осо списками, где он также удаляет элементы и возвращает их значения, используя при этом номер позиции, а не ключ как pop для словарей:

>>> L = ['aa', 'bb', 'cc', 'dd']
>>> L.pop()
'dd'
>>> L
['aa', 'bb', 'cc']
>>> L.pop(1)
'bb'
>>> L
['aa', 'cc']

Имеется также метод copy, который будет рассмотрен позднее в этой книге.



Таблица языков.

Рассмотрим применение словаря на примере таблицы языков программирования и их создателей:

>>> table = {'Python':'Guido Van Rossum',
	 'Perl':'Larry Wall',
	 'Tcl':'John Ousterhout'}
>>> language = 'Python'
>>> cerator = table[language]
>>> cerator
'Guido Van Rossum'
>>> 
>>> for lang in table:				# То же, что и  -  for lang in table.keys()
	print(lang, '\t', table[lang])
	
Tcl 	 John Ousterhout
Python 	 Guido Van Rossum
Perl 	 Larry Wall


>>> for a in table:					# Просто проверяю lang  ключевое слово или можно любое
	print(a, '\t', table[a])
	
Tcl 	 John Ousterhout
Python 	 Guido Van Rossum
Perl 	 Larry Wall


- приведенная команда с циклом for просто выполняет обход всех ключей в таблице и выводит список ключей и их значений, разделенных символом табуляции.


Словари не являются последовательностями, как списки и строки, но если необходимо выполнить обход элементов словаря, нет ничего сложного - это легко сделать методом keys, возвращающим все ключи словаря, которые можно обойти в цикле for, а внутри цикла можно получить значения ключей, как было сделано у нас в примере выше.

Для любого словаря D цикл можно оформить как for key in D, что равносильно полной форме записи - for key in D.keys(), пример:  

>>> for a in table.keys():
	print(a, '\t', table[a])
	
Tcl 	 John Ousterhout
Python 	 Guido Van Rossum
Perl 	 Larry Wall



Замечания по использованию словарей. стр. 271.

























 




ми
 
