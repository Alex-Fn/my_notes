
Часть 4. Модули.  стр. 605


Глава 21. Модули: общая картина.  стр. 607

Модули - самая крупная организационная программная единица, которая вмещает код и данные, готовые для многократного использования.

Модули обычно соотв-ют файлам программ (или расширениям др. ЯП как С, Java, C#). 

Каждый файл - это отдельный модуль, конечно модули могут испортировать др. модули.

Моудли обрабатываются двумя инструкциями и одной функцией:

- import - Позволяет клиентам (импортерам) получать модуль целиком.

- from - Позволяет клиентам получать определенные имена из модуля.

- imp.reload - Обеспечивает возможность повторной загрузки модуля без остановки интерпретатора.


Зачем нужны модули?

Модули обеспечивают простой способ организации компонентов в систему автономных пакетов переменных, известных как пространства имен.
Все имена, определяемые на верх. уровне модуля, становятся атрибутами объекта импортируемого модуля.

В процессе импорта глоабл. область модуля образует пространство имен атрибутов объекта модуля.

Модули позволяют связывать отдельные файлы в крупные программные системы.

По теории, модули играют как минимум три роли:

- Повторное использование программного кода. Т.к. модули хранят код в виде файлов то код, т.о., хранится постоянно, т.е. его можно загружать и запускать сколько угодно раз. Так модули становятся местом, где определяются имена, известные как - атрибуты, на которые могут ссылаться внешние клиенты.

- Разделение системы пространства имен. По сути, модули - всего лишь пакеты имен. Т.о. появл-ся изоляция - мы никогда не узнаем имя в др. модуле пока не импортируем его. Выполняемый код и создаваемые объекты модуля - всегда неявно включается в модули.

- Реализация служб или данных для совместного использования. С функциональной точки зрения, модули могут использ-ся для реализации компонентов, используемых системой, вследствии чего требуется только одна копия такого компонента. Нарп. если нужен глобал. объект, использующийся более одной ф-цией или модулем, можно написать его в виде модуля, который будет импортироваться многими клиентами.


Архитектура программы на языке Питон.

Обычно программы состоят более чем из одного файла, даже если ваш файл всего один наверняка вы используете какие-то модули.

Изучим введение в архитектура программ - способ, которым программа делится на коллекцию файлов с исходными текстами (т.е. модулей) и увязывается в единое целое.


Как организована программа.

Как правило программа состоит из множества текстовых файлов, содержащих инструкции. Программа организована как один главный файл, к которому могут подключаться доп. файлы, известные как модули.

Главный файл (или сценарий) определяет, как будет двигаться основной поток выполнения программы, - это тот файл, который нужно запустить, чтобы начать работу приложения.

Файлы модулей - библиотеки инструментов, где содержатся компоненты, используемые главным файлом (и может где-то еще). Глав. файл использ-т инструменты, определенне в файлах модулей, а модули использ. инструменты, из др. модулей.

Обычно файлы модулей ничего не делают сами по себе, - в них определяются инструментальные средства, используемые в др. файлах. Чтобы получить доступ к инструментам модуля, наз-ся атрибутами модуля, необходимо импортировать модуль.


Импортирование и атрибуты.

Рисунок 21.1 Структура программ на Питон.  стр. 610

Три файла: a.py, b.py, c.py. Файл a.py явл-ся глав. файлом программы, в нем инструкции. Файлы b.py, c.py - модули, также простые текстовые файлы с инструкциями, но как самостоятельные программы они обычно не запускаются.

Пусть b.py определяет ф-цию spam:

def spam(text):
	print(text, 'spam')
	
Предположим, что модуль a.py использ-т spam, описание его такое:

import b
b.spam('gumby')

- получаем доступ ко всему, что определено на верхнем уровне b.py (т.е. ко всем атрибутам).

Импорт нужен чтобы связать имена в модуле - простые переменные - с объектами загруженных модулей.

Фактически, имя модуля в инструкции import, идентифицирует внешний файл, и становится именем переменной, которая будет представлять загруженный модуль.

b.spam - вызывает ф-цию, поределенную в b.py ("извлечь значение имени psam, расположенного в b").

Мы увидим, что повсюду в Питон использ-ся нотация object.attribute (здесь точка "." - это оператор).

Любой файл может импортировать функциональные возможности из другого файла. 


Модули стандартной библиотеки.

Интерпретатор Питон поставл-ся с обширной коллекцией доп. модулей, которая известна как стандартная библиотека. Она насчитывает окооло 200 модулей (это из книги цифра) и платформонезависимую поддержку разных задач: интерфейсы ОС, организацию хранилищ объектов, поиск по шаблону, сетевые взаимодействия, создания графич. интерфейса и др.

Они могут использ-ся при импортировании необходимого модуля.


Как работает импорт.

Программисты на С любят сравниват ьинструкцию import в Питон с инструкцией #include, но они в корне
неправы - импортирование в Питон - это не просто включение текста одного файла в другой.

Это самые настоящие операции времени выполнения, которые вып-т след. действия, когда программа импортирует файл:

1. Отыскивают файл модуля.
2. Компилируют в байт-код (если нужно).
3. Запускают программный код модуля, чтобы создать объекты, которые он определяет.

Внимание. Все три действия вып-ся только если модуль импортируется впервые во время выполнения программы - последующие операции импорта этого же модуля пропускают эти действия и просто выбирают,Ю уже находящийся в памяти объект модуля.

Интерпретатор сохраняет информацию о загруженных модулях в словаре с именем sys.modules и проверяет его при каждой операции импортирования. Если модуль отсутствует, то выполняется процесс, описанный выше.  


1. Поиск.

На этом этапе интерпретатор определяет местонахождение файла модуля. 

Заметим, что имена модулей в инструкции import указываются без расширения .py и без пути к каталогу, эти ограничения выполняются потому что интерпретатор использует стнадартный путь поиска модулей.

2. Компиляция (если необходимо).

Когда файл найден интерпретатор компилирует его в байт-код, если нужно.

Интерпретатор проверяет время создания файла и пропускает компиляцию, если файл с байт-кодом .pyc не старше, чем соответствующий ему файл .py с исходным текстом.

Если Питон находит только файл с байт-кодом и не найдет файл с исходным текстом, то он просто загрузит байт-код. Это даже ускорит запуск программы.

Обратите внимание, компиляция выполняется в момент импортирования файла. По этой причине файл .pyc с байт-кодом для глав. файла программы обычно не создается, если тольк оон не был импортирован куда-то еще (файл .pyc создаются при импортировании). Байт-код файла программы создается в памяти ПК, а импортированных файлов сохр-ся в файлах для ускорения будущих импортов.

Также можно создавать глав. файлы, которые будут играть роль и главного файла и импортируемого модуля, но об этом потом.

3. Запуск.  

На последнем шаге идет запуск байт-кода модуля. все инструкции в файле модуля выполняются по порядку, сверху вниз, и любые операции присваивания, которые встретятся на этом шаге, будут создавать атрибуты конечного объекта модуля. Т.о. этот этап создает все инструменты, которые опред-ся модулем (напр. выполняются инструкции def, создающие ф-ции и мн. др.).

Т.о. фактически запускается программный код модуля, и если код выполняет какие-то действия, то мы сможем их наблюдать во время импорта (напр. действия инструкции print).


Путь поиска модулей.

Нам может потребоваться сообщить интерпретатору, где искать импортируемые файлы, поэтмоу нужн ознать как получить доступ к пути поиска.

Имеются следующие источники поиска:

1. Домашний каталог программы (в моей Убунте это - домашняя папка моего пользователя).
2. Содержимое переменной окружения PYTHONPATH (если таковая определена).
3. Каталоги стандартной библиотеки.
4. Содержимое любых файлов с расширением .pht (если таковые имеются).

Объединение этих компонентов составляет sys.path - список строк с именами каталогов, о нем поговорим позднее.

Первый и третий пути определяются автоматически, а второй и четвертый можно использовать для расширения пути поиска.

Домашний каталог. 

В первую очередь интерпретатор ищем в домашнем каталоге. В зависимости от того как была запущена программа, это может быть каталог, где нах-ся глав. файл программы. У меня в Убунте модули приходится сохранять в домашней папке пользователя, а в Виндовс - в папке Питона.

Каталоги в PYTHONPATH.

Затем произв-ся поиск в каталогах окружения PYTHONPATH, слева направо (если переменная установлена). Переменная PYTHONPATH - это просто список имен каталогов, определяемых пользователем и системой. Мы можем добавит ьв эту переменную все каталоги где у нас будут модули. Конечно, для начала можно её не настраивать, а хранить модули в домашнем каталоге. А уж потом, как получите больше опыта,  обращться к её изменению.

Каталоги стандратной библиотеки.

Т.к. эти каталоги автоматически участвуют в поиске, их можно не добавлять в переменную PYTHONPATH и не включат ьв файлы .pth.

Каталоги в файле .pth.

Эта особенность Ппитона дает возможность просто перечислисть нужные нам каталоги в текстовом файле, с расширением .pth (от слова "path" - "путь"). Это расширенная возможность, альтернатива настройки переменной PYTHONPATH.

Текстовый файл со списком каталогов помещается в соответствующий каталог и играет роль PYTHONPATH. В Виндовс в Питон 3.0, например, файл myconfig.pth можно поместить в глав. каталог (C:\Python34 - т.к. у меня установлен Питон 3.4), или в под-каталог site-packages  C:\Python34\lib\site-packages стандартной библиотеки. В Unix этот файл можно поместить в каталог /usr/local/lib/python34/site-packages или /usr/local/lib/site-python.

Интерпретатор выберет все имена каталогов во всех файлах .pth, которые обнаружит.

За доп. информацией обращайтесь к документации, в частности к описанию модуля site - этот модуль позволяет создавать файлы .pth и определять местоположение библиотек, в документации модуля описывается где вообще могут располагаться файлы .pth.

Начинающим рекомендуется использовать переменную PYTHONPATH или, если очень нужно, то один файл .pth.


Настройка пути поиска. стр. 616

Т.о. понятно, что переменная окружения PYTHONPATH и файлы .pth позволяют определять каталоги, где интерпретатор будет искать файлы при импортировании.

Способ настройки зависит от платформы, например мы можем через свойства системы в Виндовс просто записать в переменную PYTHONPATH список каталогов:

c:\pycode\utilites;d:\pycode\package1		# например таким образом (без пробелов!)

Или создать текстовый файл с именем C:\Python43\pydirs.pth с текстом примерно:

c:\pycode\utilites
d:\pycode\package1

- и т.п.

В Приложении А мы сможем найти указания по настройке пути поиска на различных платформах.


Автоматическое изменение пути поиска.

На самом деле точная конфигурация поиска зависит от платформы и версии Питона.

Например, за каталогами из PYTHONPATH и перед каталогами стандарт. библиотеки интерпретатор может добавлять текущий рабочий каталог - каталог, откуда была запущена программа.

Когда прога запускается из командной строки, текущий рабочий каталог может не совпадать с домашним каталогом, где находится глав. файл проги (т.е. с каталогом где нах-ся прога). Т.к. от запуска к запуску проги текущий рабочий каталог может меняться, при обычных условиях рабочий каталог не должен иметь значения для операции импорта.


Список sys.path

Если хотите узнать действительный путь поиска на своем ПК, то можете посмотреть содержимое встроенного списка sys.path (т.е. содержимое атрибута path модуля sys).

sys.path - это путь поиска модулей. Интерпретатор создает его во время запуска программы, автоматом объединяя в список домашний каталог (или пустую строку, что соответствует текущему рабочему каталогу), все каталоги, перечисленные PYTHONPATH и в файлах .pth, и каталоги стандарт. библиотеки.

Представление этого списка имеет два полезных результата:

- Первое - он обеспечивает возможность проверить настройки пути поиска, которые вы выполнили (если их нет в этом списке, то проверьте, что вы там наделали). Напр. автор добавил в PYTHONPATH каталог C:\users и в файл C:\Python34\mypath.pth каталог С:\users\mark, смотрим список (вначале пустая строка, соотв-щая текущему рабочему каталогу):

>>> import sys
>>> sys.path
['', 'C:\\users', 'C:\\Python34\\Lib\\idlelib', 'C:\\WINDOWS\\system32\\python34.zip', 'C:\\Python34\\DLLs', 'C:\\Python34\\lib', 'C:\\Python34', 'С:\\users\\mark', 'C:\\Python34\\lib\\site-packages']

- здесь мы видим где располагаются в списке оба добавленных каталога.

- Второе - если мы понимаем как формируется список, можем дать сценариям возможность самостоятельно задавать свои пути поиска. Изменяя sys.path мы можем изменить путь поиска для всех последующих операций импорта. Не забывайте - эти изменения продолжают действовать пока выполняется сценарий (иногда это даже полезно, напр. на веб-серверах, ведь там миллионы пользователей в день бывает). PYTHONPATH и файлы .pth обеспечивают более долговременное хранение пути.       


Выбор файла модуля.

Интерпретатор выбирает первый, найденный в пути пориска, файл, который соотв-ет указанному имени (имена в import пишем без расширений, помним). Наприме import b мог бы загрузить:

- Файл с кодом, с именем b.py;

- Файл с байт-кодом, с именем b.pyc;

- Содержимое каталога b при импорте пакета (см. гл. 23);

- Скомпилированный модуль расширения (С или С++) в виде динамической библиотеки (b.so в Linux и b.dll или b.pyd в Cygwin и Windows);

- Скомпилированный встроенный модуль, на С и статически скомпонованный с интерпретатором;

- Файл zip-архива с компонентом, который автоматич. извлек-ся при импорте;

- Образ памяти для фиксированных двоичных исполняемых файлов;

- Класс Java в Jython;

- Компонент .NET в IronPython.

Для импортера не важны типы загружаемых файлов как при импорте так и при обращении к атрибутам модуля. Напри, некоторые модули, которыми будем польз-ся, на самом деле написаны на С, - но для клиентов это не имеет значения.

Если у нас в разных каталогах есть файлы b.py и b.so, интерпретатор будет загружать тот, что будет найден в каталоге, который располагается раньше (левее) в пути поиска модулей (поиск в списке sys.path идет слева направо).

Если же оба файла  b.py и b.so находятся в одном каталоге, интерпретатор будет следовать стандарт. порядку выбора файлов (который может измениться в др. версиях языка, например, т.е. гарантий нет).

Т.о. видим, что мы должны избегать зависимости от порядка выбора файлов интерпретатором в одном и том же каталоге - давайте модулям различные имена и настраивайте путь поиска так ,чтобы порядок выбора был очевидным.


Дополнительные возможности выбора модуля.

Мы можем изменять обычную операцию импорта, и переопределять её большую часть, используя то, что называется - программными ловушками импорта. Эти ловушки придают операции импорта доп. возможности, напр. загрузка файлов из архивов, расшифровывание и т.д.

Сам интерпретатор использ. эти ловушки, чтобы извлекать компоненты из zip-архивов (см. выше). Нарп. один из каталогов стандарт. библиотеки в sys.path, на сегодняшний день (от атора книги) явл-ся файлом .zip.

За доп. информацией обращайтесь с описанию ф-ции __import__, которая использует инструкцию import.

Питон поддерживает также понятие файлов с оптимизированным байт-кодом (.pyo), которые созд-ся и запуск-ся интерпретатором из командной строки с флагом -0, - однако выполняются немногим быстрее чем обычные файлы .pyc, поэтому использ-ся редко.


Стороннее программное обеспечение: distutils.

Настройка пути поиска в первую очередь относится к коду, который мы пишем самостоятельно.

Сторонние расширения Питон обычно использ-т для автоматической установки самих себя такой инструмент, как disrutils, входящий в состав стандарт. библиотеки.

Системы, использующие distutils, обычно поставляются со сценарием setup.py, который запускается для установки таких систем - этот сценарий импортирует и использ. модуль distutils, чтобы поместить систему в каталог, котоырй уже явл-ся частью пути поиска модулей (обычно подкаталог Lib\sitepackages в каталоге, куда был установлен Питон).

Этот инстурмент также обеспечивает возможность компиляции расширений на С на машине, где происходит установка. Обратите также внимание на систему "eggs" (новая система на момент напсиания книги).
















Глава 22. Основы программирования модулей.


Создание модуля.  
 
В текстовом редакторе вводим программный код в текстовый файл и сохраняем его с расширением .py - любой такой файл автоматически будет считаться модулем Питона (практически любой текстовый файл может играть роль модуля).

Все имена, которым будет выполнено присваивание на верхнем уровне модуля, станут его атрибутами (именами ассоциированными с объектами модуля) и будут доступны для использования клиентами.

Напр. инструкция def в файле module1.py, импортируя его мы получаем объект модуля с атрибутом - printer, которое ссылается на объхект ф-ции:

def printer(x):			# Атрибут модуля
	print(x)
	
Мы можем называть файлы как угодно, главное расширение .py, если собираемся импортировать модуль.

Глав. файлы, которые будут запускаться, но не будут импортироваться, расширение не обязательно должно быть .py, но желательно использовать его (вдруг захотим импортировать глав. файл в будущем).

Т.к. имена файлов становятся именами переменных, в инструкции import, они должны следовать правилам именования обычных переменных (см. гл. 11).

Напр. можно создать файл модуля с именем if.py, но его невозможно импортировать, т.к. if - это зарезервированное слово, мы получим ошибку, если попытаемся импортировать.

И имена модулей и имена каталогов (использ-ч при импортировании пакетов) должны соотв-ть правилам именования переменных из гл. 11, т.е. содержать только алфавитные символы, цифры и символы подчеркивания.

При импортировании преобразуется имя модуля в имя внеш. файла, добавляя в начало путь из каталога путей поиска и расширение .py, или др. расширение.

Также ест ьвозможность создать модуль  на др. ЯП, такие модули наз-ся модулями расширений. Когда они импортируются, то ведут себя как обычные модули, написанные на Питон.


Использование модулей.

Клиенты могут использовать модуль выполнив import или from. Обе инструкции отыскивают, компилируют и запускают программный код модуля, если он еще не был загружен.

import загружает модуль целиком, поэтому имена нужно дополнять именем модуля (мы с этим уже столкнулись), а инструкция from загружает (или копирует) из модуля отдельные имена (и имя модуля уже не нужно).

Создаем в папке C:\Python34 файл module1.py с ф-цией printer, и далее в примерах будет фигурировать этот модуль.


Инструкция import.

В этом примере module1 идентифицирует внеш. файл и вревращается в имя переменной, которая ссылается на объект модуля после загрузки файла:

>>> import module1						# Загрузить модуль целиком
>>> module1.printer('Hello World!')		# имя дополняем именем модуля
Hello World!


Инструкция from.

Инструкция from копирует имена из области видимости одного файла в область видимости другого:

>>> from module1 import printer			# Копировать одну переменную
>>> printer('HelloWorld!')				# Имя не требует дополнения
HelloWorld!

Инструкция from явл-ся всего лишь расширением инструкции import - она импортирует модуль как обычно, но выполняет доп. шаг, на котором копирует одно или более имен.


Инструкция from *

Когда используется символ * в from, копируются все имена. В этом случае точно так же можно использовать скопированное имя printer, не предваря его именем модуля:

>>> from module1 import *
>>> printer('HelloWorld!')
HelloWorld!

В Питон 3.0 инструкция from ... *, может использ-ся только на верхнем уровне модуля - она не может вызываться внутри функций. В 2.6 можно вызывать внутри ф-ций, но показывает предупреждение.


Импорт выполняется только один раз.

Почему же модуль выполняет свои операции только при первом импортировании (напр. print()), а при последующем ничего не происходит? На самом деле этот эффект и должен быть.

Модули загружаются и запускаются первой и только первой инструкцией import или from. Это сделано потому, что импортирование - это дорогостоящая операция и поэтому выполняется один раз. А при последющем импорте просто получают объект загруженного модуля.

Т.к. код на верх. уровне модуля выполняется всего один раз, это можно использ. для инициализации переменных. Рассмотрим пример модуля simple.py:

print('Hello')      
spam = 1

В этом примере инструкции print и = выполняются во время первого импортирования модуля и в это же время инициализируется переменная spam:

>>> import simple		# Первая инструкция import: загружает и запускает код модуля
Hello!
>>> simple.spam			# Операция присваивания создает атрибут
1 

Все последующие операция импорта не приводят к перезапуску кода модуля - они просто получают объект модуля из внутренней таблицы модулей интерпретатора:

>>> simple.spam = 2			# Изменяем атрибут модуля
>>> import simple			# Эта инструкция получает уже загруженный ранее модуль
>>> simple.spam				# Код не перезапускается: атрибут не изменился
2


Инструкции import и from - операции присваивания.

Как и def, инструкции import и from явл-ся исполняемыми инструкциями, а не объявлениями времени компиляции. Они могут вкладываться в инструкции if, присутствовать в объявлениях def и т.д., и они не имеют эффекта пока интерпретатор не достигнет их в ходе выполнения проги. Т.е. импортируемые модули и имена не будут доступны пока не будут выполнены import или from.

Также import и from - это явные операции присваивания:

- import присваивает объект модуля единственному имени;

- from присваивает одно или более имен объектам с теми же именами в др. модуле.

Всё, что обсуждалось ранее применимо и к модулям. Например, имена, копируемые from, становятся ссылками на разделямые объекты - как и аргументы ф-ций, повторное присваивание полученному имени не оказывает воздействия на модуль, откуда это имя было скопировано, но модификация изменяемого объекта может оказывать влияние на объект в модуле, откуда он был импортирован. Пример с файлом small.py:

x = 1
y = [1, 2]

>>> from small import x, y		# Скопировать два имени
>>> 
>>> x = 42						# Изменяется только локальная переменная х
>>> y[0] = 42					# Изменяется непосредственно изменяемый объект

Имена y в импортирующем и импортируемом модулях ссылаются на один и тот же объект списка:

>>> import small			# Получить имя модуля (инструкция from его не дает)
>>> small.x				# x в модуле small - это не наша локал. переменная х
1
>>> small.y				# а изменяемый объект исполз-ся повсеместно
[42, 2] 

Кстати, вернитесь к рис. 18.1 и замените слова "вызывающая программа" и "функция" на "импортируемый модуль" и "импортирующий модуль" и получите графическое изображение наших примеров.


Изменение значений имен в других файлах. стр. 627





















  




















