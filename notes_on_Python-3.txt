
Часть 4. Модули.  стр. 605


Глава 21. Модули: общая картина.  стр. 607

Модули - самая крупная организационная программная единица, которая вмещает код и данные, готовые для многократного использования.

Модули обычно соотв-ют файлам программ (или расширениям др. ЯП как С, Java, C#). 

Каждый файл - это отдельный модуль, конечно модули могут испортировать др. модули.

Моудли обрабатываются двумя инструкциями и одной функцией:

- import - Позволяет клиентам (импортерам) получать модуль целиком.

- from - Позволяет клиентам получать определенные имена из модуля.

- imp.reload - Обеспечивает возможность повторной загрузки модуля без остановки интерпретатора.


Зачем нужны модули?

Модули обеспечивают простой способ организации компонентов в систему автономных пакетов переменных, известных как пространства имен.
Все имена, определяемые на верх. уровне модуля, становятся атрибутами объекта импортируемого модуля.

В процессе импорта глоабл. область модуля образует пространство имен атрибутов объекта модуля.

Модули позволяют связывать отдельные файлы в крупные программные системы.

По теории, модули играют как минимум три роли:

- Повторное использование программного кода. Т.к. модули хранят код в виде файлов то код, т.о., хранится постоянно, т.е. его можно загружать и запускать сколько угодно раз. Так модули становятся местом, где определяются имена, известные как - атрибуты, на которые могут ссылаться внешние клиенты.

- Разделение системы пространства имен. По сути, модули - всего лишь пакеты имен. Т.о. появл-ся изоляция - мы никогда не узнаем имя в др. модуле пока не импортируем его. Выполняемый код и создаваемые объекты модуля - всегда неявно включается в модули.

- Реализация служб или данных для совместного использования. С функциональной точки зрения, модули могут использ-ся для реализации компонентов, используемых системой, вследствии чего требуется только одна копия такого компонента. Нарп. если нужен глобал. объект, использующийся более одной ф-цией или модулем, можно написать его в виде модуля, который будет импортироваться многими клиентами.


Архитектура программы на языке Питон.

Обычно программы состоят более чем из одного файла, даже если ваш файл всего один наверняка вы используете какие-то модули.

Изучим введение в архитектура программ - способ, которым программа делится на коллекцию файлов с исходными текстами (т.е. модулей) и увязывается в единое целое.


Как организована программа.

Как правило программа состоит из множества текстовых файлов, содержащих инструкции. Программа организована как один главный файл, к которому могут подключаться доп. файлы, известные как модули.

Главный файл (или сценарий) определяет, как будет двигаться основной поток выполнения программы, - это тот файл, который нужно запустить, чтобы начать работу приложения.

Файлы модулей - библиотеки инструментов, где содержатся компоненты, используемые главным файлом (и может где-то еще). Глав. файл использ-т инструменты, определенне в файлах модулей, а модули использ. инструменты, из др. модулей.

Обычно файлы модулей ничего не делают сами по себе, - в них определяются инструментальные средства, используемые в др. файлах. Чтобы получить доступ к инструментам модуля, наз-ся атрибутами модуля, необходимо импортировать модуль.


Импортирование и атрибуты.

Рисунок 21.1 Структура программ на Питон.  стр. 610

Три файла: a.py, b.py, c.py. Файл a.py явл-ся глав. файлом программы, в нем инструкции. Файлы b.py, c.py - модули, также простые текстовые файлы с инструкциями, но как самостоятельные программы они обычно не запускаются.

Пусть b.py определяет ф-цию spam:

def spam(text):
	print(text, 'spam')
	
Предположим, что модуль a.py использ-т spam, описание его такое:

import b
b.spam('gumby')

- получаем доступ ко всему, что определено на верхнем уровне b.py (т.е. ко всем атрибутам).

Импорт нужен чтобы связать имена в модуле - простые переменные - с объектами загруженных модулей.

Фактически, имя модуля в инструкции import, идентифицирует внешний файл, и становится именем переменной, которая будет представлять загруженный модуль.

b.spam - вызывает ф-цию, поределенную в b.py ("извлечь значение имени psam, расположенного в b").

Мы увидим, что повсюду в Питон использ-ся нотация object.attribute (здесь точка "." - это оператор).

Любой файл может импортировать функциональные возможности из другого файла. 


Модули стандартной библиотеки.

Интерпретатор Питон поставл-ся с обширной коллекцией доп. модулей, которая известна как стандартная библиотека. Она насчитывает окооло 200 модулей (это из книги цифра) и платформонезависимую поддержку разных задач: интерфейсы ОС, организацию хранилищ объектов, поиск по шаблону, сетевые взаимодействия, создания графич. интерфейса и др.

Они могут использ-ся при импортировании необходимого модуля.


Как работает импорт.

Программисты на С любят сравниват ьинструкцию import в Питон с инструкцией #include, но они в корне
неправы - импортирование в Питон - это не просто включение текста одного файла в другой.

Это самые настоящие операции времени выполнения, которые вып-т след. действия, когда программа импортирует файл:

1. Отыскивают файл модуля.
2. Компилируют в байт-код (если нужно).
3. Запускают программный код модуля, чтобы создать объекты, которые он определяет.

Внимание. Все три действия вып-ся только если модуль импортируется впервые во время выполнения программы - последующие операции импорта этого же модуля пропускают эти действия и просто выбирают,Ю уже находящийся в памяти объект модуля.

Интерпретатор сохраняет информацию о загруженных модулях в словаре с именем sys.modules и проверяет его при каждой операции импортирования. Если модуль отсутствует, то выполняется процесс, описанный выше.  


1. Поиск.

На этом этапе интерпретатор определяет местонахождение файла модуля. 

Заметим, что имена модулей в инструкции import указываются без расширения .py и без пути к каталогу, эти ограничения выполняются потому что интерпретатор использует стнадартный путь поиска модулей.

2. Компиляция (если необходимо).

Когда файл найден интерпретатор компилирует его в байт-код, если нужно.

Интерпретатор проверяет время создания файла и пропускает компиляцию, если файл с байт-кодом .pyc не старше, чем соответствующий ему файл .py с исходным текстом.

Если Питон находит только файл с байт-кодом и не найдет файл с исходным текстом, то он просто загрузит байт-код. Это даже ускорит запуск программы.

Обратите внимание, компиляция выполняется в момент импортирования файла. По этой причине файл .pyc с байт-кодом для глав. файла программы обычно не создается, если тольк оон не был импортирован куда-то еще (файл .pyc создаются при импортировании). Байт-код файла программы создается в памяти ПК, а импортированных файлов сохр-ся в файлах для ускорения будущих импортов.

Также можно создавать глав. файлы, которые будут играть роль и главного файла и импортируемого модуля, но об этом потом.

3. Запуск.  

На последнем шаге идет запуск байт-кода модуля. все инструкции в файле модуля выполняются по порядку, сверху вниз, и любые операции присваивания, которые встретятся на этом шаге, будут создавать атрибуты конечного объекта модуля. Т.о. этот этап создает все инструменты, которые опред-ся модулем (напр. выполняются инструкции def, создающие ф-ции и мн. др.).

Т.о. фактически запускается программный код модуля, и если код выполняет какие-то действия, то мы сможем их наблюдать во время импорта (напр. действия инструкции print).


Путь поиска модулей.

Нам может потребоваться сообщить интерпретатору, где искать импортируемые файлы, поэтмоу нужн ознать как получить доступ к пути поиска.

Имеются следующие источники поиска:

1. Домашний каталог программы (в моей Убунте это - домашняя папка моего пользователя).
2. Содержимое переменной окружения PYTHONPATH (если таковая определена).
3. Каталоги стандартной библиотеки.
4. Содержимое любых файлов с расширением .pht (если таковые имеются).

Объединение этих компонентов составляет sys.path - список строк с именами каталогов, о нем поговорим позднее.

Первый и третий пути определяются автоматически, а второй и четвертый можно использовать для расширения пути поиска.

Домашний каталог. 

В первую очередь интерпретатор ищем в домашнем каталоге. В зависимости от того как была запущена программа, это может быть каталог, где нах-ся глав. файл программы. У меня в Убунте модули приходится сохранять в домашней папке пользователя, а в Виндовс - в папке Питона.

Каталоги в PYTHONPATH.

Затем произв-ся поиск в каталогах окружения PYTHONPATH, слева направо (если переменная установлена). Переменная PYTHONPATH - это просто список имен каталогов, определяемых пользователем и системой. Мы можем добавит ьв эту переменную все каталоги где у нас будут модули. Конечно, для начала можно её не настраивать, а хранить модули в домашнем каталоге. А уж потом, как получите больше опыта,  обращться к её изменению.

Каталоги стандратной библиотеки.

Т.к. эти каталоги автоматически участвуют в поиске, их можно не добавлять в переменную PYTHONPATH и не включат ьв файлы .pth.

Каталоги в файле .pth.

Эта особенность Ппитона дает возможность просто перечислисть нужные нам каталоги в текстовом файле, с расширением .pth (от слова "path" - "путь"). Это расширенная возможность, альтернатива настройки переменной PYTHONPATH.

Текстовый файл со списком каталогов помещается в соответствующий каталог и играет роль PYTHONPATH. В Виндовс в Питон 3.0, например, файл myconfig.pth можно поместить в глав. каталог (C:\Python34 - т.к. у меня установлен Питон 3.4), или в под-каталог site-packages  C:\Python34\lib\site-packages стандартной библиотеки. В Unix этот файл можно поместить в каталог /usr/local/lib/python34/site-packages или /usr/local/lib/site-python.

Интерпретатор выберет все имена каталогов во всех файлах .pth, которые обнаружит.

За доп. информацией обращайтесь к документации, в частности к описанию модуля site - этот модуль позволяет создавать файлы .pth и определять местоположение библиотек, в документации модуля описывается где вообще могут располагаться файлы .pth.

Начинающим рекомендуется использовать переменную PYTHONPATH или, если очень нужно, то один файл .pth.


Настройка пути поиска. стр. 616

Т.о. понятно, что переменная окружения PYTHONPATH и файлы .pth позволяют определять каталоги, где интерпретатор будет искать файлы при импортировании.

Способ настройки зависит от платформы, например мы можем через свойства системы в Виндовс просто записать в переменную PYTHONPATH список каталогов:

c:\pycode\utilites;d:\pycode\package1		# например таким образом (без пробелов!)

Или создать текстовый файл с именем C:\Python43\pydirs.pth с текстом примерно:

c:\pycode\utilites
d:\pycode\package1

- и т.п.

В Приложении А мы сможем найти указания по настройке пути поиска на различных платформах.


Автоматическое изменение пути поиска.

На самом деле точная конфигурация поиска зависит от платформы и версии Питона.

Например, за каталогами из PYTHONPATH и перед каталогами стандарт. библиотеки интерпретатор может добавлять текущий рабочий каталог - каталог, откуда была запущена программа.

Когда прога запускается из командной строки, текущий рабочий каталог может не совпадать с домашним каталогом, где находится глав. файл проги (т.е. с каталогом где нах-ся прога). Т.к. от запуска к запуску проги текущий рабочий каталог может меняться, при обычных условиях рабочий каталог не должен иметь значения для операции импорта.


Список sys.path

Если хотите узнать действительный путь поиска на своем ПК, то можете посмотреть содержимое встроенного списка sys.path (т.е. содержимое атрибута path модуля sys).

sys.path - это путь поиска модулей. Интерпретатор создает его во время запуска программы, автоматом объединяя в список домашний каталог (или пустую строку, что соответствует текущему рабочему каталогу), все каталоги, перечисленные PYTHONPATH и в файлах .pth, и каталоги стандарт. библиотеки.

Представление этого списка имеет два полезных результата:

- Первое - он обеспечивает возможность проверить настройки пути поиска, которые вы выполнили (если их нет в этом списке, то проверьте, что вы там наделали). Напр. автор добавил в PYTHONPATH каталог C:\users и в файл C:\Python34\mypath.pth каталог С:\users\mark, смотрим список (вначале пустая строка, соотв-щая текущему рабочему каталогу):

>>> import sys
>>> sys.path
['', 'C:\\users', 'C:\\Python34\\Lib\\idlelib', 'C:\\WINDOWS\\system32\\python34.zip', 'C:\\Python34\\DLLs', 'C:\\Python34\\lib', 'C:\\Python34', 'С:\\users\\mark', 'C:\\Python34\\lib\\site-packages']

- здесь мы видим где располагаются в списке оба добавленных каталога.

- Второе - если мы понимаем как формируется список, можем дать сценариям возможность самостоятельно задавать свои пути поиска. Изменяя sys.path мы можем изменить путь поиска для всех последующих операций импорта. Не забывайте - эти изменения продолжают действовать пока выполняется сценарий (иногда это даже полезно, напр. на веб-серверах, ведь там миллионы пользователей в день бывает). PYTHONPATH и файлы .pth обеспечивают более долговременное хранение пути.       


Выбор файла модуля.

Интерпретатор выбирает первый, найденный в пути пориска, файл, который соотв-ет указанному имени (имена в import пишем без расширений, помним). Наприме import b мог бы загрузить:

- Файл с кодом, с именем b.py;

- Файл с байт-кодом, с именем b.pyc;

- Содержимое каталога b при импорте пакета (см. гл. 23);

- Скомпилированный модуль расширения (С или С++) в виде динамической библиотеки (b.so в Linux и b.dll или b.pyd в Cygwin и Windows);

- Скомпилированный встроенный модуль, на С и статически скомпонованный с интерпретатором;

- Файл zip-архива с компонентом, который автоматич. извлек-ся при импорте;

- Образ памяти для фиксированных двоичных исполняемых файлов;

- Класс Java в Jython;

- Компонент .NET в IronPython.

Для импортера не важны типы загружаемых файлов как при импорте так и при обращении к атрибутам модуля. Напри, некоторые модули, которыми будем польз-ся, на самом деле написаны на С, - но для клиентов это не имеет значения.

Если у нас в разных каталогах есть файлы b.py и b.so, интерпретатор будет загружать тот, что будет найден в каталоге, который располагается раньше (левее) в пути поиска модулей (поиск в списке sys.path идет слева направо).

Если же оба файла  b.py и b.so находятся в одном каталоге, интерпретатор будет следовать стандарт. порядку выбора файлов (который может измениться в др. версиях языка, например, т.е. гарантий нет).

Т.о. видим, что мы должны избегать зависимости от порядка выбора файлов интерпретатором в одном и том же каталоге - давайте модулям различные имена и настраивайте путь поиска так ,чтобы порядок выбора был очевидным.


Дополнительные возможности выбора модуля.

Мы можем изменять обычную операцию импорта, и переопределять её большую часть, используя то, что называется - программными ловушками импорта. Эти ловушки придают операции импорта доп. возможности, напр. загрузка файлов из архивов, расшифровывание и т.д.

Сам интерпретатор использ. эти ловушки, чтобы извлекать компоненты из zip-архивов (см. выше). Нарп. один из каталогов стандарт. библиотеки в sys.path, на сегодняшний день (от атора книги) явл-ся файлом .zip.

За доп. информацией обращайтесь с описанию ф-ции __import__, которая использует инструкцию import.

Питон поддерживает также понятие файлов с оптимизированным байт-кодом (.pyo), которые созд-ся и запуск-ся интерпретатором из командной строки с флагом -0, - однако выполняются немногим быстрее чем обычные файлы .pyc, поэтому использ-ся редко.


Стороннее программное обеспечение: distutils.

Настройка пути поиска в первую очередь относится к коду, который мы пишем самостоятельно.

Сторонние расширения Питон обычно использ-т для автоматической установки самих себя такой инструмент, как disrutils, входящий в состав стандарт. библиотеки.

Системы, использующие distutils, обычно поставляются со сценарием setup.py, который запускается для установки таких систем - этот сценарий импортирует и использ. модуль distutils, чтобы поместить систему в каталог, котоырй уже явл-ся частью пути поиска модулей (обычно подкаталог Lib\sitepackages в каталоге, куда был установлен Питон).

Этот инстурмент также обеспечивает возможность компиляции расширений на С на машине, где происходит установка. Обратите также внимание на систему "eggs" (новая система на момент напсиания книги).
















Глава 22. Основы программирования модулей.


Создание модуля.  
 
В текстовом редакторе вводим программный код в текстовый файл и сохраняем его с расширением .py - любой такой файл автоматически будет считаться модулем Питона (практически любой текстовый файл может играть роль модуля).

Все имена, которым будет выполнено присваивание на верхнем уровне модуля, станут его атрибутами (именами ассоциированными с объектами модуля) и будут доступны для использования клиентами.

Напр. инструкция def в файле module1.py, импортируя его мы получаем объект модуля с атрибутом - printer, которое ссылается на объхект ф-ции:

def printer(x):			# Атрибут модуля
	print(x)
	
Мы можем называть файлы как угодно, главное расширение .py, если собираемся импортировать модуль.

Глав. файлы, которые будут запускаться, но не будут импортироваться, расширение не обязательно должно быть .py, но желательно использовать его (вдруг захотим импортировать глав. файл в будущем).

Т.к. имена файлов становятся именами переменных, в инструкции import, они должны следовать правилам именования обычных переменных (см. гл. 11).

Напр. можно создать файл модуля с именем if.py, но его невозможно импортировать, т.к. if - это зарезервированное слово, мы получим ошибку, если попытаемся импортировать.

И имена модулей и имена каталогов (использ-ч при импортировании пакетов) должны соотв-ть правилам именования переменных из гл. 11, т.е. содержать только алфавитные символы, цифры и символы подчеркивания.

При импортировании преобразуется имя модуля в имя внеш. файла, добавляя в начало путь из каталога путей поиска и расширение .py, или др. расширение.

Также ест ьвозможность создать модуль  на др. ЯП, такие модули наз-ся модулями расширений. Когда они импортируются, то ведут себя как обычные модули, написанные на Питон.


Использование модулей.

Клиенты могут использовать модуль выполнив import или from. Обе инструкции отыскивают, компилируют и запускают программный код модуля, если он еще не был загружен.

import загружает модуль целиком, поэтому имена нужно дополнять именем модуля (мы с этим уже столкнулись), а инструкция from загружает (или копирует) из модуля отдельные имена (и имя модуля уже не нужно).

Создаем в папке C:\Python34 файл module1.py с ф-цией printer, и далее в примерах будет фигурировать этот модуль.


Инструкция import.

В этом примере module1 идентифицирует внеш. файл и вревращается в имя переменной, которая ссылается на объект модуля после загрузки файла:

>>> import module1						# Загрузить модуль целиком
>>> module1.printer('Hello World!')		# имя дополняем именем модуля
Hello World!


Инструкция from.

Инструкция from копирует имена из области видимости одного файла в область видимости другого:

>>> from module1 import printer			# Копировать одну переменную
>>> printer('HelloWorld!')				# Имя не требует дополнения
HelloWorld!

Инструкция from явл-ся всего лишь расширением инструкции import - она импортирует модуль как обычно, но выполняет доп. шаг, на котором копирует одно или более имен.


Инструкция from *

Когда используется символ * в from, копируются все имена. В этом случае точно так же можно использовать скопированное имя printer, не предваря его именем модуля:

>>> from module1 import *
>>> printer('HelloWorld!')
HelloWorld!

В Питон 3.0 инструкция from ... *, может использ-ся только на верхнем уровне модуля - она не может вызываться внутри функций. В 2.6 можно вызывать внутри ф-ций, но показывает предупреждение.


Импорт выполняется только один раз.

Почему же модуль выполняет свои операции только при первом импортировании (напр. print()), а при последующем ничего не происходит? На самом деле этот эффект и должен быть.

Модули загружаются и запускаются первой и только первой инструкцией import или from. Это сделано потому, что импортирование - это дорогостоящая операция и поэтому выполняется один раз. А при последющем импорте просто получают объект загруженного модуля.

Т.к. код на верх. уровне модуля выполняется всего один раз, это можно использ. для инициализации переменных. Рассмотрим пример модуля simple.py:

print('Hello')      
spam = 1

В этом примере инструкции print и = выполняются во время первого импортирования модуля и в это же время инициализируется переменная spam:

>>> import simple		# Первая инструкция import: загружает и запускает код модуля
Hello!
>>> simple.spam			# Операция присваивания создает атрибут
1 

Все последующие операция импорта не приводят к перезапуску кода модуля - они просто получают объект модуля из внутренней таблицы модулей интерпретатора:

>>> simple.spam = 2			# Изменяем атрибут модуля
>>> import simple			# Эта инструкция получает уже загруженный ранее модуль
>>> simple.spam				# Код не перезапускается: атрибут не изменился
2


Инструкции import и from - операции присваивания.

Как и def, инструкции import и from явл-ся исполняемыми инструкциями, а не объявлениями времени компиляции. Они могут вкладываться в инструкции if, присутствовать в объявлениях def и т.д., и они не имеют эффекта пока интерпретатор не достигнет их в ходе выполнения проги. Т.е. импортируемые модули и имена не будут доступны пока не будут выполнены import или from.

Также import и from - это явные операции присваивания:

- import присваивает объект модуля единственному имени;

- from присваивает одно или более имен объектам с теми же именами в др. модуле.

Всё, что обсуждалось ранее применимо и к модулям. Например, имена, копируемые from, становятся ссылками на разделямые объекты - как и аргументы ф-ций, повторное присваивание полученному имени не оказывает воздействия на модуль, откуда это имя было скопировано, но модификация изменяемого объекта может оказывать влияние на объект в модуле, откуда он был импортирован. Пример с файлом small.py:

x = 1
y = [1, 2]

>>> from small import x, y		# Скопировать два имени
>>> 
>>> x = 42						# Изменяется только локальная переменная х
>>> y[0] = 42					# Изменяется непосредственно изменяемый объект

Имена y в импортирующем и импортируемом модулях ссылаются на один и тот же объект списка:

>>> import small			# Получить имя модуля (инструкция from его не дает)
>>> small.x				# x в модуле small - это не наша локал. переменная х
1
>>> small.y				# а изменяемый объект исполз-ся повсеместно
[42, 2] 

Кстати, вернитесь к рис. 18.1 и замените слова "вызывающая программа" и "функция" на "импортируемый модуль" и "импортирующий модуль" и получите графическое изображение наших примеров.


Изменение значений имен в других файлах. стр. 627

В примере выше переменная х менялась только в IDLE, но не менялась в файле, т.к. между именем, скопированным from и именем в файле нет никакой связи.

Чтобы изменить глоабл. имя в др. файле, нужно использовать import:

>>> from small import x, y		# Копируем два имени
>>> x
1
>>> x = 42						# Изменяем локал. имя х
>>> x
42
>>> import small			# Получаем имя модуля
>>> x						# Локальное х по-прежнему 42
42
>>> small.x					# А х в модуле по-прежнему равно 1
1
>>> small.x = 42			# Изменяем х в модуле (но не в файле на диске, конечно)
>>> x
42
>>> small.x					# Теперь оба х равны 42
42

- По этому явлению см. главу 17. Такое изменение переменных может быть источником проблем (связи все такое), нужно быть очень внимательными.


Эквивалентность инструкций import и from.

Инструкция from, приведенная ниже:

from module import name1, name2			# Копировать только эти два имени

- эквивалентна следующей последовательности:

import module					# Получаем объект модуля
name1 = module.name1			# Копирванием имена с помощью присваивания
name2 = module.name2
del module 						# Удалить имя модуля (from не копирует сам модуль)
 
Т.о. from создает новые переменные в импортирующем модуле, которые ссылаются на объект с теми же имена в импортируемом модуле.


Потенциальные проблемы инструкции from.

from делает местоположение переменных менее явным (напр. name и module.name), поэтому некоторые рекомендуют использ. import вместо from. Но ве-таки from тоже полезна, ведь удобнее писат ьимена без приставки имени модуля (особенно если модуль имеет много атрибутов).

Суть проблемы в том, что from способна повреждать пространства имен, - если при импорте сущ-ют одноименные переменные в имеющейся области видимости, то они будут перезаписаны.

import не дает такой проблемы, т.к. имя модуля указывается вместе с атрибутами. Но если from использовать внимательно и осторожно, то можно избежать таких проблем.

С др. стороны, имеются более серьезные проблемы при использ. from вместе с reload, т.к. импортирвоанные имена могут ссылаться на предыдущие версии объектов.

Также инструкция в форме from module import *  может повреждать пространства имен и затрудняет понимание имен.

Отдавайте предпочтение import для простых модулей, явно перечисляйте имена в from (без *, если можно) и не используйте форму from * для импорта более чем одного файла в модуле. И конечно осторожность и внимательность.


Когда необходимо использовать инструкцию import.

Главное - это когда нужно использовать одно и тоже имя, присутствующее в двух разных модулях. Напр. если файлы по-разному определяют одно и то же имя:

# M.py

def func():
	...выполнить что-то одно...
	
# N.py

def func():
	...выполнить что-то другое...  	

В этом случае использ. from нельзя, т.к. получим одно, а не два имени:

# O.py

from M import func
from N import func				# перезапишет имя, импортированное из модуля M
func()  						# Будет вызвана N.func 		

В этом случае нужен import:

# O.py

import M, N				# Получаем модуль целиком
M.func()				# Теперь можем вызывать обе ф-ции
N.finc()				# Наличие имени модуля делает их уникальными


Пространства имен модулей.

Модули будут понятны, если представлять их как пакеты имен - т.е. место, где определяются переменные, которые должны быть доступны остальной системе.

Технически каждому модулю соотв-т отдельный файл, и интерпретатор создает объект модуля, содержащий все имена, которым присвоены значения в файле модуля.


Файлы создают пространства имен.

Каждое имя, которому присв-ся некое значение на верх. уровне модуля (т.е. не вложенное в ф-ции или классы), превращается в атрибут этого модуля.

Напр. Х = 1 на верх. уровне модуля M.py превращает имя Х в атрибут модуля М (доступно как М.Х). Также имя Х становится глобал. переменной для программного кода внутри модуля M.py.

Уточним некоторые моменты:

- Инструкции модуля выполняются во время первой попытки импорта. Первый импорт - созда-ся пустой объхект модуля и выполняются инструкции одна за другой.

- Операции присваивания, выполняемые на верхнем уровне, создают атрибуты модуля.

- Доступ к пространствам имен модулей можно получить через атрибут __dic__ или dir(M). Пространства имен модулей - это словари - доступ к ним ест ьчерез атрибут __dict__, и с помощью ф-ции dir.

- Модуль - это единая область видимости (локальная является глобальной). Имена на верх. уровне модуля выполняют те же правила обращения/присваивания, что и имена в ф-циях (т.е. соотв-ют правилу LEGB только без уровней L и E). В модулях область видимости модуля, после загрузки модуля, превращается в атрибут-словарь объекта модуля.

Примеры. 

Создаем файл module2.py:

print('starting to load...')
import sys
name = 42

def func(): pass

class klass: pass

print('done loading.')

А теперь импортируем его (в это время вып-ся все инструкции):

>>> import module2
starting to load...
done loading.

Модуль загружен и его область видимостипревращается в пространство имен атрибутов объекта модуля. Теперь можно обращаться к атрибутам в этом пространсте:

>>> module2.sys
<module 'sys' (built-in)>
 
>>> module2.name
42
 
>>> module2.func
<function func at 0x0227B588>
 
>>> module2.klass
<class 'module2.klass'>

Обратите внимание на атрибут sys - инструкции import действительно присваивают объекты модулей именам, а любая операция присваивания на верх. уровне создает атрибут модуля.

Пространство имен внутри интерпретатора - это обычный словарь и можно обратиться к нему через атрибут __dict__ модуля (и list не забудьте):

>>> list(module2.__dict__.keys())
['sys', 'klass', '__cached__', '__spec__', '__package__', 'func', 'name', '__file__', '__name__', '__builtins__', '__loader__', '__doc__']

Имена в файле модуля становятся ключами внутреннего словаря (мы видим список т.к. выборку ключей обернули в list). Например __file__ содержит имя файла, из которого загружен модуль, а __name__ - это имя модуля, которое пишется в инструкции import.

    
Квалификация имен атрибутов.

В Питон, для доступа к атрибутам любого объекта использ. синтаксис квалификации имени onject.attribute.

Квалификация имени явл-ся выражением, возвращающим значение, присвоенное имени атрибута, ассоциированного с объектом.

module2.sys возвращает значение атрибута sys в объекте module2. Также, если есть встроенный объект списка L, L.append вернет метод append, ассоциированный с этим списком.

Принятые правила квалификации:

- Простые переменные. Если используем краткую форму имени, напр. Х, то будет идти поиск в текущих областях видимости (согласно LEGB).

- Квалифицированные имена. Имя X.Y означает, что будет поиск имени Х в текущих областях видимости, а затем будет поиск атрибута Y в объекте X (не в областях видимости).

Квалифицированные пути. Имя X.Y.Z означает, что будет поиск имени Y в объекте X, а затем имени Z в объекте X.Y

- Общий случай. Квалификация имени применима ко всем объектам, имеющим атрибуты: модулям, классам, расшиерниям типов на С и т.д.


Импортирование и область видимости. 

Примеры. Модуль moda.py опредлеляет переменную Х, и ф-цию, изменяющую Х:

X = 88				# X - глобальная только для этого файла
def f():
	global X		# Изменяет Х в этом файле
	X = 99			# Имена в др. модулях недоступны (они внутри ф-ции)
	
Второй модуль modb.py имеет свою глобал. переменную Х, а также импортирует и вызывает ф-цию из первого модуля:

X = 11				# X - глобальная только для этого файла

import moda			# получаем доступ к именам в модуле moda
moda.f()			# Изменяет переменную moda.X, но не Х в modb
print(X, moda.X)	

Глоабльной областью ф-ции moda.f всегда явл-ся файл, вмещающий её, независимо от того, из какого модуля она была вызвана:

>>> import modb
11 99

Т.е. операция импортирования никогда не изменяет область видимости для программ. кода в импортируемом файле - из импортируемого файла нельзя получить доступ к именам в импортирующем файле.

- Функциям никогда не будут доступны имена, определнные в др. ф-циях, если только они не вложены друг в друга.

- Программ. коду модуля никогда не будут доступны имена, определенные в др. модулях, если только они явно не были импортированы.

Области видимости не подвержены влияниям вызовов ф-ций или операции импортирования, они полностью определяются физическим расположением этого программного кода в файле.


Вложенные пространства имен.

Импорт не дает доступ к внеш. областям видимости, но дает доступ к вложенным областям. Используя квалифицированные пути к именам атрибутов, можно погрузиться в сколь угодно глубоко вложенные модули и получить доступ к их атрибутам.

Файл mod3.py определяет единственное глобальное имя и атрибут операцией присваивания:

Х = 3 	

Файл mod2.py определяет свою переменную Х, затем импортирует модуль mod3 и использует квалификацию имени, чтобы получить доступ к атрибуту импортированного модуля:

Х = 2
import mod3

print(X, end=' ')			# Моя глобальная переменная Х
print(mod3.X)				# Глобал. переменная Х из модуля mod3

У файла mod1.py своя переменная Х, импорт mod2 и получает значения атрибутов обоих модулей:

X = 11
import mod2 

print(X, end=' ')			# Моя глобалю переменная Х
print(mod2.X, end=' ')		# Переменная Х из модуля mod2
print(mod2.mod3.X)			# Переменная Х из модуля mod3

Когда mod1 импортирует mod2, он создает двухуровневое вложение пространств имен. Используя путь mod2.mod3.X, он может погрузиться в модуль mod3, котоырй вложен в импортированный модуль mod2. Суть в том, что модуль mod1 может обращаться к переменным Х вовсех трех файлах, и поэтмоу имеет доступ ко всем трем глоабл. областям видимости:

>>> import mod1
2 3
1 2 3

А модуль mod3 не имеет доступ к именам в mod2, а модуль mod2 не имеет доступ к именам в mod1. Если переведем взгляд на объекты, задействованные в примене, то увидим, что mod2 внутри mod1 - это всего лишь имя, которое ссылается на объект с атрибутами, некоторые из них могут ссылаться на др. объекты с атрибутами. Пути вида mod2.mod3.X Питон вычисляет слева направо, извлекая атрибуты из объектов.

В mod1 можно вставить инструкцию import mod2 и использовать mod2.mod3.X, но нельзя записать import mod2.mod3 - такой синтаксис использ. для операции импортирования пакетов (каталогов).


Повторная загрузка модулей.

Повторно загрузить и зщапустить модуль можно при помощи ф-ции reload. Исследуем некоторые сообенности повторной загрузки:

- При вызове операции импортирования (import и from) программный код модуля загружается и выполняется, тольк окогда модуль импортируется в первый раз за время работы проги.

- При последующих попытках импорта модуль будет использ-ть объект уже загруженного модуля. Повторная загрузка и запуск кода при этом не происходит.

- Ф-ция reload принудительно выполняет повторную загрузку уже загруженного модуля и запускает его код. Инструкции присваивания при этом будут изменять существующий объект модуля.

Т.о. reload позволяет изменять части проги, не останавливая всю прогу. Напр. мы работаем с БД, которая при запуске соединяется с сервером - благодаря повторной загрузке изменения и настройки можно применять в ходе сеанса работы с БД, не перезапускаясь.

Модули загружаются динамически уже запущенной программой (нет компиляции/компоновки как на С), поввторная загрузка повышает призводительность таких систем. Сейчас (момент написания книги) ф-ция reload может работать только с модулями на Питоне, модули расширений не поддерживают такую операцию.

Примечание.

В 2.6 reload - встроенная ф-ция, а в 3.0 она перемещена в модуль imp, и доступна как imp.reload. Т.е. сначала нужно загрузит ьеё, выполнив import или from.


Основы использования функции reload.

В отличие от import, from:

- reload - это не инструкция, а функция.

- Ф-ции reload передается существующий объект модуля, а не имя.

- В 3.0 ф-ция reload находится в модуле imp, который нужно импортировать, чтобы получить доступ к ф-ции.

Ф-ция reload ожидает получить объект, поэтмоу к моменту её вызова модуль должен быть импортирован. К тому же синтаксис отличается от import, пример:

import modul			# Первоначальное импортирование 
...используются атрибуты модуля...
...						# Теперь выполняются изменения в файле модуля
...
from imp import reload	# Импортируем ф-цию reload (в 3.0)
reload(module)			# Загрузить обновленный модуль			
...используются атрибуты модуля...

Это типичная ситуация, напр. когда мы изменяем код загруженного модуля и хотим его перезагрузить.

Ф-ция reload - изменяет непосредственно сам объект модуля, она не удаляет и не создает его повторно. Т.е. все ссылки, имеющиеся в программе, автоматически будут учитывать изменения, произошедшие после в ходе повторной загрузки. 

Подробнее о ходе повторной загрузки:

- Ф-ция reload запускает новый программный код в файле модуля в текущем пространстве имен модуля. Текущее пространство имен перезаписывается.

- Инструкции присваивания на верхнем уровне файла замещают имена новыми значениями. Повторный запуск, например def, замещает предыдущую версию ф-ции в пространстве имен модуля, т.к. выполняет повторную операцию присваивания имени ф-ции.

- Повторная загрузка оказывает воздействие на всех клиентов, использовавших инструкцию import для получения доступа к модулю. После повторной загрузки клиенты будут получать новые значения атрибутов.

- Повторная загрузка будет воздействовать лишь на тех клиентов, которые еще только будут использовать инструкцию from в будущем. Клиенты, которые использовали from для получения доступа к атрибутам в прошлом, не заметят изменений, после повторной загрузки - они будут ссылаться на старые объекты, полученные до выполнения перезагрузки.


Пример использования reload.

Создадим модуль changer.py:

message = "First version"		# Имя связано со строкой
def printer():					# А это имя связано с ф-цией 
	print(message)

Импортируем модуль и вызовем ф-цию:

>>> import changer
>>> changer.printer()
First version

А теперь немного изменим файл модуля:

message = "After editing"
def printer():
	print('reloaded: ', message)
	
Попробуем снова импортировать модуль и затем перезагрузить его:

>>> import changer
>>> changer.printer()		# Используется прежняя версия модуля!
First version	

>>> from imp import reload
>>> reload(changer)					# Принудительная загрузка/выполнение нового кода
<module 'changer' from 'C:\\Python34\\changer.py'>
>>> changer.printer()				# Теперь заработала новая версия кода
reloaded:  After editing
	
Как видим, ф-ция reload, на самом деле, возвращает объект, поэтому интерпретатор и вывел строку <module 'changer' from 'C:\\Python34\\changer.py'>.


Повторная загрузка модуля.

Повторная загрузка может использ-ся и в крупных системах, где стоимость перезапуска всего приложения слишком высока, например системы соединенные с серверами сети.

Также эта возможность использ-ся в приложениях с графич. интерфейсом (напр. обработчики событий). И при использ-ии Питон в качестве встроенного языка в прогах на С или С++.    

Обычно повторная загрузка позволяет реализовывать высокодинамичные интерфейсы. Напр. Питон часто использ-ся для настройки больших систем (можно изменять код без перекомпиляции всей системы).

Также использ-ся для создания сценариев настройки в крупных системах.











Глава 23. Пакеты модулей.

 



  




















