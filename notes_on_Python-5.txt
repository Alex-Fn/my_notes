
Часть 6. Исключения и инструменты.  стр. 917


Глава 32. Основы исключений.  стр. 919

Исключения, по сути, явл-ся событиями, способными изменить ход выполнения программы. Исключения в Питон возбуждаются автоматически, когда код допускает ошибку, а также могут возбуждаться и перехватываться самими кодом.

Обрабатываются исключения четырьмя инструкциями. Эти инструкции мы и изучим. Первая инструкция имеет два вида ,а последняя явл-лась доп. расширением до выхода 2.6 и 3.0:

try/except - Перехватывает исключения, возбужденные инетр-ром или вашим программным кодом, и выполняет восстановительные операции.

try/finally - Выполняет заключительные операции независимо от того, возникло исключение или нет.

raise - Дает возможность возбудить исключение программно.

assert - Дает возможность возбудить исключение программно, при выполнении определенного условия.

with/as - Реализует менеджеры контекста в версиях 2.6 и 3.0 (в 2.5 явл-ся доп. расширением).


Зачем нужны исключения?

Исключения позволяют перепрыгнуть через фрагмент программы произвольной длины. Вспомним про нашу мащину по изготовлению пиццы и допустим мы её даже сделали.

Представим, что что-то пошло не так при "выпекании основы". Печь сломалась или робот ошибся. Понятно, что нам нужно предусмотреть быстрый переход к коду, которй быстро обрабатывает такие ситуации. А т.к. в таких условиях пиццы нам точно не получит нам нужно совсем остановить приготовление.

Это именно то, что позволяют делать исключения: программа может перейти к обработчику исключения за один шаг, отменив все вызовы ф-ций. После этого обработчик исключения может вып-ть действия, соответствующие ситуации.

Исключения - это своего рода "супер-goto". Обработчик исключений (инструкция try) ставит метку и вып-ет некий код. Если затем, где-то в программе, возникнет исключение, интер-р немедленно возвращается к метке, отменяя все активные вызовы ф-ций, которые были произведены после установки метки.

Это всё позволяет соотв. образом реагировать на необычные события. Кроме того, переход к обработчику исключения выполняется немедленно, поэтому нет нужды проверять коды возврата каждой вызванной ф-ции, которая могла потерпеть неудачу.


Назначение исключений.

Исключения в программах могу тиграть разные роли:

- Обработка ошибок. Интер-р возбуждает исключение каждый раз, когда обнаруживает ошибку во время выполнения программы. Прога может перехватывать такие ошибки и обрабатывать их или просто игнорировать. Если ошибка игнорируется, интер-р выполняет действия, предусмотренные по умолчанию - он останавливает выполнение проги и выводит сообщение об ошибке. Если такое поведение по умолч. явл-ся нежелательным, можно добавит ьинструкцию try, которая позволит перехватывать обнаруженные ошибки и продолжить выполнение проги после инструкции try.

- Уведомление о событиях. Исключения могут также использ-ся для уведомления о наступлении некоторых условий, что устраняет необходимость передавать куда-либо флаги рез-та или явно проверять их. Напр. ф-ция поиска может возбуждать исключение в случае неудачи, вместо того, чтобы возвращать целочисленный признак в виде рез-та.

- Обработка особых ситуаций. Некоторые условия могут наступать так редко, что было бы слишком расточительно предусматривать проверку наступления таких условий с целью их обработки. Нередко такие проверки обычных ситуаций можно заменить обработчикам исключений.

- Заключительные операции. Как будет показано далее, инструкция try/finally позволяет гарантировать выполнение завершающих операций независимо от наличия исключений.

- Необычное управление потоком выполнения. И, наконец, т.к. исключения - это своего рода оператор "goto", их можно использовать как основу для экзотического управления потоком выполнения программы. Напр. обратная трассировка не явл-ся частью самого языка, но она может быть реализована с пом. исключений и некоторой логики поддержки, выполняющей раскручивание операций присваивания. В Питоне отсутствует оператор goto, но исключения могут с успехом заменить его.



Обработка исключений: краткий обзор.  стр. 921


Обработчик исключений по умолчанию.

Предположим у нас есть ф-ция:

>>> def fetcher(obj, index):
		return obj[index]

Ф-ция просто извлекает элемент из объекта по заданному индексу. Если всё в порядке она возвращает рез-т:

>>> x = 'spam'
>>> fetcher(x, 3)		# То же, что x[3]
'm'

Но если ф-ции передать индекс, выходящий за пределы строки, то получим встр. исключение IndexError:

>>> fetcher(x, 4)					# Обработчик по умолч. - интерактивная оболочка
Traceback (most recent call last):
  File "<pyshell#7>", line 1, in <module>
    fetcher(x, 4)
  File "<pyshell#3>", line 2, in fetcher
    return obj[index]
IndexError: string index out of range
(выход индекса за пределы диапазона)

Т.к. наш код не перехватывает это исключение явно, оно возвращает выполнение на верх. уровень программы и вызывает обработчик исключений по умолч., который просто выводи тстандартное сообщение об ошибке. К этому времени мы видели уже много разных сообщений об ошибках. Они включают тип исключения, а также диагностическую информацию - список строк и ф-ций, которые были активны в момент появления исключения.

Текст ошибки может отличаться от версии интер-ра. При работе в интерактив. оболочке файлом явл-ся "<stdin>", т.е. стандарт. поток ввода:

>>> fetcher(x, 4)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in fetcher
IndexError: string index out of range

При рабоет в IDLE файлом явл-ся "<pyshell>" и доп. выводятся номера строк (так всё у нас и есть в примере, т.к. мы в основном работаем в IDLE).

В настоящей проге, запущенной не в оболочке, после сообщения об ошибке обработчик по умолч. сразу же завершает работу программы. Это имеет смысл для простых сценариев - как правило, ошибки в них должны быть фатальными и лучшее, что можно сделать - это ознакомиться с текстом ошибки.


Обработка исключений.

Но завершение работы не всегда, то, что нам нужно. Напр. серверные программы обычно должны быть аткивными даже после появления ошибок. Для этого нам нужн оперехватить исключение, обернув вызов ф-ции инструкцией try:

>>> try:
		fetcher(x, 4)
	except IndexError:
		print('got exception')
...
got exception
>>>

Т.о. видим, что когда исключение возникает при выполнении инструкций в блоке try, интер-р автоматич. переходит к нашему обработчику (блок под предложением except, в котором указано имя исключения). Пр иработе в оболочке, после выполнения блока except происходит возврат в приглашение к вводу. В настоящих прогах инструкции try не тольк оперехватывают исключения, но и вып-ют действия по восстановлению после ошибки:

>>> def catcher():
		try:
			fetcher(x, 4)
		except IndexError:
			print('got exception')
		print('continuing')
	
>>> catcher()
got exception
continuing
>>> 

Здесь, после того как исключение было перехвачено и обработано, программа продолжила выполнение инже всей инструкции try - именно поэтому в данном примере было выведено сообщение "continuing".  Стандартное сообщение об ошибке не появилось на экране, и программа продолжила работу как ни в чем не бывало.


Возбуждение исключений. 

Все эти исключения возбуждались интер-ром когда он встречал наши ошибки. Однако наши сценарии также способны возбуждать исключения - т.е. исключения могут возбуждаться интер-ром или самой прогой, и могут перехватываться или нет.

Чтобы возбудить исключение вручную, нужно просто выполнить инструкцию raise. Исключения, определяемые прогой, перехватываются также как и встроенные. Пример:

>>> try:
		raise IndexError
	except IndexError:
		print('got exception')
	
got exception  

Если исключение, определяемое прогой не перехватывается, оно будет передано обработчику по умолч., что приведет к завершению проги и сообщению об ошибке:

>>> raise IndexError
Traceback (most recent call last):
  File "<pyshell#26>", line 1, in <module>
    raise IndexError
IndexError

Исключения также могут возбуждаться с пом. инструкции assert - это условная форма инструкции raise, которая использ-ся в основном для отладки в процессе разработки:

>>> assert False, 'Nobody expects the Spanish Inquisition!'
Traceback (most recent call last):
  File "<pyshell#28>", line 1, in <module>
    assert False, 'Nobody expects the Spanish Inquisition!'
AssertionError: Nobody expects the Spanish Inquisition!


Исключения, определяемые пользователем.

Инструкция raise возбуждает встр. исключения, которые определены во встр. области видимости. Далее мы узнаем, что можно определять новые исключения для внутр. нужд своих программ.

Польз. исключения создаются в виде классов, наследующих один из классов встр. исключений, - обычно класс с именем Exception. Польз. исключения позволяют создавать категории исключений, наследовать поведение и добавлять к ним инфу о состоянии:

>>> class Bad(Exception):		# Пользовательское исключение
		pass

>>> def doomed():
		raise Bad()				# Возбудит экземпляр исключения

>>> try:
		doomed()
	except Bad:					# Перехватить исключение по имени класса
		print('got Bad')
	
got Bad
>>>     


Заключительные операции.

Наконец, инструкции try могут включать блоки finally. Эти блоки выглядят точно так же, как обработчики except. Комбинация try/finally определяет завершающие действия, которые всегда выполняются "на выходе", независимо от того, возникло исключение в блоке try или нет:

>>> try:
	fetcher(x, 3)
finally:
	print('after fetch')
	
'm'
after fetch
>>>

Здесь, если блок try выполнится без ошибок, будет выполнен блок finally и прога продолжит свою работу дальше. В этом случае данная инструкция окажется бессмысленной - мы могли бы просто добавить  print сразу вслед за вызовом ф-ции и вообще убрать try:

fetcher(x, 3)
print('after fetch')

Однако в таком подходе имется одна проблема: если в ф-ции возникнет исключение, инструкция print не будет выполнена. Комбинация try/finally позволяет ликвидировать эту проблему - когда в блоке try действительн опроизойдет исклюение, блок finally будет выполнен, пока программа будет раскручиваться:

>>> def after():
		try:
			fetcher(x, 4)
		finally:
			print('after fetch')
		print('after try?')

>>> after()
after fetch
Traceback (most recent call last):
  File "<pyshell#58>", line 1, in <module>
    after()
  File "<pyshell#57>", line 3, in after
    fetcher(x, 4)
  File "<pyshell#3>", line 2, in fetcher
    return obj[index]
IndexError: string index out of range 

Здесь мы не получили сообщение "after try?" потмоу что работа проги не была продолжена после блока try/finally, когда возникло исключение. Вместо этого интер-р выполнил действия, предусмотренные блоком finally, после чего исключение достигло предыдущего обработчика (в данном случае - обработчик по умолч.). Если изменить вызов внутри ф-ции after, чтобы он не вызывал исключение, блок finally все равно будет выполнен, но прога продолжит работу после выхода из try:

>>> def after():
		try:
			fetcher(x, 3)			# Изменили вызов с (х, 4) на (х, 3)
		finally:
			print('after fetch')
		print('after try?')
	
>>> after()
after fetch
after try? 

На практике, комбинацию try/except удобно использ. для перехвата и восстановления после исключений, а комбинацию try/finally - в случаях, когда нужно гарантировать выполнение заключительных действий независимо было исключение в try или нет.

Напр. try/except можно было бы ипольз. для перехвата ошибок, возникающих в импортированной библиотеке, созданной сторонним разработчиком, а комбинацию try/finally - чтобы гарантировать закрытие файлов и соединений с сервером.

Хоть эти две комбинации служат разным целям, начиная с Питон 2.5 появилась возможность смешивать предложения except и finally в одной и той же инструкции try - блок finally будет выполняться всегда, независимо от того, было ли перехвачено исключение предложением except.

Как узнаем далее, в 2.6 и 3.0 есть альтернатива try/finally, используемая с некоторыми типами объектов. Инструкция with/as выполняет логику, предусмотренную реализацией объекта, гарантируя выполнение заключительных операций:

>>> with open('spam.txt', 'w') as file:		# Всегда закрывает файл при выходе
	file.write('The larch!\n')
...	
11

- теперь у нас в файле spam.txt строка "The larch!".

Такой подход позволяет сократить объем программного кода, но может прмиеняться лишь с некоторыми типами объектов, поэтому try/finally - более универсальный способ заключ. операций. 


Проверка ошибок.

Полезность исключений можно увидеть просто сравнив программирование на Питон и на языке, не имеющим исключений. Напр. на С нам нужно проверят ьвозвращаемые значения или коды состояния после выполнения каждой операции, которая может быть выполнена с ошибкой и передавать рез-ты проверок в ходе выполнения проги:

doStuff()
{									# Программа на С
	if (doFirstThing() == ERROR)	# Проверить наличие ошибки
		return ERROR;				# даже если здесь она не обрабатывается
	if (doNextThing() == ERROR)
		return ERROR;
	...
	return doLastThing();	
}

main()
{
	if (doStuff() == ERROR)
		badEnding();
	else
		goodEnding();
}

Фактич. в настоящих прогах на С значительная доля всего кода выполняет проверку наличия ошибок. Но в Питон достаточно обернуть участки кода обработчиками исключений и писать эти участки в ожидании, что ошибок не будет:

def doStuff():
								# Код на Питон
	doFirstThing()				# Нас не беспокоят возможные исключения
	doNextThing()				# поэтому мы не выполняем проверку	
	...
	doLastThing()	


if __name__ == '__main__':
	
	try:
		doStuff()		# Здесь нас интересуют возможные рез-ты, 
	except:				# поэтмоу это единственное место, где нужна проверка 
		badEnding()
	else:
		goodEnding

Т.к. в случае исключения управление немедленно перейдет обработчику, здесь нет необходимости разбрасывать проверки по всему коду. Т.о. образом исключения позволяют игнорировать возможные необычные ситуации и отказаться от кода, выполняющего проверки на ошибки (как выше на С).

















Глава 33. Особенности использования исключений.  стр. 929


Инструкция try/except/else.  стр. 930

Сначала исследуем try/except/else и try/finally как разные инструкции, т.к. они не могут комбинироваться в Питон инже 2.5, а затем уже рассмотрим их комбинации.

Инструкция try - составная инструкция. Начинается с строки заголовка try, за которой идет блок инструкци (обычно с отступами), затем следует одно или более предложений except, которые определяют обрабатываемые исключения, и затем следует необязательное предложение else. Слова try, except и else должны располагаться на одном уровне. Пример полного формата:

try:
	<statements>			# Сначала выполняются эти действия
except <name1>:
	<statements>			# Запускается, если в блоке try возникло исключение name1
except (name2, name3):
	<statements>			# Запускается, если возникло любое из этих исключений	
except <name4> as <data>:
	<statements>			# Запускается в случае исключения name4 
							# и получает экземпляр исключения
except:
	<statements>			# Запускается для всех (остальных) возникших исключений
else:
	<statements>			# Запускается, если в блоке try не возникло исключения 
	
Блок под заголовком try представляет основное действие инструкции - код, который следует попытаться выполнить. Предложения except определяют обработчики исключений, возникших в ходе выполнения блока try, а предложение else (если оно есть) определяет обработчик для случая отсутствия исключений. Элемент <data> имеет отношение к особенности инструкции raise, которую обсудим позднее.

Опишем принцип действия инструкции try. Когда запускается инструкция try, интер-р помечает текущий конекст программы, чтобы вернуться к нему, если возникнет исключение. В первую очередь вып-ся инструкции, располож. под заголовком try. Дальше всё зависит будет ли возбуждено исключение в блоке try или нет:

- Если исключение в блоке try возникнет, интер-р вернется к инструкции try и выполнит первое предложение except, соответствующее возбужденному исключению. После выполнения блока except управление будет передано первой инструкции, находящейся за всей инструкцией try (при условии, что в блоке except не возникло другое исключение).

- Если в блоке try возникло исключение и не было найдено ни одного соответствия среди предложений except, исключение будет передано инструкции try, стоящей выше в программе, или на верх. уровень процесса (что вынудит интер-р аварийно завершить работу программы и вывести сообщение об ошибке по умолч.).

- Если в процессе выполнения блока try не возникло исключение, интер-р выполнит инструкции в блоке else (если они есть) и затем выполнение продолжится с первой инструкции, находящейся за всей инструкцией try.

Др. словами except перехватывают любые исключения, которые могут возникнуть при выполнении блока try, а блок else вып-ся тольк ов случае отсутствия исключений в блок try.

В предложениях except нах-ся обработчики исключений - они перехватывают исключения, которые возникли тольк ов инструкциях блока try. Однако инструкции блока try могут вызывать ф-ции, расположенные в разных частях программы, поэтому сам источник исключения может располагаться за пределами самой инструкции try. 


Предложения инструкции try.

Таблица 33.1 Различные формы предложений в инструкции try.  стр. 931

Некоторые мы уже знаем, напр. except, finally, else. В инструкции может присутствовать несколько предложений except, но только одно предложение else. Вплоть до 2.4 предложение finally должно было быть единственным (без else и except). На самом деле try/finally - это отдельная инструкция. Однако начиная с 2.5 предложение finally может присутствовать в той же инструкции, что и предложения except и else.

Есследованием доп. значения as value мы займемся, когда будем рассматривать инструкцию raise. Оно обеспечивает доступ к объекту, который играет роль исключения.

Новыми для нас явл-ся первая и четвертая строки в табл. 33.1:

- Предложения except, в которых отсутствуют имена исключений (except:), перехватывают все исключения, ранее не перечисленные в инструкции try;

- Предложения except, где в круглых скобках перечислены имена исключений (except (e1, e2, e3):), перехватывают любое из перечисленных исключений.

Интер-р просматривает предложения except сверху вниз в поисках соответствия, поэтому версию предложения с круглыми скобками можно рассматривать как аналог нескольким отдельным выражениям except, по одному для каждого исключения из списка, тольк ов этом слчае тело обработчика явл-ся общим для всех указанных исключений. Пример использ. нескольких except:

try:
	action()
except NameError:
	...
except IndexError:
	...
except KeyError:
	...
except (AttributeError, TypeError, SyntaxError):
	...
else:	
	...

Здесь, если при вып-иии	ф-ции action возникнет исключение, интер-р возвращается к инструкции try и пытается отыскать первое предложение except, в котором указано возникшее исключение. Поиск среди except ведется сверху вниз, слева направо, и вып-ся инструкции в первом найденном совпадении. Если совпадений не найдено, исключение продолжит распространение выше этой инструкции try. Помним, что блок else вып-ся только при отсутствии исключения в ф-ции action - этот блок не вып-ся при наличии исключения, которому не было найдено соответствующее предложение except.

Для перехвата всех исключений используйте пустое предложение except:

try:
	action()
except NameError:
	...
except IndexError:
	...
except: 		# Обраб-ть все остальные исключения, если нет NameError и IndexError
	...
else:	
	...
     
Предложение except без имени исключения - это, своего рода, шаблонный символ, т.к. перехватывает любые исключения, что позволяет создавать и универсальные и специфич. обработчики. В некоторых случаях эта форма более удобна, чем перечисление всех возможных исключений. Пример:

try:
	action()
except:
	...			# перехватить все возможные исключения
	
Однако применение пустых except несет и некоторые проблемы проектирования. Они могут перехватывать, напр., системные исключения не связанные с работой нашего кода, и случайн опрерывать распространение исключений, предназначенных для других обработчиков. Напр. даже выход из проги в Питон возбуждает исключение, и поэтому желательно такое исключение пропустить. Кроме того такая конструкция будет перехватывать исключения, вызванные обычными ошибками разработчика, которые нам навернка хотелось бы обнаружить и исправить. Т.е. предложение except требует внимательного отношения.

В 3.0 была введена альтернатива, - предложение except Exception имеет практич. тот же эффект, что и пустое except, но оно не перехватывает исключения, имеющие отношение к завершению программы (это один плюс, остальные минусы остались те же, что и у простого except):

try:
	action()
except Exception:
	...				# Перехватывает все исключения, кроме завершения программы 

Примечание.	В 3.0 нужно использ. форму предложения except E as V:, вместо старой формы except E, V:. Это сделано, чтобы не путать эту форму с указанием двух и более альтернативных исключений вида except (E1, E2):. Кроме того, при использовании ключевого слова as переменная V автоматич. удаляется в конце блока except (очищается память).


Предложение try/else.

Нзначение предложения else в инструкции try, для новичков Питона, не всегда очевидно. Но все-таки без этого предложения нет никакого способа узнать (без установки и проверки флагов) - выполнение проги продолжилось потому, что исключение в блоке try не было возбуждено, или потому, что исключение перехвачено и обработано:

try:
	... выполняемый код ...
except IndexError:
	... обработка исключения ...
# Программа оказалась здесь потому, что исключение было обработано
# или потому, что его не возникло?  	

Так же как и в операторах цикла, else в try однозначно и очевидно сообщает о произошедшем:  	

try:
	... выполняемый код ...
except IndexError:
	... обработка исключения ...
else:
	... исключение не было возбуждено ...	
 
То же самое поведение можно имитировать, переместив содержимое блока else в блок try:

try:
	... выполняемый код ...
	... исключение не было возбуждено ...
except IndexError:
	... обработка исключения ...

Но такой ход может привести к некорректной классификации исключения. Если какая-либо инструкция в блоке "исключение не было возбуждено" приведет к появлению исключения IndexError, оно будет зарегистрировано как ошибка в блоке try и соответственно, ошибочно будет передано обработчику исключения ниже (тонко, но верно!).

Прия вном использ. else логика выполнения становится более очевидной и гаранитруется, что обработчики исключений будут вызываться только для обработки истинных ошибок в блоке, обернутом инструкцией try, а не при выполнении действий, предусматриваемых в блоке else.


Пример: поведение по умолчанию.  

Мы знаем, что исключения, не перехваченные try, распространяются до самого верхнего уровня процесса и запускают логику обработки исключений по умолч. (т.е. интер-р аварийно замершает работу проги и выводит сообщение об ошибке). Пример, с делением на ноль:

def gobad(x, y):
	return x / y

def gosouth(x):
	print(gobad(x, 0))

gosouth(1)	

Т.к. прога сама не обрабатывает это исключение, интер-р завершает её и выводит сообщение (в книге сообщение немного длиннее, там они запускали под 3.0, а у нас уже 3.4):

C:\Python34>bad.py
Traceback (most recent call last):
  File "C:\Python34\bad.py", line 8, in <module>
    gosouth(1)
  File "C:\Python34\bad.py", line 6, in gosouth
    print(gobad(x, 0))
  File "C:\Python34\bad.py", line 3, in gobad
    return x / y
ZeroDivisionError: division by zero 

Сообщение состоит из содержимого стека вызовов ("Traceback") и имени (с доп. данными) исключения. В содержимом стека перечислены все строки, которые были активны в момент появления исключения, в порядке от более старых к более новым.
Обратите внимание, что в командной строке (не в оболочке) имена файлов и номера строк содержат для нас полезную инфу. Например, здесь видно, что ошибка произошла в 3-й строке в файле bad.py в инструкции return. 

Замечание. В моей IDLE версии 3.4 инфа та же самая, т.е. у командной строки, по состоянию инфы,  особого преимущества не видно. Ну это просто замечание, даже сам автор подчеркивает, что может оболочка выводить и полезную инфу.

Т.к. интер-р определяет и сообщает обо всех ошибках, появившихся во время выполнения программы, возбуждая исключения, эти исключения тесно связаны с идеями обработки ошибок и отладки вообще. Да мы и сами встречались с сообщениями об ошибках и даже пытались по ним искать причину. Естественно большинство из них были синтаксическими, но были и функциональные конечно.


Пример: перехват встроенных исключений.

Обработка интер-ром по умолч. чаще всего удовлетворяет всем потребностям, особенно для программного кода верхнего уровня, где ошибки должны приводить к немедленному завершению программы. Для большинства программ нет нужды особой обработки ошибок.

Однако иногда нужно перехватить ошибку и вып-ть восстановительные действия после неё. Или если не хотим, чтобы программа завершалась после ошибки. Это очень важно для серверов сети, например, которые должны работать не смотря ни на что.

Пример, перехват и обработка исключения TypeError, при попытке конкатенации списка и строки (а должны быть последовательности одного типа):

def kaboom(x, y):
	print(x + y)				# Это место возбуждает исключение TypeError
	
try:
	kaboom([0, 1, 2], "spam")
except TypeError:				# Исключение перехватывается и обрабатывается здесь
	print('Hello World!')
print('resuming here') 			# Прога работает дальше, не зависимо было или нет исключение

Когда в ф-ци иkaboom возникает исключение, управление передается предложению except в инструкции try, где выводится текст сообщения. После того как исключение перехв-ся оно становится неактуальным, поэтому прога продолжает выполнение ниже инструкции try вместо того, чтобы завершиться:

C:\Python34>kaboom.py
Hello World!
resuming here

Внимание, - как только ошибка будет перехвачена, вып-ие продолжается с того места, где ошибка была перехвачена (т.е. после инструкции try), - нет никакой возможности вернуться к тому месту, где возникла ошибка (т.е. в ф-цию kaboom). Это делает исключения похожими на инструкцию перехода, - нет никакой возможности вернуться к коду, вызвавшему ошибку.


Инструкция try/finally.  стр. 936

Др. разновидность инструкции try специализируется на выполнении заключ. операций. Если в try включено предложение finally, интер-р всегда будет выполнять блок инструкций при "выходе" из инструкции try независимо от того, произошло ли исключение во время вып-ия инструкций в блоке try. Общая форма:

try:
	<statements>		# Выполнить эти действия первыми
finally:
	<statements>		# Всегда выполнять этот блок кода при выходе	

В первую очередь вып-ся инструкции в блоке try. Дальнейшее зависит от того возникло ли исключение в блоке try:

- Если в блоке try исключение не возникло, интер-р переходит к вып-ию блока finally и затем продолжает вып-ть программу ниже инструкции try.

- Если в блоке try возникло исключение, интер-р также вып-ит инструкции в блоке finally, но, после этого, исключение продолжит своё распространение до вышестоящей инструкции try или до обработчика исключений по умолч. - прога не будет вып-ся вслед за try. Т.е. инструкци ив блоке finally будут выполнены, даже если исключение будет, но в отличие о except, предложение finally не завершает распространение исключения - оно остается актуальным после вып-ия блока finally.

Форму try/finally удобно использ. когда нужно гаранитровать вып-ие некоторых действий. С практич. стороны, эта форма инструкции позволяет определять завершающие действия, которые должны вып-ся всегда, напр. закрытие файлов или закрытие соединений с сервером.

В Питон 2.4 и ниже finally не может использ. в той же инструкции try, где уже использ. предложение except или else, поэтому форму try/finally лучше считать отдельной формой инструкции при работе со старыми версиями.

Позднее узнаем, что в 2.6 и 3.0 инструкция with и конектстные менеджеры обеспечивают объектно-ориентированный подход к вып-ию аналогичных завершающих действий. Но, в отличие от finally, эта новая инструкция поддерживает возможность вып-ия действий по инициализации, хотя и ограничивается областью видимости объектов, которые реализуют протокол менеджеров контекста.


Пример: реализация завершающих действий с помощью инструкции try/finally.

Приведем типичный пример использ. инструкции try/finally:

class MyError(Exception): pass

def stuff(file):
	raise MyError()
	
file = open('data', 'w')	# Открыть файл для вывода
try:
	stuff(file)				# Возбуждает исключение
finally:
	file.close()			# Всегда закрывать файл, чтобы вытолкнуть буферы
print('not reached')		# Продолжить с этого места,
							# только если не было исключения
   
Итак, здесь мы обернули вызов ф-ции в инструкцию try с предложением finally, чтобы гаранитровать закрытие файла при любых обстоятельствах.

Как мы знаем, объекты файлов автоматич. закрываются на этапе сборки мусора, что очень удобно с временными файлами. Однако не всегда можно предсказать время сборки мусора, особенно в больших прогах. Инструкция try делает закрытие файла явной операцией, предсказуемой. Она гарантирует, что файл будет закрыт при выходе из блока, не зависимо было исключение или нет.

Ф-ция здесь у нас просто генерирует исключение. А мы еще раз напоминаем - интер-р всегда выполняет код в блоке finally, независимо было исключение в блоке try или нет.

Когда ф-ция возбуждает исключение, управление перед-ся инструкции try и начинает вып-ся блок finally, в котором производится закрытие файла. После этого исключение продолжает своё распространение либо пока не встретит др. инструкцию try, либо пока не буде тдостигнут обработчик по умолч., который выведет сообщение об ошибке и остановит прогу - инструкция, находящаяся ниже инструкции try никогда не будет достигнута.

Если бы ф-ция в этом примере не возбуждала исключение, прога точно так же выполнила бы блок finally, чтобы закрыть файл, и затем продолжила бы своё выполнение ниже инструкции try. Также обратите внимание - исключение опять определено как класс.


Объединенная инструкция try/except/finally.

В Питон 2.6 и 3.0 можно объединять инструкции finally и except/else в одной конструкции. Т.е. посмотрим пример:

try:
	основное действие
except Exception1:
	обработчик_1 
except Exception2:
	обработчик_2
...
else:
	блок else
finally:
	блок finally	

Первым, конечно же, выполняется код в блоке "основное действие". Если в нем возбуждается исключение, вып-ся проверка всех блоков except, одно за другим, в поисках соотествия исключению. Если возбуждено исключение Exception1 то вып-ся блок "обработчик_1", если исключение Exception2, то вып-ся блок "обработчик_2". Если в блоке try не возникло исключение, то буде твыполнен "блок else".

И вот уже затем, после всех этих действий, будет выполнен "блок finally". Причем будет выполнен даже если исключение возникнет в самом обработчике или блоке else.

Как всегда, finally не прекращает распространение исключения - если к моменту вып-ия блкоа finally есть активное исключение, оно продолжит своё распространение после блока finally и управление передается куда-то в др. место проги. Если к моменту вып-ия блкао finally нет исключений, выполнение проги продолжится сразу же вслед за инструкцией try.

Т.о. блок finally выполняется всегда, когда:

- В блоке основного действия возникло исключение и было обработано;

- В блоке основного действия возникло исключение и не было обработано;

- В блоке основного действия не возникло исключение;

- В одном из обработчиков возникло новое исключение.

Напомним, предложение finally служит, чтобы организовать выполнение завершающих действий, которые должны вып-ся всегда при выходе из инструкции try независимо от того, было исключение или нет.



Синтаксис объединенной инструкции try.  стр. 940

Инструкция try, как минимум, должна содержать либо предложение except, либо предложение finally и порядок таков:

try -> except -> else -> finally

где else и finally явл-ся необязательными и можеть быть ноль и более предложений except, но в случае присутствия предложения else должно быть указано хотя бы одно предложение except. В действительности инструкция try состоит из двух частей: из предложений except с необязательным предложением else и/или предложения finally.

Опишем синтаксис объединенной инструкции (квадртные скобки означают необязательную формпу, а звездочка значит "ноль и более раз"):

try:						# Формат 1
	statements
except [type [as value]]:
	statements
[except [type [as value]]:	
	statements]*
[else:
	statements]
[finally:
	statements]	

try:					# Формат 2
	statements
finally:
	statements	

Согласно этим правилам else может присутствовать, только если в инструкции есть хоть одно предложение except, и всегда можно одновременно указывать except и finally, независимо от наличия else.

Кроме того, допускается одновременно указывать finally и else, но только если в инструкции присутствует предложение except. А если порядок следования предложений будет нарушен, то интер-р возбудит исключение о синтаксической ошибке.


Объединение finally и except вложением.

До 2.5 существовала возможность объединять finally b except в инструкции try за счет вложения инструкции try/except в блок try инструкции try/finally (более полно рассмотрим этот прием в гл. 35). На самом деле фрагмент ниже имеет тот же эффект, что и новая форма инструкции, представленная в начале этого раздела:

try:
	try:
		основное действие
	except Exception1:
		обработчик_1
	except Exception2:
		обработчик_2
	...
	else:
		нет ошибок
finally:
	завершающее действие

Здесь блок finally всегда вып-ся при выходе из инструкции try независимо от того, что произошло в блоке основного действия, и независимо от того, выполнялись ли обработчики исключений во вложенной инструкции try. Т.к. else всегда требует наличия хотя бы одного предложения except, эта вложенная форма тмеет те же ограничения, что и объединенная форма инструкции.

Но этот эквивалент выглядит менее понятно, чем новая, объединенная, форма инструкции, и для её записи требуется больше программного кода (минимум на одну строку). Смешанная форма инструкции проще в написании и выглядит понятнее, поэтому такая форма записи считается в настоящее время предпочтительной.


Пример использования объединенной инструкции try.

В файле merged.py представлены четыре типичных варианта с инструкциями print, описывающими значение каждого из них:

sep = '-' * 32 + '\n'
print(sep + 'EXCEPTION RAISED AND CAUGHT')
try:
	x = 'spam'[99]
except IndexError:
	print('except run')
finally:
	print('finally run')
print('after run')

print(sep + 'NO EXCEPTION RAISED')
try:
	x = 'spam'[3]
except IndexError:
	print('except run')
finally:
	print('finally run')
print('after run')

print(sep + 'NO EXCEPTION RAISED, EITH ELSE')
try:
	x = 'spam'[3]
except IndexError:
	print('except run')
else:
	print('else run')	
finally:
	print('finally run')
print('after run')

print(sep + 'EXCEPTION RAISED BUT NOT CAUGHT')
try:
	x = 1/0
except IndexError:
	print('except run')
finally:
	print('finally run')
print('after run')

Запустим наш код:

C:\Python34>merged.py
--------------------------------
EXCEPTION RAISED AND CAUGHT
except run
finally run
after run
--------------------------------
NO EXCEPTION RAISED
finally run
after run
--------------------------------
NO EXCEPTION RAISED, EITH ELSE
else run
finally run
after run
--------------------------------
EXCEPTION RAISED BUT NOT CAUGHT
finally run
Traceback (most recent call last):
  File "C:\Python34\merged.py", line 33, in <module>
    x = 1/0
ZeroDivisionError: division by zero

Этот пример в основном действии использует встр. операции и полагается на тот факт, что интер-р всегда определяет появление ошибок во время выполнения кода.



Инструкция raise.  стр. 943

Чтобы явно возбудить исключение, можно использ. инструкцию raise. Синтаксис - инструкция raise состоит из слова raise, за которым может следовать имя класса или экземпляр возбуждаемого исключения:

raise <instance>		# Возбуждает экземпляр класса-исключения
raise <class>			# Создает и возбуждает экземпляр класса-исключения
raise					# Повторно возбуждает самое последнее исключение

В Питон 2.6 и 3.0 исключение - это всегда экземпляр класса. Поэтому первая форма инструкции raise явл-ся наиболее типичной - ей непосредственно передается экземпляр класса, котоырй создается перед вызовом инструкции raise или внутри неё.

Если raise передается класс, интер-р вызовет конструктор класса без аргументов, а полученный экземпляр передаст инструкции raise - если после имени класса добавить круглые скобки, мы получим эквивалентную форму.

Третья форма raise просто повторно возбуждает текущее исключение - это удобно, когда возникает необходимость передать перехваченное исключение другому обработчику.

Примеры, эквивалентные друг другу:

raise IndexError		# Класс (экземпляр создается неявно)
raise IndexError()		# Экземпляр (создается в инструкции)

Мы можем и заранее создать экземпляр - raise принимает ссылки на объекты любого типа, примеры:

exc = IndexError()
raise exc

excs = [IndexError, TypeError]
raise excs[0]

При исключении интер-р отправляет возбужденный экземпляр вместе с исключением. Есди try включает предложение вида except name as X:, переменной Х будет присвоен экземпляр, переданной инструкции raise:

try:
	...
except IndexError as X:		# Переменной Х будет присвоен экземпляр исключения	

Ключ. слово as явл-ся необязательным в обработчиках инструкции try (если оно опущено, интер-р просто не будет присваивать экземпляр переменной), но с его помощью можно получить доступ к данным экземпляра и методам класса исключения.

Так же действуют и исключения определяемые пользователем в виде классов. Пример, передача аргумента конструктору класса исключения, знач. которого становится доступным в обработчике через экземпляр, присвоенный переменной:

class MyExc(Exception): pass
...
raise MyExc('spam')			# Вызов конструктора класса с аргументом
...
try:
	...
except MyExc as X:			# Атрибуты экземпляра доступны в обработчике
	print(X.args)

Независимо какие исключения используются, они всегда идентифицируются обычными объектами и только одно исключение может быть активным в каждый конкретный момент времени. Как тольк оисключение перехватывается except, находящимся в любом месте проги, исключение деактивируется (т.е. не будет передано др. инструкции try), если не будет повторно возбуждено при помощи raise или простой ошибки.


Пример: возбуждение и обработка собственных исключений.

Итак, собственное исключение будет представлено объектом экземпляра класса (как и должно быть), как напр. MyBad у нас:

class MyBad: pass

def stuff():
	raise MyBad()		# Возбудит исключение вручную
try:
	stuff()				# Возбуждает исключение
except MyBad:	
	print('got it')		# Здесь вып-ся обработка исключения
...						# С этого места продолжается выполнение программы

Здесь исключение происходит внутри ф-ции, но это не имеет значения - управление немедленно передается блоку except. Видим, что инструкция try перехватывает собственные исключения программы так же, как и встр. исключения.


Пример: повторное возбуждение исключений с помощью инструкции raise.

Инструкция raise, в которой нет имени исключения или нет доп. данных, просто повторно возбуждает текущее исключение. Это делают, например, когда нужно перехватить и обработать исключение, но при этом не требуется деактивировать исключение:

>>> try:
		raise IndexError('spam')		# Исключения сохраняют аргументы
	except IndexError:
		print('propagating')
		raise							# Повторное возбуждение последнего исключения	
...
propagating
Traceback (most recent call last):
  File "<pyshell#6>", line 2, in <module>
    raise IndexError('spam')
IndexError: spam 

Видим как здесь raise повторно возбуждает исключение, которое затем передается обработчику более высокого уровня (или обработчику по умолч., который останавливает выполнение проги и выводи тсообщение об ошибке). Обратим внимание, как отображается значение аргумента в тексте сообщения об ошибке, который был передан конструктору класса - почему это происходит узнаем в след. главе.


Измнения в Python 3.0: raise from.

В 3.0 (но не в 2.6) raise может включать доп. предложение from:

raise exception from otherexception

При использ. from второе выражение определяет еще один класс исключения или экземпляр, который будет присвоен атрибуту __cause__ возбуждаемого исключения. Если исключение не будет перехвачено, интер-р выведет инфу об обоих исключениях:

>>> try:
	1/0
except Exception as E:
	raise TypeError('Bad!') from E

Traceback (most recent call last):
  File "<pyshell#12>", line 2, in <module>
    1/0
ZeroDivisionError: division by zero

The above exception was the direct cause of the following exception:
(Исключение выше стало прямой причиной следующего исключения:)

Traceback (most recent call last):
  File "<pyshell#12>", line 4, in <module>
    raise TypeError('Bad!') from E
TypeError: Bad! 

Когда исключение возбуждается в обработчике исключения, подобная процедура вып-ся неявно: предыдущее исключение присваивается атрибуту __context__ нового исключения и также выводится к стандартный поток ошибок, если исключение не будет перехвачено.

Примечание.

В 3.0 больше неподдерживается форма raise Exc, Args, которая все еще есть в 2.6. Вместо неё в 3.0 нужно использ. описанную выше форму raise Exc(Args), которая создает экземпляр исключения.



Инструкция assert.

Инструкция assert действует в качестве особого случая возбуждения исключений на этапе отладки. Это сокращенная форма типичного шаблона raise, которая представляет собой условную инструкцию raise. Инструкция вида:

assert <test>, <data>		# Часть <data> является необязательной

представляет собой эквивалент следующего фрагмента:

if __debug__:
	if not <test>:
		raise AssertionError(<data>)
		
Др. словами, если условное выражение возвращает ложное значение, интер-р возбуждает исключение: элемент данных (если он есть) играет роль аргумента конструктора исключения. Как и все исключения,  AssertionError приводит к завершению проги, если не будет перехвачено инструкцией try, и в этом случае элемент данных отображается как часть сообщения об ошибке.

Есть доп. возможность удалить все инструкции assert из скомпилированного байт-кода проги за счет использ. флага командной строки -0 при запуске интер-ра и тем самым оптимизировать прогу. Исключение AssertionError явл-ся встроенным исключением, а мя __debug__ - встр. флагом, который автоматич. получает знач. True (истина), когда не использ. флаг -0. Использ. команду фида python -0 main.py, чтобы запустить прогу в оптимизированном режиме и отключить все инструкции assert.


Пример: проверка соблюдений ограничений (но не ошибок).

Обычно assert использ. для проверки условий выполнения проги во время разработки. При отображении в текст сообщений об ошибках, полученных в рез-те вып-ия инструкции assert, автоматич. выключается инфа из строки исходного кода и значения, перечисленные в инструкции. Пример файла asserter.py:

def f(x):
	assert x < 0, 'x must be negative'
	return x ** 2
	
>>> import asserter
>>> asserter.f(1)
Traceback (most recent call last):
  File "<pyshell#16>", line 1, in <module>
    asserter.f(1)
  File "C:\Python34\asserter.py", line 2, in f
    assert x < 0, 'x must be negative'
AssertionError: x must be negative

Нужно не забывать, что инструкция assert глав. образом предназначена для проверки соблюдения ограничений, накладываемых программистом, а не для перехвата настоящих ошибок. Т.к. интер-р сам может находить ошибки, обычно нет нужды использ. assert для выявления таких проблем, ка квыход индекса за пределы, несоответствие типов или деление на ноль:

def reciprocal(x):
	assert x != 0		# Бесполезная инструкция assert!
	return 1/x			# Интер-р автоматич. проверит х на равенство нулю
   	
Такие инструкции assert явл-ся лишними, т.к. с подобными ошибками интер-р разберется и сам.	Еще один пример использ. assert приводится в примере абстрактного суперкласса в гл. 28 - там assert использ. для того, чтобы вызов неопределенных методов приводил к исключению с определенным текстом сообщения.



Конекстные менеджеры with/as.  стр. 948

Инструкция with, с необязательным предложением as, предназначена для работы с объектами контекстных менеджеров, которые поддерживают новый протокол взаимодействия, основанный на использовании методов. Эта особенность доступна и в 2.5 в виде расширения, которое активируется инструкцией:

from __future__ import with_statement

Инструкция with/as может использ. как альтернатива известной идиомы try/finally; подобно этой инструкции она предназначена для вып-ия заключительных операций независимо, возникло ли исключение на этапе вып-ия основного действия. Но, в отличие от try/finally, инструкция with поддерживает более богатый возможностями протокол, позволяющий определять как предварительные, так и заключительные действия для блока кода.

Питон дополняет некоторые встр. средства контекстными менеджерами, напр. файлы, которые закрываются автоматич., или блокировки потоков выполнения, которые автоматич. запираются и отпираются. Но мы можем создавать с классами и свои контекстные менеджеры.


Основы использования.

Основная форма with:

with выражение [as переменная]:
	блок with

Здесь предполагается, что выражение возвращет объект, поддерживающий протокол конекстного менеджера. Этот объект может возвращать значение, которое будет присвоено переменной, если присутствует необязательное предложение as.

Заметьте, что переменной необязательно будет присвоен результат выражения - результатом выражения явл-ся объект, который поддерживает контекстный протокол, а переменной может быть присвоено некоторое др. значение, предназначенное для использ. внутри ф-ции. Объект, возвращаемый выражением, может затем выполнять предварительные действия после того, как этот блок будет выполнен, независимо от того. было ли исключение при его выполнении.

Некоторые встр. объекты Питон были дополнены поддержкой протокола управления контекстом и потому могут использ. в инструкции with. Напр. объекты файлов имеют менеджер контекста, который автоматич. закрывает файл после вып-ия блока with независимо от того, было ли исключение:

with open(r'C:\misc\data') as myfile:
	for line in myfile:
		print(line)
		... остальной программный код ...
		
Здесь, ф-ция open возвращает объект файла, который присваивается имени myfile. К переменной myfile можем применять обычные средства, предназначенные для работы с файлами, - в данном случае с пом. итератора вып-ся чтение строки за строкой в цикле for.

Но данный объект поддерживает протокол управления контекстом, используемый инструкцией with. После того как with начнет выполнение, механизм управления контекстом гарантирует, что объект файла, на который ссылается переменная myfile, будет закрыт автоматич., даже если в for во время обработки файла произойдет исключение.

Мы не знаем точно в какой момент сборщик мусора закроет файл. Инструкция with дает альтернативу, позволяющую гаранитровать, что файл будет закрыт сразу после выполнения определенного блока кода. Конечно можно использ. try/finally, но кода будет больше:

myfile = open(r'C:\misc\data')
try:
	for line in myfile:
		print(line)
		... остальной программный код ...
finally:
	myfile.close()
	
Многопоточную модель мы здесь изучать не будем, но блокировка и средства синхронизации посредством условных переменных также поддерживаются инструкцией with за счет обеспечения поддержки протокола управления контекстом:

lock = threading.lock()
with lock:
	# Критическая секция программного кода	
	... доступ к совместно используемым ресурсам ...
	
Здесь механизм управления контекстом гарантирует, что блокировка автоматич. будет приобретена до того, как начнет вып-ся блок, и освобождена по завершении работы блока независимо от того, было ли исключение.

Модуль decimal, из гл. 5, также использ. менеджеры контекста для упрощения сохранения и восстановления текущего контекста вычислений, определяющего параметры точности и округления, используемые в вычислениях:

with decimal.localcontext() as ctx:
	ctx.prec = 2
	x = decimal.Decimal('1.00') / decimal.Decimal('3.00')

После вып-ия этой инструкции менеджер локального контекста текущего потока вып-ия автоматич. восстановит его в прежнее состояние, предшествовавшее началу вып-ия инструкции.


Протокол управления контекстом.

Некоторые встр. типы уже имеют менеджер контекстов, и мы сами можем добавлять менеджеры контекстов в свои классы. Для реализации использ. спец. методы классов, т.н. методы перегрузки операторов и они обеспечивают взаимодействие с with. Интерфейс, который должны реализовать объекты для использ. совместно с with, достаточно сложен, хотя чаще достаточно знать, как использ. существующие контексты менеджеров. 

Коротко рассмотрим основные принципы, опишем работу инструкции with:

1. Производится вычисление выражения, возвращающего объект, известный как менеджер контекста, который должен иметь методы __enter__ и __exit__.

2. Вызывается метод __enter__ менеджера контекста. Возвращаемое значение метода присв-ся переменной в предложении as, если оно есть, в ином случае значение просто уничтожается.

3. Затем вып-ся блок кода, вложенный в инструкцию with.

4. Если, при вып-ии блока, возбуждается исключение, вызывается метод __exit__ (тип, значение, диагностическая_инфа), которому передается подробная инфа об исключении. Заметьте, что это те же самые значения, которые возвращает ф-ция sys.exec_info, описываемая в руководстве Питона и в книге. Если этот метод возвращает ложное значение, исключение возбуждается повторно, в противном случае исключение деактивируется. Обычно исключение следует возбуждать повторно, чтобы оно могло выйти за пределы инструкции with.

5. Если в блоке with исключение не возникнет, метод __exit__ всё равно вызывается, но в аргументах тип, значение и диагностическая_информация ему передается значение None.

Рассмотрим небольшой пример, демонстрирующий работу протокола. Следующий фрагмент определяет объект менеджера контекста, который сообщает о входе и выходе из блока программного кода любой инструкции with, с которой он используется:

class TraceBlock:
	def message(self, arg):
		print('running', arg)
	def __enter__(self):
		print('starting with block')
		return self
	def __exit__(self, exc_type, exc_value, exc_tb):
		if exc_type is None:
			print('exited normally\n')
		else:
			print('raise an exception!', exc_type)
			return False							# Повторное возбуждение

with TraceBlock() as action:
	action.message('test 1')
	print('reached')

with TraceBlock() as action:
	action.message('test 2')
	raise TypeError
	print('not reached')    

Обратите внимание, что метод __exit__ должен возвращать False, чтобы разрешить дальнейшее распространение исключения - отсутствие инструкции return обеспечивает тот же самый эффект, потому что в этом случае по умолчанию возвращается знач. None, которое по сути явл-ся ложным.

Следует заметить, что метод __enter__ возвращает сам объект self, который присваивается переменной в предложении as; при желании этот метод может возвращать совершенно другой объект.

При запуске этого фрагмента менеджер контекста с пом. своих методов __enter__ и __exit__ отмечает моменты входа и выхода из блока инструкции with. Приводим работу этого сценария:

C:\Python34>withas.py
starting with block
running test 1
reached
exited normally

starting with block
running test 2
raise an exception! <class 'TypeError'>
Traceback (most recent call last):
  File "C:\Python34\withas.py", line 20, in <module>
    raise TypeError
TypeError

Менеджеры контекста явл-ся новыми механизмами, предназначенными для разработчиков инструментальныхз средств, поэтому мы не будем рассматривать доп. подробности. В более простыхслучаях try/finally обеспечивает достаточную поддержку для выполнения завершающих действий.

В версии 3.1 (ну навернео и в нашей 3.4) в инструкции with можно будет определять сразу несколько (иногда их называют "вложенными") менеджеров контекста через запятую. В примере, напр. при выходе из блока инструкции with автоматич. вып-ся заключительные операции для обоих файлов независимо от наличия исключений:

with open('data') as fin, open('res', 'w') as fout:
	for line in fin:
		if 'some key' in line:
			fout.write(line)
			
В одной инструкции with может быть перечислено любое количество менеджеров контекста, которые будут действовать как влож. инструкции with. Вообще реализация в 3.1 (и выше)Ж

with A() as a, B() as b:
	... инструкции ...
	
эквивалентна следующей реализации, которая будет работать в 3.1, 3.0 и 2.6:

with A() as a:
	with B() as b:
		... инструкции ...
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
Глава 34. Объекты исключений.  стр. 954

		
		




















	
	

  

 

  

